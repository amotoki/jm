# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2012-04-23 07:54+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=CHARSET\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#: build/C/man3/bsd_signal.3:23
#, no-wrap
msgid "BSD_SIGNAL"
msgstr ""

#. type: TH
#: build/C/man3/bsd_signal.3:23 build/C/man2/getitimer.2:7
#, no-wrap
msgid "2009-03-15"
msgstr ""

#. type: TH
#: build/C/man3/bsd_signal.3:23 build/C/man2/eventfd.2:21 build/C/man2/getitimer.2:7 build/C/man3/gsignal.3:25 build/C/man2/kill.2:44 build/C/man2/killpg.2:40 build/C/man2/pause.2:30 build/C/man2/prctl.2:46 build/C/man3/profil.3:28 build/C/man3/psignal.3:28 build/C/man3/raise.3:27 build/C/man2/rt_sigqueueinfo.2:23 build/C/man2/sgetmask.2:24 build/C/man2/sigaction.2:45 build/C/man2/sigaltstack.2:25 build/C/man7/sigevent.7:24 build/C/man3/siginterrupt.3:29 build/C/man2/signal.2:34 build/C/man7/signal.7:44 build/C/man2/signalfd.2:19 build/C/man3/sigpause.3:23 build/C/man2/sigpending.2:27 build/C/man2/sigprocmask.2:27 build/C/man3/sigqueue.3:26 build/C/man2/sigreturn.2:27 build/C/man3/sigset.3:24 build/C/man3/sigsetops.3:29 build/C/man2/sigsuspend.2:27 build/C/man3/sigvec.3:24 build/C/man3/sigwait.3:24 build/C/man2/sigwaitinfo.2:23 build/C/man3/sysv_signal.3:23 build/C/man2/timer_create.2:29 build/C/man2/timer_delete.2:23 build/C/man2/timer_getoverrun.2:23 build/C/man2/timer_settime.2:23 build/C/man2/timerfd_create.2:20 build/C/man2/tkill.2:29 build/C/man2/wait.2:50 build/C/man2/wait4.2:34
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr ""

#. type: SH
#: build/C/man3/bsd_signal.3:24 build/C/man2/eventfd.2:22 build/C/man2/getitimer.2:8 build/C/man3/gsignal.3:26 build/C/man2/kill.2:45 build/C/man2/killpg.2:41 build/C/man2/pause.2:31 build/C/man2/prctl.2:47 build/C/man3/profil.3:29 build/C/man3/psignal.3:29 build/C/man3/raise.3:28 build/C/man2/rt_sigqueueinfo.2:24 build/C/man2/sgetmask.2:25 build/C/man2/sigaction.2:46 build/C/man2/sigaltstack.2:26 build/C/man7/sigevent.7:25 build/C/man3/siginterrupt.3:30 build/C/man2/signal.2:35 build/C/man7/signal.7:45 build/C/man2/signalfd.2:20 build/C/man3/sigpause.3:24 build/C/man2/sigpending.2:28 build/C/man2/sigprocmask.2:28 build/C/man3/sigqueue.3:27 build/C/man2/sigreturn.2:28 build/C/man3/sigset.3:25 build/C/man3/sigsetops.3:30 build/C/man2/sigsuspend.2:28 build/C/man3/sigvec.3:25 build/C/man3/sigwait.3:25 build/C/man2/sigwaitinfo.2:24 build/C/man3/sysv_signal.3:24 build/C/man2/timer_create.2:30 build/C/man2/timer_delete.2:24 build/C/man2/timer_getoverrun.2:24 build/C/man2/timer_settime.2:24 build/C/man2/timerfd_create.2:21 build/C/man2/tkill.2:30 build/C/man2/wait.2:51 build/C/man2/wait4.2:35
#, no-wrap
msgid "NAME"
msgstr ""

#. type: Plain text
#: build/C/man3/bsd_signal.3:26
msgid "bsd_signal - signal handling with BSD semantics"
msgstr ""

#. type: SH
#: build/C/man3/bsd_signal.3:26 build/C/man2/eventfd.2:24 build/C/man2/getitimer.2:10 build/C/man3/gsignal.3:28 build/C/man2/kill.2:47 build/C/man2/killpg.2:43 build/C/man2/pause.2:33 build/C/man2/prctl.2:49 build/C/man3/profil.3:31 build/C/man3/psignal.3:31 build/C/man3/raise.3:30 build/C/man2/rt_sigqueueinfo.2:26 build/C/man2/sgetmask.2:27 build/C/man2/sigaction.2:48 build/C/man2/sigaltstack.2:28 build/C/man7/sigevent.7:27 build/C/man3/siginterrupt.3:32 build/C/man2/signal.2:37 build/C/man2/signalfd.2:22 build/C/man3/sigpause.3:26 build/C/man2/sigpending.2:30 build/C/man2/sigprocmask.2:30 build/C/man3/sigqueue.3:29 build/C/man2/sigreturn.2:30 build/C/man3/sigset.3:27 build/C/man3/sigsetops.3:33 build/C/man2/sigsuspend.2:30 build/C/man3/sigvec.3:27 build/C/man3/sigwait.3:27 build/C/man2/sigwaitinfo.2:26 build/C/man3/sysv_signal.3:26 build/C/man2/timer_create.2:32 build/C/man2/timer_delete.2:26 build/C/man2/timer_getoverrun.2:26 build/C/man2/timer_settime.2:27 build/C/man2/timerfd_create.2:24 build/C/man2/tkill.2:32 build/C/man2/wait.2:53 build/C/man2/wait4.2:37
#, no-wrap
msgid "SYNOPSIS"
msgstr ""

#. type: Plain text
#: build/C/man3/bsd_signal.3:28
msgid "B<#define _XOPEN_SOURCE> /* See feature_test_macros(7) */"
msgstr ""

#. type: Plain text
#: build/C/man3/bsd_signal.3:30 build/C/man2/killpg.2:45 build/C/man2/sigaltstack.2:30 build/C/man2/signal.2:39 build/C/man2/sigpending.2:32 build/C/man2/sigprocmask.2:32 build/C/man3/sigqueue.3:31 build/C/man3/sigset.3:29 build/C/man3/sigsetops.3:35 build/C/man2/sigsuspend.2:32 build/C/man3/sigvec.3:29 build/C/man3/sysv_signal.3:30
msgid "B<#include E<lt>signal.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man3/bsd_signal.3:32 build/C/man2/signal.2:41 build/C/man3/sigset.3:31 build/C/man3/sysv_signal.3:32
msgid "B<typedef void (*sighandler_t)(int);>"
msgstr ""

#. type: Plain text
#: build/C/man3/bsd_signal.3:34
msgid "B<sighandler_t bsd_signal(int >I<signum>B<, sighandler_t >I<handler>B<);>"
msgstr ""

#. type: SH
#: build/C/man3/bsd_signal.3:34 build/C/man2/eventfd.2:28 build/C/man2/getitimer.2:19 build/C/man3/gsignal.3:47 build/C/man2/kill.2:65 build/C/man2/killpg.2:59 build/C/man2/pause.2:37 build/C/man2/prctl.2:56 build/C/man3/profil.3:44 build/C/man3/psignal.3:54 build/C/man3/raise.3:36 build/C/man2/rt_sigqueueinfo.2:33 build/C/man2/sgetmask.2:31 build/C/man2/sigaction.2:65 build/C/man2/sigaltstack.2:49 build/C/man7/sigevent.7:50 build/C/man3/siginterrupt.3:53 build/C/man2/signal.2:43 build/C/man7/signal.7:47 build/C/man2/signalfd.2:26 build/C/man3/sigpause.3:34 build/C/man2/sigpending.2:44 build/C/man2/sigprocmask.2:45 build/C/man3/sigqueue.3:41 build/C/man2/sigreturn.2:32 build/C/man3/sigset.3:56 build/C/man3/sigsetops.3:61 build/C/man2/sigsuspend.2:44 build/C/man3/sigvec.3:47 build/C/man3/sigwait.3:43 build/C/man2/sigwaitinfo.2:44 build/C/man3/sysv_signal.3:34 build/C/man2/timer_create.2:50 build/C/man2/timer_delete.2:42 build/C/man2/timer_getoverrun.2:42 build/C/man2/timer_settime.2:47 build/C/man2/timerfd_create.2:36 build/C/man2/tkill.2:38 build/C/man2/wait.2:82 build/C/man2/wait4.2:68
#, no-wrap
msgid "DESCRIPTION"
msgstr ""

#. type: Plain text
#: build/C/man3/bsd_signal.3:39
msgid ""
"The B<bsd_signal>()  function takes the same arguments, and performs the "
"same task, as B<signal>(2)."
msgstr ""

#. type: Plain text
#: build/C/man3/bsd_signal.3:52
msgid ""
"The difference between the two is that B<bsd_signal>()  is guaranteed to "
"provide reliable signal semantics, that is: a) the disposition of the signal "
"is not reset to the default when the handler is invoked; b) delivery of "
"further instances of the signal is blocked while the signal handler is "
"executing; and c) if the handler interrupts a blocking system call, then the "
"system call is automatically restarted.  A portable application cannot rely "
"on B<signal>(2)  to provide these guarantees."
msgstr ""

#. type: SH
#: build/C/man3/bsd_signal.3:52 build/C/man2/eventfd.2:222 build/C/man2/getitimer.2:117 build/C/man2/kill.2:99 build/C/man2/killpg.2:88 build/C/man2/pause.2:42 build/C/man2/prctl.2:381 build/C/man3/profil.3:66 build/C/man3/psignal.3:87 build/C/man3/raise.3:59 build/C/man2/rt_sigqueueinfo.2:124 build/C/man2/sgetmask.2:54 build/C/man2/sigaction.2:651 build/C/man2/sigaltstack.2:131 build/C/man3/siginterrupt.3:71 build/C/man2/signal.2:95 build/C/man2/signalfd.2:248 build/C/man3/sigpause.3:46 build/C/man2/sigpending.2:51 build/C/man2/sigprocmask.2:91 build/C/man3/sigqueue.3:81 build/C/man2/sigreturn.2:51 build/C/man3/sigset.3:127 build/C/man3/sigsetops.3:105 build/C/man2/sigsuspend.2:68 build/C/man3/sigvec.3:197 build/C/man3/sigwait.3:66 build/C/man2/sigwaitinfo.2:98 build/C/man3/sysv_signal.3:49 build/C/man2/timer_create.2:165 build/C/man2/timer_delete.2:50 build/C/man2/timer_getoverrun.2:79 build/C/man2/timer_settime.2:169 build/C/man2/timerfd_create.2:286 build/C/man2/tkill.2:69 build/C/man2/wait.2:354 build/C/man2/wait4.2:127
#, no-wrap
msgid "RETURN VALUE"
msgstr ""

#. type: Plain text
#: build/C/man3/bsd_signal.3:58
msgid ""
"The B<bsd_signal>()  function returns the previous value of the signal "
"handler, or B<SIG_ERR> on error."
msgstr ""

#. type: SH
#: build/C/man3/bsd_signal.3:58 build/C/man2/eventfd.2:229 build/C/man2/getitimer.2:122 build/C/man2/kill.2:104 build/C/man2/killpg.2:93 build/C/man2/pause.2:53 build/C/man2/prctl.2:398 build/C/man2/rt_sigqueueinfo.2:129 build/C/man2/sgetmask.2:59 build/C/man2/sigaction.2:654 build/C/man2/sigaltstack.2:135 build/C/man3/siginterrupt.3:76 build/C/man2/signal.2:100 build/C/man2/signalfd.2:262 build/C/man2/sigpending.2:54 build/C/man2/sigprocmask.2:94 build/C/man3/sigqueue.3:89 build/C/man3/sigset.3:152 build/C/man3/sigsetops.3:121 build/C/man2/sigsuspend.2:72 build/C/man3/sigvec.3:214 build/C/man3/sigwait.3:71 build/C/man2/sigwaitinfo.2:107 build/C/man3/sysv_signal.3:55 build/C/man2/timer_create.2:173 build/C/man2/timer_delete.2:57 build/C/man2/timer_getoverrun.2:87 build/C/man2/timer_settime.2:178 build/C/man2/timerfd_create.2:301 build/C/man2/tkill.2:73 build/C/man2/wait.2:383 build/C/man2/wait4.2:130
#, no-wrap
msgid "ERRORS"
msgstr ""

#. type: Plain text
#: build/C/man3/bsd_signal.3:61 build/C/man3/sysv_signal.3:58
msgid "As for B<signal>(2)."
msgstr ""

#. type: SH
#: build/C/man3/bsd_signal.3:61 build/C/man2/eventfd.2:266 build/C/man2/getitimer.2:143 build/C/man3/gsignal.3:93 build/C/man2/kill.2:120 build/C/man2/killpg.2:110 build/C/man2/pause.2:57 build/C/man2/prctl.2:475 build/C/man3/profil.3:68 build/C/man3/psignal.3:97 build/C/man3/raise.3:62 build/C/man2/rt_sigqueueinfo.2:171 build/C/man2/sgetmask.2:61 build/C/man2/sigaction.2:666 build/C/man2/sigaltstack.2:154 build/C/man7/sigevent.7:128 build/C/man3/siginterrupt.3:80 build/C/man2/signal.2:105 build/C/man7/signal.7:834 build/C/man2/signalfd.2:304 build/C/man3/sigpause.3:54 build/C/man2/sigpending.2:59 build/C/man2/sigprocmask.2:99 build/C/man3/sigqueue.3:112 build/C/man2/sigreturn.2:58 build/C/man3/sigset.3:171 build/C/man3/sigsetops.3:126 build/C/man2/sigsuspend.2:80 build/C/man3/sigvec.3:219 build/C/man3/sigwait.3:77 build/C/man2/sigwaitinfo.2:126 build/C/man3/sysv_signal.3:58 build/C/man2/timer_create.2:191 build/C/man2/timer_delete.2:64 build/C/man2/timer_getoverrun.2:94 build/C/man2/timer_settime.2:203 build/C/man2/timerfd_create.2:370 build/C/man2/tkill.2:90 build/C/man2/wait.2:421 build/C/man2/wait4.2:133
#, no-wrap
msgid "CONFORMING TO"
msgstr ""

#. type: Plain text
#: build/C/man3/bsd_signal.3:68
msgid ""
"4.2BSD, POSIX.1-2001.  POSIX.1-2008 removes the specification of "
"B<bsd_signal>(), recommending the use of B<sigaction>(2)  instead."
msgstr ""

#. type: SH
#: build/C/man3/bsd_signal.3:68 build/C/man2/eventfd.2:271 build/C/man2/getitimer.2:153 build/C/man2/kill.2:122 build/C/man2/killpg.2:114 build/C/man2/rt_sigqueueinfo.2:173 build/C/man2/sgetmask.2:63 build/C/man2/sigaction.2:669 build/C/man2/sigaltstack.2:156 build/C/man2/signal.2:107 build/C/man2/signalfd.2:309 build/C/man3/sigpause.3:58 build/C/man2/sigpending.2:61 build/C/man2/sigprocmask.2:101 build/C/man3/sigqueue.3:114 build/C/man2/sigreturn.2:62 build/C/man3/sigset.3:188 build/C/man3/sigsetops.3:128 build/C/man2/sigsuspend.2:82 build/C/man3/sigvec.3:225 build/C/man3/sigwait.3:79 build/C/man2/sigwaitinfo.2:128 build/C/man3/sysv_signal.3:60 build/C/man2/timer_create.2:193 build/C/man2/timer_getoverrun.2:96 build/C/man2/tkill.2:96 build/C/man2/wait.2:423 build/C/man2/wait4.2:135
#, no-wrap
msgid "NOTES"
msgstr ""

#. type: Plain text
#: build/C/man3/bsd_signal.3:74
msgid "Use of B<bsd_signal>()  should be avoided; use B<sigaction>(2)  instead."
msgstr ""

#. type: Plain text
#: build/C/man3/bsd_signal.3:85
msgid ""
"On modern Linux systems, B<bsd_signal>()  and B<signal>(2)  are equivalent.  "
"But on older systems, B<signal>(2)  provided unreliable signal semantics; "
"see B<signal>(2)  for details."
msgstr ""

#. type: Plain text
#: build/C/man3/bsd_signal.3:92 build/C/man3/sysv_signal.3:85
msgid ""
"The use of I<sighandler_t> is a GNU extension; this type is only defined if "
"the B<_GNU_SOURCE> feature test macro is defined."
msgstr ""

#. type: SH
#: build/C/man3/bsd_signal.3:92 build/C/man2/eventfd.2:417 build/C/man2/getitimer.2:219 build/C/man3/gsignal.3:101 build/C/man2/kill.2:170 build/C/man2/killpg.2:133 build/C/man2/pause.2:59 build/C/man2/prctl.2:489 build/C/man3/profil.3:79 build/C/man3/psignal.3:111 build/C/man3/raise.3:64 build/C/man2/rt_sigqueueinfo.2:183 build/C/man2/sgetmask.2:74 build/C/man2/sigaction.2:782 build/C/man2/sigaltstack.2:230 build/C/man7/sigevent.7:130 build/C/man3/siginterrupt.3:89 build/C/man2/signal.2:259 build/C/man7/signal.7:845 build/C/man2/signalfd.2:430 build/C/man3/sigpause.3:96 build/C/man2/sigpending.2:82 build/C/man2/sigprocmask.2:131 build/C/man3/sigqueue.3:147 build/C/man2/sigreturn.2:72 build/C/man3/sigset.3:264 build/C/man3/sigsetops.3:166 build/C/man2/sigsuspend.2:104 build/C/man3/sigvec.3:250 build/C/man3/sigwait.3:86 build/C/man2/sigwaitinfo.2:179 build/C/man3/sysv_signal.3:85 build/C/man2/timer_create.2:397 build/C/man2/timer_delete.2:66 build/C/man2/timer_getoverrun.2:128 build/C/man2/timer_settime.2:208 build/C/man2/timerfd_create.2:540 build/C/man2/tkill.2:105 build/C/man2/wait.2:605 build/C/man2/wait4.2:153
#, no-wrap
msgid "SEE ALSO"
msgstr ""

#. type: Plain text
#: build/C/man3/bsd_signal.3:97
msgid "B<sigaction>(2), B<signal>(2), B<sysv_signal>(3), B<signal>(7)"
msgstr ""

#. type: SH
#: build/C/man3/bsd_signal.3:97 build/C/man2/eventfd.2:428 build/C/man2/getitimer.2:226 build/C/man3/gsignal.3:105 build/C/man2/kill.2:180 build/C/man2/killpg.2:139 build/C/man2/pause.2:64 build/C/man2/prctl.2:492 build/C/man3/profil.3:84 build/C/man3/psignal.3:116 build/C/man3/raise.3:71 build/C/man2/rt_sigqueueinfo.2:191 build/C/man2/sgetmask.2:77 build/C/man2/sigaction.2:801 build/C/man2/sigaltstack.2:237 build/C/man7/sigevent.7:140 build/C/man3/siginterrupt.3:91 build/C/man2/signal.2:278 build/C/man7/signal.7:878 build/C/man2/signalfd.2:443 build/C/man3/sigpause.3:104 build/C/man2/sigpending.2:90 build/C/man2/sigprocmask.2:142 build/C/man3/sigqueue.3:155 build/C/man2/sigreturn.2:77 build/C/man3/sigset.3:274 build/C/man3/sigsetops.3:171 build/C/man2/sigsuspend.2:114 build/C/man3/sigvec.3:260 build/C/man3/sigwait.3:94 build/C/man2/sigwaitinfo.2:191 build/C/man3/sysv_signal.3:90 build/C/man2/timer_create.2:410 build/C/man2/timer_delete.2:72 build/C/man2/timer_getoverrun.2:138 build/C/man2/timer_settime.2:212 build/C/man2/timerfd_create.2:552 build/C/man2/tkill.2:110 build/C/man2/wait.2:617 build/C/man2/wait4.2:160
#, no-wrap
msgid "COLOPHON"
msgstr ""

#. type: Plain text
#: build/C/man3/bsd_signal.3:104 build/C/man2/eventfd.2:435 build/C/man2/getitimer.2:233 build/C/man3/gsignal.3:112 build/C/man2/kill.2:187 build/C/man2/killpg.2:146 build/C/man2/pause.2:71 build/C/man2/prctl.2:499 build/C/man3/profil.3:91 build/C/man3/psignal.3:123 build/C/man3/raise.3:78 build/C/man2/rt_sigqueueinfo.2:198 build/C/man2/sgetmask.2:84 build/C/man2/sigaction.2:808 build/C/man2/sigaltstack.2:244 build/C/man7/sigevent.7:147 build/C/man3/siginterrupt.3:98 build/C/man2/signal.2:285 build/C/man7/signal.7:885 build/C/man2/signalfd.2:450 build/C/man3/sigpause.3:111 build/C/man2/sigpending.2:97 build/C/man2/sigprocmask.2:149 build/C/man3/sigqueue.3:162 build/C/man2/sigreturn.2:84 build/C/man3/sigset.3:281 build/C/man3/sigsetops.3:178 build/C/man2/sigsuspend.2:121 build/C/man3/sigvec.3:267 build/C/man3/sigwait.3:101 build/C/man2/sigwaitinfo.2:198 build/C/man3/sysv_signal.3:97 build/C/man2/timer_create.2:417 build/C/man2/timer_delete.2:79 build/C/man2/timer_getoverrun.2:145 build/C/man2/timer_settime.2:219 build/C/man2/timerfd_create.2:559 build/C/man2/tkill.2:117 build/C/man2/wait.2:624 build/C/man2/wait4.2:167
msgid ""
"This page is part of release 3.38 of the Linux I<man-pages> project.  A "
"description of the project, and information about reporting bugs, can be "
"found at http://www.kernel.org/doc/man-pages/."
msgstr ""

#. type: TH
#: build/C/man2/eventfd.2:21
#, no-wrap
msgid "EVENTFD"
msgstr ""

#. type: TH
#: build/C/man2/eventfd.2:21
#, no-wrap
msgid "2010-08-30"
msgstr ""

#. type: TH
#: build/C/man2/eventfd.2:21 build/C/man2/getitimer.2:7 build/C/man2/kill.2:44 build/C/man2/killpg.2:40 build/C/man2/pause.2:30 build/C/man2/prctl.2:46 build/C/man3/profil.3:28 build/C/man2/rt_sigqueueinfo.2:23 build/C/man2/sgetmask.2:24 build/C/man2/sigaction.2:45 build/C/man2/sigaltstack.2:25 build/C/man2/signal.2:34 build/C/man7/signal.7:44 build/C/man2/signalfd.2:19 build/C/man3/sigpause.3:23 build/C/man2/sigpending.2:27 build/C/man2/sigprocmask.2:27 build/C/man3/sigqueue.3:26 build/C/man2/sigreturn.2:27 build/C/man3/sigset.3:24 build/C/man3/sigsetops.3:29 build/C/man2/sigsuspend.2:27 build/C/man3/sigvec.3:24 build/C/man3/sigwait.3:24 build/C/man2/sigwaitinfo.2:23 build/C/man2/timer_create.2:29 build/C/man2/timer_delete.2:23 build/C/man2/timer_getoverrun.2:23 build/C/man2/timer_settime.2:23 build/C/man2/timerfd_create.2:20 build/C/man2/tkill.2:29 build/C/man2/wait.2:50 build/C/man2/wait4.2:34
#, no-wrap
msgid "Linux"
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:24
msgid "eventfd - create a file descriptor for event notification"
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:26
msgid "B<#include E<lt>sys/eventfd.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:28
msgid "B<int eventfd(unsigned int >I<initval>B<, int >I<flags>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:38
msgid ""
"B<eventfd>()  creates an \"eventfd object\" that can be used as an event "
"wait/notify mechanism by userspace applications, and by the kernel to notify "
"userspace applications of events.  The object contains an unsigned 64-bit "
"integer (I<uint64_t>)  counter that is maintained by the kernel.  This "
"counter is initialized with the value specified in the argument I<initval>."
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:43
msgid ""
"The following values may be bitwise ORed in I<flags> to change the behaviour "
"of B<eventfd>():"
msgstr ""

#. type: TP
#: build/C/man2/eventfd.2:43
#, no-wrap
msgid "B<EFD_CLOEXEC> (since Linux 2.6.27)"
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:53 build/C/man2/signalfd.2:94 build/C/man2/timerfd_create.2:102
msgid ""
"Set the close-on-exec (B<FD_CLOEXEC>)  flag on the new file descriptor.  See "
"the description of the B<O_CLOEXEC> flag in B<open>(2)  for reasons why this "
"may be useful."
msgstr ""

#. type: TP
#: build/C/man2/eventfd.2:53
#, no-wrap
msgid "B<EFD_NONBLOCK> (since Linux 2.6.27)"
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:61 build/C/man2/signalfd.2:84 build/C/man2/timerfd_create.2:92
msgid ""
"Set the B<O_NONBLOCK> file status flag on the new open file description.  "
"Using this flag saves extra calls to B<fcntl>(2)  to achieve the same "
"result."
msgstr ""

#. type: TP
#: build/C/man2/eventfd.2:61
#, no-wrap
msgid "B<EFD_SEMAPHORE> (since Linux 2.6.30)"
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:65
msgid ""
"Provide semaphore-like semantics for reads from the new file descriptor.  "
"See below."
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:69 build/C/man2/signalfd.2:98
msgid ""
"In Linux up to version 2.6.26, the I<flags> argument is unused, and must be "
"specified as zero."
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:75
msgid ""
"As its return value, B<eventfd>()  returns a new file descriptor that can be "
"used to refer to the eventfd object.  The following operations can be "
"performed on the file descriptor:"
msgstr ""

#. type: TP
#: build/C/man2/eventfd.2:75 build/C/man2/signalfd.2:101 build/C/man2/timerfd_create.2:210
#, no-wrap
msgid "B<read>(2)"
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:85
msgid ""
"Each successful B<read>(2)  returns an 8-byte integer.  A B<read>(2)  will "
"fail with the error B<EINVAL> if the size of the supplied buffer is less "
"than 8 bytes."
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:90
msgid ""
"The value returned by B<read>(2)  is in host byte order, i.e., the native "
"byte order for integers on the host machine."
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:97
msgid ""
"The semantics of B<read>(2)  depend on whether the eventfd counter currently "
"has a nonzero value and whether the B<EFD_SEMAPHORE> flag was specified when "
"creating the eventfd file descriptor:"
msgstr ""

#. type: IP
#: build/C/man2/eventfd.2:98 build/C/man2/eventfd.2:105 build/C/man2/eventfd.2:112 build/C/man2/eventfd.2:157 build/C/man2/eventfd.2:167 build/C/man2/eventfd.2:177 build/C/man3/psignal.3:103 build/C/man3/psignal.3:107 build/C/man2/sigaction.2:294 build/C/man2/sigaction.2:309 build/C/man2/sigaction.2:325 build/C/man2/sigaction.2:340 build/C/man2/sigaction.2:387 build/C/man2/sigaction.2:423 build/C/man2/signal.2:66 build/C/man2/signal.2:71 build/C/man2/signal.2:78 build/C/man2/signal.2:205 build/C/man2/signal.2:209 build/C/man2/signal.2:248 build/C/man7/signal.7:147 build/C/man7/signal.7:155 build/C/man7/signal.7:611 build/C/man7/signal.7:613 build/C/man7/signal.7:634 build/C/man7/signal.7:649 build/C/man7/signal.7:653 build/C/man7/signal.7:660 build/C/man7/signal.7:676 build/C/man7/signal.7:682 build/C/man7/signal.7:689 build/C/man7/signal.7:694 build/C/man7/signal.7:713 build/C/man7/signal.7:732 build/C/man7/signal.7:739 build/C/man7/signal.7:748 build/C/man7/signal.7:756 build/C/man7/signal.7:762 build/C/man7/signal.7:767 build/C/man7/signal.7:787 build/C/man7/signal.7:806 build/C/man7/signal.7:809 build/C/man7/signal.7:812 build/C/man7/signal.7:815 build/C/man7/signal.7:820 build/C/man7/signal.7:826 build/C/man7/signal.7:830 build/C/man3/sigwait.3:59 build/C/man3/sigwait.3:64 build/C/man2/timer_create.2:214 build/C/man2/timer_create.2:217 build/C/man2/timer_create.2:220 build/C/man2/timer_create.2:224 build/C/man2/timer_create.2:227 build/C/man2/timer_create.2:233 build/C/man2/timer_create.2:237
#, no-wrap
msgid "*"
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:105
msgid ""
"If B<EFD_SEMAPHORE> was not specified and the eventfd counter has a nonzero "
"value, then a B<read>(2)  returns 8 bytes containing that value, and the "
"counter's value is reset to zero."
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:112
msgid ""
"If B<EFD_SEMAPHORE> was specified and the eventfd counter has a nonzero "
"value, then a B<read>(2)  returns 8 bytes containing the value 1, and the "
"counter's value is decremented by 1."
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:122
msgid ""
"If the eventfd counter is zero at the time of the call to B<read>(2), then "
"the call either blocks until the counter becomes nonzero (at which time, the "
"B<read>(2)  proceeds as described above)  or fails with the error B<EAGAIN> "
"if the file descriptor has been made nonblocking."
msgstr ""

#. type: TP
#: build/C/man2/eventfd.2:123
#, no-wrap
msgid "B<write>(2)"
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:140
msgid ""
"A B<write>(2)  call adds the 8-byte integer value supplied in its buffer to "
"the counter.  The maximum value that may be stored in the counter is the "
"largest unsigned 64-bit value minus 1 (i.e., 0xfffffffffffffffe).  If the "
"addition would cause the counter's value to exceed the maximum, then the "
"B<write>(2)  either blocks until a B<read>(2)  is performed on the file "
"descriptor, or fails with the error B<EAGAIN> if the file descriptor has "
"been made nonblocking."
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:147
msgid ""
"A B<write>(2)  will fail with the error B<EINVAL> if the size of the "
"supplied buffer is less than 8 bytes, or if an attempt is made to write the "
"value 0xffffffffffffffff."
msgstr ""

#. type: TP
#: build/C/man2/eventfd.2:147 build/C/man2/signalfd.2:139 build/C/man2/timerfd_create.2:243
#, no-wrap
msgid "B<poll>(2), B<select>(2) (and similar)"
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:156
msgid ""
"The returned file descriptor supports B<poll>(2)  (and analogously "
"B<epoll>(7))  and B<select>(2), as follows:"
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:167
msgid ""
"The file descriptor is readable (the B<select>(2)  I<readfds> argument; the "
"B<poll>(2)  B<POLLIN> flag)  if the counter has a value greater than 0."
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:177
msgid ""
"The file descriptor is writable (the B<select>(2)  I<writefds> argument; the "
"B<poll>(2)  B<POLLOUT> flag)  if it is possible to write a value of at least "
"\"1\" without blocking."
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:197
msgid ""
"If an overflow of the counter value was detected, then B<select>(2)  "
"indicates the file descriptor as being both readable and writable, and "
"B<poll>(2)  returns a B<POLLERR> event.  As noted above, B<write>(2)  can "
"never overflow the counter.  However an overflow can occur if 2^64 eventfd "
"\"signal posts\" were performed by the KAIO subsystem (theoretically "
"possible, but practically unlikely).  If an overflow has occurred, then "
"B<read>(2)  will return that maximum I<uint64_t> value (i.e., "
"0xffffffffffffffff)."
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:205
msgid ""
"The eventfd file descriptor also supports the other file-descriptor "
"multiplexing APIs: B<pselect>(2), B<ppoll>(2), and B<epoll>(7)."
msgstr ""

#. type: TP
#: build/C/man2/eventfd.2:205 build/C/man2/signalfd.2:159 build/C/man2/timerfd_create.2:261
#, no-wrap
msgid "B<close>(2)"
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:210
msgid ""
"When the file descriptor is no longer required it should be closed.  When "
"all file descriptors associated with the same eventfd object have been "
"closed, the resources for object are freed by the kernel."
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:222
msgid ""
"A copy of the file descriptor created by B<eventfd>()  is inherited by the "
"child produced by B<fork>(2).  The duplicate file descriptor is associated "
"with the same eventfd object.  File descriptors created by B<eventfd>()  are "
"preserved across B<execve>(2), unless the close-on-exec flag has been set."
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:229
msgid ""
"On success, B<eventfd>()  returns a new eventfd file descriptor.  On error, "
"-1 is returned and I<errno> is set to indicate the error."
msgstr ""

#. type: TP
#: build/C/man2/eventfd.2:230 build/C/man2/getitimer.2:130 build/C/man2/kill.2:105 build/C/man2/killpg.2:94 build/C/man2/prctl.2:403 build/C/man2/prctl.2:408 build/C/man2/prctl.2:418 build/C/man2/prctl.2:423 build/C/man2/rt_sigqueueinfo.2:136 build/C/man2/sigaction.2:659 build/C/man2/sigaltstack.2:140 build/C/man3/siginterrupt.3:77 build/C/man2/signal.2:101 build/C/man2/signalfd.2:268 build/C/man2/signalfd.2:276 build/C/man3/sigqueue.3:96 build/C/man3/sigsetops.3:122 build/C/man3/sigwait.3:72 build/C/man2/sigwaitinfo.2:122 build/C/man2/timer_create.2:177 build/C/man2/timer_delete.2:58 build/C/man2/timer_getoverrun.2:88 build/C/man2/timer_settime.2:187 build/C/man2/timer_settime.2:195 build/C/man2/timerfd_create.2:304 build/C/man2/timerfd_create.2:312 build/C/man2/timerfd_create.2:348 build/C/man2/timerfd_create.2:355 build/C/man2/timerfd_create.2:361 build/C/man2/tkill.2:74 build/C/man2/wait.2:416
#, no-wrap
msgid "B<EINVAL>"
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:234
msgid "An unsupported value was specified in I<flags>."
msgstr ""

#. type: TP
#: build/C/man2/eventfd.2:234 build/C/man2/signalfd.2:283 build/C/man2/timerfd_create.2:319
#, no-wrap
msgid "B<EMFILE>"
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:237
msgid "The per-process limit on open file descriptors has been reached."
msgstr ""

#. type: TP
#: build/C/man2/eventfd.2:237 build/C/man2/signalfd.2:286 build/C/man2/timerfd_create.2:322
#, no-wrap
msgid "B<ENFILE>"
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:241 build/C/man2/signalfd.2:290 build/C/man2/timerfd_create.2:326
msgid "The system-wide limit on the total number of open files has been reached."
msgstr ""

#. type: TP
#: build/C/man2/eventfd.2:241 build/C/man2/signalfd.2:290 build/C/man2/timerfd_create.2:326
#, no-wrap
msgid "B<ENODEV>"
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:249 build/C/man2/signalfd.2:293 build/C/man2/timerfd_create.2:329
msgid "Could not mount (internal) anonymous inode device."
msgstr ""

#. type: TP
#: build/C/man2/eventfd.2:249 build/C/man2/sigaltstack.2:145 build/C/man2/signalfd.2:293 build/C/man2/timer_create.2:185 build/C/man2/timerfd_create.2:329
#, no-wrap
msgid "B<ENOMEM>"
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:253
msgid "There was insufficient memory to create a new eventfd file descriptor."
msgstr ""

#. type: SH
#: build/C/man2/eventfd.2:253 build/C/man2/prctl.2:470 build/C/man3/psignal.3:93 build/C/man2/rt_sigqueueinfo.2:164 build/C/man2/signalfd.2:296 build/C/man3/sigqueue.3:110 build/C/man2/timer_create.2:189 build/C/man2/timer_delete.2:62 build/C/man2/timer_getoverrun.2:92 build/C/man2/timer_settime.2:201 build/C/man2/timerfd_create.2:367 build/C/man2/tkill.2:85
#, no-wrap
msgid "VERSIONS"
msgstr ""

#.  eventfd() is in glibc 2.7, but reportedly does not build
#. type: Plain text
#: build/C/man2/eventfd.2:266
msgid ""
"B<eventfd>()  is available on Linux since kernel 2.6.22.  Working support is "
"provided in glibc since version 2.8.  The B<eventfd2>()  system call (see "
"NOTES) is available on Linux since kernel 2.6.27.  Since version 2.9, the "
"glibc B<eventfd>()  wrapper will employ the B<eventfd2>()  system call, if "
"it is supported by the kernel."
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:271
msgid "B<eventfd>()  and B<eventfd2>()  are Linux-specific."
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:279
msgid ""
"Applications can use an eventfd file descriptor instead of a pipe (see "
"B<pipe>(2))  in all cases where a pipe is used simply to signal events.  The "
"kernel overhead of an eventfd file descriptor is much lower than that of a "
"pipe, and only one file descriptor is required (versus the two required for "
"a pipe)."
msgstr ""

#.  or eventually syslets/threadlets
#. type: Plain text
#: build/C/man2/eventfd.2:285
msgid ""
"When used in the kernel, an eventfd file descriptor can provide a "
"kernel-userspace bridge allowing, for example, functionalities like KAIO "
"(kernel AIO)  to signal to a file descriptor that some operation is "
"complete."
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:302
msgid ""
"A key point about an eventfd file descriptor is that it can be monitored "
"just like any other file descriptor using B<select>(2), B<poll>(2), or "
"B<epoll>(7).  This means that an application can simultaneously monitor the "
"readiness of \"traditional\" files and the readiness of other kernel "
"mechanisms that support the eventfd interface.  (Without the B<eventfd>()  "
"interface, these mechanisms could not be multiplexed via B<select>(2), "
"B<poll>(2), or B<epoll>(7).)"
msgstr ""

#. type: SS
#: build/C/man2/eventfd.2:302 build/C/man2/signalfd.2:333
#, no-wrap
msgid "Underlying Linux system calls"
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:316
msgid ""
"There are two underlying Linux system calls: B<eventfd>()  and the more "
"recent B<eventfd2>().  The former system call does not implement a I<flags> "
"argument.  The latter system call implements the I<flags> values described "
"above.  The glibc wrapper function will use B<eventfd2>()  where it is "
"available."
msgstr ""

#. type: SS
#: build/C/man2/eventfd.2:316
#, no-wrap
msgid "Additional glibc features"
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:320
msgid ""
"The GNU C library defines an additional type, and two functions that attempt "
"to abstract some of the details of reading and writing on an eventfd file "
"descriptor:"
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:324
#, no-wrap
msgid "typedef uint64_t eventfd_t;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:327
#, no-wrap
msgid ""
"int eventfd_read(int fd, eventfd_t *value);\n"
"int eventfd_write(int fd, eventfd_t value);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:334
msgid ""
"The functions perform the read and write operations on an eventfd file "
"descriptor, returning 0 if the correct number of bytes was transferred, or "
"-1 otherwise."
msgstr ""

#. type: SH
#: build/C/man2/eventfd.2:334 build/C/man2/sigaction.2:779 build/C/man2/sigaltstack.2:213 build/C/man2/signalfd.2:357 build/C/man3/sigwait.3:83 build/C/man2/timer_create.2:251 build/C/man2/timer_getoverrun.2:125 build/C/man2/timer_settime.2:205 build/C/man2/timerfd_create.2:372 build/C/man2/wait.2:522
#, no-wrap
msgid "EXAMPLE"
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:343
msgid ""
"The following program creates an eventfd file descriptor and then forks to "
"create a child process.  While the parent briefly sleeps, the child writes "
"each of the integers supplied in the program's command-line arguments to the "
"eventfd file descriptor.  When the parent has finished sleeping, it reads "
"from the eventfd file descriptor."
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:345
msgid "The following shell session shows a sample run of the program:"
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:357
#, no-wrap
msgid ""
"$B< ./a.out 1 2 4 7 14>\n"
"Child writing 1 to efd\n"
"Child writing 2 to efd\n"
"Child writing 4 to efd\n"
"Child writing 7 to efd\n"
"Child writing 14 to efd\n"
"Child completed write loop\n"
"Parent about to read\n"
"Parent read 28 (0x1c) from efd\n"
msgstr ""

#. type: SS
#: build/C/man2/eventfd.2:359 build/C/man2/signalfd.2:380 build/C/man2/timerfd_create.2:400 build/C/man2/wait.2:557
#, no-wrap
msgid "Program source"
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:367
#, no-wrap
msgid ""
"#include E<lt>sys/eventfd.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdint.hE<gt>             /* Definition of uint64_t */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:370 build/C/man2/signalfd.2:391
#, no-wrap
msgid ""
"#define handle_error(msg) \\e\n"
"    do { perror(msg); exit(EXIT_FAILURE); } while (0)\n"
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:377
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int efd, j;\n"
"    uint64_t u;\n"
"    ssize_t s;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:382
#, no-wrap
msgid ""
"    if (argc E<lt> 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>numE<gt>...\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:386
#, no-wrap
msgid ""
"    efd = eventfd(0, 0);\n"
"    if (efd == -1)\n"
"        handle_error(\"eventfd\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:398
#, no-wrap
msgid ""
"    switch (fork()) {\n"
"    case 0:\n"
"        for (j = 1; j E<lt> argc; j++) {\n"
"            printf(\"Child writing %s to efd\\en\", argv[j]);\n"
"            u = strtoull(argv[j], NULL, 0);\n"
"                    /* strtoull() allows various bases */\n"
"            s = write(efd, &u, sizeof(uint64_t));\n"
"            if (s != sizeof(uint64_t))\n"
"                handle_error(\"write\");\n"
"        }\n"
"        printf(\"Child completed write loop\\en\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:400
#, no-wrap
msgid "        exit(EXIT_SUCCESS);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:403
#, no-wrap
msgid ""
"    default:\n"
"        sleep(2);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:411
#, no-wrap
msgid ""
"        printf(\"Parent about to read\\en\");\n"
"        s = read(efd, &u, sizeof(uint64_t));\n"
"        if (s != sizeof(uint64_t))\n"
"            handle_error(\"read\");\n"
"        printf(\"Parent read %llu (0x%llx) from efd\\en\",\n"
"                (unsigned long long) u, (unsigned long long) u);\n"
"        exit(EXIT_SUCCESS);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:416
#, no-wrap
msgid ""
"    case -1:\n"
"        handle_error(\"fork\");\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:428
msgid ""
"B<futex>(2), B<pipe>(2), B<poll>(2), B<read>(2), B<select>(2), "
"B<signalfd>(2), B<timerfd_create>(2), B<write>(2), B<epoll>(7), "
"B<sem_overview>(7)"
msgstr ""

#. type: TH
#: build/C/man2/getitimer.2:7
#, no-wrap
msgid "GETITIMER"
msgstr ""

#. type: Plain text
#: build/C/man2/getitimer.2:10
msgid "getitimer, setitimer - get or set value of an interval timer"
msgstr ""

#. type: Plain text
#: build/C/man2/getitimer.2:13
#, no-wrap
msgid "B<#include E<lt>sys/time.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/getitimer.2:15
#, no-wrap
msgid "B<int getitimer(int >I<which>B<, struct itimerval *>I<curr_value>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/getitimer.2:18
#, no-wrap
msgid ""
"B<int setitimer(int >I<which>B<, const struct itimerval *>I<new_value>B<,>\n"
"B<              struct itimerval *>I<old_value>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/getitimer.2:24
msgid ""
"The system provides each process with three interval timers, each "
"decrementing in a distinct time domain.  When any timer expires, a signal is "
"sent to the process, and the timer (potentially) restarts."
msgstr ""

#. type: TP
#: build/C/man2/getitimer.2:24
#, no-wrap
msgid "B<ITIMER_REAL>"
msgstr ""

#. type: Plain text
#: build/C/man2/getitimer.2:29
msgid "decrements in real time, and delivers B<SIGALRM> upon expiration."
msgstr ""

#. type: TP
#: build/C/man2/getitimer.2:29
#, no-wrap
msgid "B<ITIMER_VIRTUAL>"
msgstr ""

#. type: Plain text
#: build/C/man2/getitimer.2:34
msgid ""
"decrements only when the process is executing, and delivers B<SIGVTALRM> "
"upon expiration."
msgstr ""

#. type: TP
#: build/C/man2/getitimer.2:34
#, no-wrap
msgid "B<ITIMER_PROF>"
msgstr ""

#. type: Plain text
#: build/C/man2/getitimer.2:44
msgid ""
"decrements both when the process executes and when the system is executing "
"on behalf of the process.  Coupled with B<ITIMER_VIRTUAL>, this timer is "
"usually used to profile the time spent by the application in user and kernel "
"space.  B<SIGPROF> is delivered upon expiration."
msgstr ""

#. type: Plain text
#: build/C/man2/getitimer.2:46
msgid "Timer values are defined by the following structures:"
msgstr ""

#. type: Plain text
#: build/C/man2/getitimer.2:54
#, no-wrap
msgid ""
"struct itimerval {\n"
"    struct timeval it_interval; /* next value */\n"
"    struct timeval it_value;    /* current value */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/getitimer.2:59
#, no-wrap
msgid ""
"struct timeval {\n"
"    long tv_sec;                /* seconds */\n"
"    long tv_usec;               /* microseconds */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/getitimer.2:81
msgid ""
"The function B<getitimer>()  fills the structure pointed to by I<curr_value> "
"with the current setting for the timer specified by I<which> (one of "
"B<ITIMER_REAL>, B<ITIMER_VIRTUAL>, or B<ITIMER_PROF>).  The element "
"I<it_value> is set to the amount of time remaining on the timer, or zero if "
"the timer is disabled.  Similarly, I<it_interval> is set to the reset value."
msgstr ""

#. type: Plain text
#: build/C/man2/getitimer.2:89
msgid ""
"The function B<setitimer>()  sets the specified timer to the value in "
"I<new_value>.  If I<old_value> is non-NULL, the old value of the timer is "
"stored there."
msgstr ""

#. type: Plain text
#: build/C/man2/getitimer.2:99
msgid ""
"Timers decrement from I<it_value> to zero, generate a signal, and reset to "
"I<it_interval>.  A timer which is set to zero (I<it_value> is zero or the "
"timer expires and I<it_interval> is zero) stops."
msgstr ""

#. type: Plain text
#: build/C/man2/getitimer.2:105
msgid ""
"Both I<tv_sec> and I<tv_usec> are significant in determining the duration of "
"a timer."
msgstr ""

#. type: Plain text
#: build/C/man2/getitimer.2:117
msgid ""
"Timers will never expire before the requested time, but may expire some "
"(short) time afterward, which depends on the system timer resolution and on "
"the system load; see B<time>(7).  (But see BUGS below.)  Upon expiration, a "
"signal will be generated and the timer reset.  If the timer expires while "
"the process is active (always true for B<ITIMER_VIRTUAL>)  the signal will "
"be delivered immediately when generated.  Otherwise the delivery will be "
"offset by a small time dependent on the system loading."
msgstr ""

#. type: Plain text
#: build/C/man2/getitimer.2:122 build/C/man2/killpg.2:93 build/C/man2/tkill.2:73
msgid ""
"On success, zero is returned.  On error, -1 is returned, and I<errno> is set "
"appropriately."
msgstr ""

#. type: TP
#: build/C/man2/getitimer.2:123 build/C/man2/prctl.2:399 build/C/man2/sigaction.2:655 build/C/man2/sigaltstack.2:136 build/C/man2/sigpending.2:55 build/C/man2/sigsuspend.2:73 build/C/man2/timer_settime.2:180 build/C/man2/timerfd_create.2:341
#, no-wrap
msgid "B<EFAULT>"
msgstr ""

#. type: Plain text
#: build/C/man2/getitimer.2:130 build/C/man2/timerfd_create.2:348
msgid "I<new_value>, I<old_value>, or I<curr_value> is not valid a pointer."
msgstr ""

#. type: Plain text
#: build/C/man2/getitimer.2:143
msgid ""
"I<which> is not one of B<ITIMER_REAL>, B<ITIMER_VIRTUAL>, or B<ITIMER_PROF>; "
"or (since Linux 2.6.22) one of the I<tv_usec> fields in the structure "
"pointed to by I<new_value> contains a value outside the range 0 to 999999."
msgstr ""

#. type: Plain text
#: build/C/man2/getitimer.2:153
msgid ""
"POSIX.1-2001, SVr4, 4.4BSD (this call first appeared in 4.2BSD).  "
"POSIX.1-2008 marks B<getitimer>()  and B<setitimer>()  obsolete, "
"recommending the use of the POSIX timers API (B<timer_gettime>(2), "
"B<timer_settime>(2), etc.) instead."
msgstr ""

#. type: Plain text
#: build/C/man2/getitimer.2:159
msgid ""
"A child created via B<fork>(2)  does not inherit its parent's interval "
"timers.  Interval timers are preserved across an B<execve>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/getitimer.2:169
msgid ""
"POSIX.1 leaves the interaction between B<setitimer>()  and the three "
"interfaces B<alarm>(2), B<sleep>(3), and B<usleep>(3)  unspecified."
msgstr ""

#. type: SH
#: build/C/man2/getitimer.2:169 build/C/man2/kill.2:160 build/C/man3/profil.3:70 build/C/man3/psignal.3:99 build/C/man2/sigaction.2:770 build/C/man7/signal.7:836 build/C/man2/signalfd.2:349 build/C/man2/sigpending.2:76 build/C/man3/sigset.3:230 build/C/man2/timer_getoverrun.2:112 build/C/man2/timerfd_create.2:534
#, no-wrap
msgid "BUGS"
msgstr ""

#. type: Plain text
#: build/C/man2/getitimer.2:178
msgid ""
"The generation and delivery of a signal are distinct, and only one instance "
"of each of the signals listed above may be pending for a process.  Under "
"very heavy loading, an B<ITIMER_REAL> timer may expire before the signal "
"from a previous expiration has been delivered.  The second signal in such an "
"event will be lost."
msgstr ""

#. type: Plain text
#: build/C/man2/getitimer.2:193
msgid ""
"On Linux kernels before 2.6.16, timer values are represented in jiffies.  If "
"a request is made set a timer with a value whose jiffies representation "
"exceeds B<MAX_SEC_IN_JIFFIES> (defined in I<include/linux/jiffies.h>), then "
"the timer is silently truncated to this ceiling value.  On Linux/i386 "
"(where, since Linux 2.6.13, the default jiffy is 0.004 seconds), this means "
"that the ceiling value for a timer is approximately 99.42 days.  Since Linux "
"2.6.16, the kernel uses a different internal representation for times, and "
"this ceiling is removed."
msgstr ""

#.  4 Jul 2005: It looks like this bug may remain in 2.4.x.
#. 	http://lkml.org/lkml/2005/7/1/165
#. type: Plain text
#: build/C/man2/getitimer.2:200
msgid ""
"On certain systems (including i386), Linux kernels before version 2.6.12 "
"have a bug which will produce premature timer expirations of up to one jiffy "
"under some circumstances.  This bug is fixed in kernel 2.6.12."
msgstr ""

#.  Bugzilla report 25 Apr 2006:
#.  http://bugzilla.kernel.org/show_bug.cgi?id=6443
#.  "setitimer() should reject noncanonical arguments"
#. type: Plain text
#: build/C/man2/getitimer.2:219
msgid ""
"POSIX.1-2001 says that B<setitimer>()  should fail if a I<tv_usec> value is "
"specified that is outside of the range 0 to 999999.  However, in kernels up "
"to and including 2.6.21, Linux does not give an error, but instead silently "
"adjusts the corresponding seconds value for the timer.  From kernel 2.6.22 "
"onward, this nonconformance has been repaired: an improper I<tv_usec> value "
"results in an B<EINVAL> error."
msgstr ""

#. type: Plain text
#: build/C/man2/getitimer.2:226
msgid ""
"B<gettimeofday>(2), B<sigaction>(2), B<signal>(2), B<timer_create>(2), "
"B<timerfd_create>(2), B<time>(7)"
msgstr ""

#. type: TH
#: build/C/man3/gsignal.3:25
#, no-wrap
msgid "GSIGNAL"
msgstr ""

#. type: TH
#: build/C/man3/gsignal.3:25 build/C/man3/profil.3:28 build/C/man3/sigvec.3:24
#, no-wrap
msgid "2007-07-26"
msgstr ""

#. type: Plain text
#: build/C/man3/gsignal.3:28
msgid "gsignal, ssignal - software signal facility"
msgstr ""

#. type: Plain text
#: build/C/man3/gsignal.3:31 build/C/man2/kill.2:52 build/C/man3/psignal.3:34 build/C/man3/raise.3:33 build/C/man2/sigaction.2:51 build/C/man3/siginterrupt.3:35 build/C/man3/sigpause.3:29 build/C/man3/sigwait.3:30 build/C/man2/sigwaitinfo.2:29
#, no-wrap
msgid "B<#include E<lt>signal.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/gsignal.3:33
#, no-wrap
msgid "B<typedef void (*sighandler_t)(int);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/gsignal.3:35
#, no-wrap
msgid "B<int gsignal(int>I<signum>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/gsignal.3:37
#, no-wrap
msgid "B<sighandler_t ssignal(int >I<signum>B<, sighandler_t >I<action>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/gsignal.3:42 build/C/man2/kill.2:59 build/C/man2/killpg.2:51 build/C/man3/profil.3:40 build/C/man3/psignal.3:44 build/C/man2/sigaction.2:59 build/C/man2/sigaltstack.2:36 build/C/man3/siginterrupt.3:42 build/C/man2/sigpending.2:38 build/C/man2/sigprocmask.2:39 build/C/man3/sigqueue.3:37 build/C/man3/sigset.3:43 build/C/man3/sigsetops.3:49 build/C/man2/sigsuspend.2:38 build/C/man3/sigvec.3:43 build/C/man3/sigwait.3:37 build/C/man2/sigwaitinfo.2:39 build/C/man2/timer_create.2:46 build/C/man2/timer_delete.2:38 build/C/man2/timer_getoverrun.2:38 build/C/man2/timer_settime.2:42 build/C/man2/wait.2:68 build/C/man2/wait4.2:54
msgid "Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr ""

#. type: Plain text
#: build/C/man3/gsignal.3:47
msgid "B<gsignal>(), B<ssignal>(): _SVID_SOURCE"
msgstr ""

#. type: Plain text
#: build/C/man3/gsignal.3:55
msgid ""
"Don't use these functions under Linux.  Due to a historical mistake, under "
"Linux these functions are aliases for B<raise>(3)  and B<signal>(2), "
"respectively."
msgstr ""

#. type: Plain text
#: build/C/man3/gsignal.3:93
msgid ""
"Elsewhere, on System V-like systems, these functions implement software "
"signaling, entirely independent of the classical B<signal>(2)  and "
"B<kill>(2)  functions.  The function B<ssignal>()  defines the action to "
"take when the software signal with number I<signum> is raised using the "
"function B<gsignal>(), and returns the previous such action or B<SIG_DFL>.  "
"The function B<gsignal>()  does the following: if no action (or the action "
"B<SIG_DFL>)  was specified for I<signum>, then it does nothing and returns "
"0.  If the action B<SIG_IGN> was specified for I<signum>, then it does "
"nothing and returns 1.  Otherwise, it resets the action to B<SIG_DFL> and "
"calls the action function with argument I<signum>, and returns the value "
"returned by that function.  The range of possible values I<signum> varies "
"(often 1-15 or 1-17)."
msgstr ""

#. type: Plain text
#: build/C/man3/gsignal.3:101
msgid ""
"These functions are available under AIX, DG/UX, HP-UX, SCO, Solaris, Tru64.  "
"They are called obsolete under most of these systems, and are broken under "
"Linux libc and glibc.  Some systems also have B<gsignal_r>()  and "
"B<ssignal_r>()."
msgstr ""

#. type: Plain text
#: build/C/man3/gsignal.3:105
msgid "B<kill>(2), B<signal>(2), B<raise>(3)"
msgstr ""

#. type: TH
#: build/C/man2/kill.2:44
#, no-wrap
msgid "KILL"
msgstr ""

#. type: TH
#: build/C/man2/kill.2:44
#, no-wrap
msgid "2009-09-15"
msgstr ""

#. type: Plain text
#: build/C/man2/kill.2:47
msgid "kill - send signal to a process"
msgstr ""

#. type: Plain text
#: build/C/man2/kill.2:50
#, no-wrap
msgid "B<#include E<lt>sys/types.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/kill.2:54
#, no-wrap
msgid "B<int kill(pid_t >I<pid>B<, int >I<sig>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/kill.2:64
msgid "B<kill>(): _POSIX_C_SOURCE\\ E<gt>=\\ 1 || _XOPEN_SOURCE || _POSIX_SOURCE"
msgstr ""

#. type: Plain text
#: build/C/man2/kill.2:70
msgid ""
"The B<kill>()  system call can be used to send any signal to any process "
"group or process."
msgstr ""

#. type: Plain text
#: build/C/man2/kill.2:73
msgid ""
"If I<pid> is positive, then signal I<sig> is sent to the process with the ID "
"specified by I<pid>."
msgstr ""

#. type: Plain text
#: build/C/man2/kill.2:76
msgid ""
"If I<pid> equals 0, then I<sig> is sent to every process in the process "
"group of the calling process."
msgstr ""

#. type: Plain text
#: build/C/man2/kill.2:80
msgid ""
"If I<pid> equals -1, then I<sig> is sent to every process for which the "
"calling process has permission to send signals, except for process 1 "
"(I<init>), but see below."
msgstr ""

#. type: Plain text
#: build/C/man2/kill.2:83
msgid ""
"If I<pid> is less than -1, then I<sig> is sent to every process in the "
"process group whose ID is I<-pid>."
msgstr ""

#. type: Plain text
#: build/C/man2/kill.2:88
msgid ""
"If I<sig> is 0, then no signal is sent, but error checking is still "
"performed; this can be used to check for the existence of a process ID or "
"process group ID."
msgstr ""

#. type: Plain text
#: build/C/man2/kill.2:99 build/C/man2/killpg.2:88
msgid ""
"For a process to have permission to send a signal it must either be "
"privileged (under Linux: have the B<CAP_KILL> capability), or the real or "
"effective user ID of the sending process must equal the real or saved "
"set-user-ID of the target process.  In the case of B<SIGCONT> it suffices "
"when the sending and receiving processes belong to the same session."
msgstr ""

#. type: Plain text
#: build/C/man2/kill.2:104
msgid ""
"On success (at least one signal was sent), zero is returned.  On error, -1 "
"is returned, and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/kill.2:108
msgid "An invalid signal was specified."
msgstr ""

#. type: TP
#: build/C/man2/kill.2:108 build/C/man2/killpg.2:98 build/C/man2/prctl.2:432 build/C/man2/prctl.2:444 build/C/man2/prctl.2:454 build/C/man2/rt_sigqueueinfo.2:143 build/C/man2/sigaltstack.2:149 build/C/man3/sigqueue.3:100 build/C/man2/tkill.2:77
#, no-wrap
msgid "B<EPERM>"
msgstr ""

#. type: Plain text
#: build/C/man2/kill.2:112 build/C/man2/killpg.2:102
msgid ""
"The process does not have permission to send the signal to any of the target "
"processes."
msgstr ""

#. type: TP
#: build/C/man2/kill.2:112 build/C/man2/killpg.2:102 build/C/man2/killpg.2:106 build/C/man2/rt_sigqueueinfo.2:151 build/C/man3/sigqueue.3:106 build/C/man2/tkill.2:82
#, no-wrap
msgid "B<ESRCH>"
msgstr ""

#. type: Plain text
#: build/C/man2/kill.2:120
msgid ""
"The pid or process group does not exist.  Note that an existing process "
"might be a zombie, a process which already committed termination, but has "
"not yet been B<wait>(2)ed for."
msgstr ""

#. type: Plain text
#: build/C/man2/kill.2:122 build/C/man2/pause.2:59 build/C/man2/wait.2:423
msgid "SVr4, 4.3BSD, POSIX.1-2001."
msgstr ""

#. type: Plain text
#: build/C/man2/kill.2:130
msgid ""
"The only signals that can be sent to process ID 1, the I<init> process, are "
"those for which I<init> has explicitly installed signal handlers.  This is "
"done to assure the system is not brought down accidentally."
msgstr ""

#. type: Plain text
#: build/C/man2/kill.2:136
msgid ""
"POSIX.1-2001 requires that I<kill(-1,sig)> send I<sig> to all processes that "
"the calling process may send signals to, except possibly for some "
"implementation-defined system processes.  Linux allows a process to signal "
"itself, but on Linux the call I<kill(-1,sig)> does not signal the calling "
"process."
msgstr ""

#. type: Plain text
#: build/C/man2/kill.2:146
msgid ""
"POSIX.1-2001 requires that if a process sends a signal to itself, and the "
"sending thread does not have the signal blocked, and no other thread has it "
"unblocked or is waiting for it in B<sigwait>(3), at least one unblocked "
"signal must be delivered to the sending thread before the B<kill>()  "
"returns."
msgstr ""

#. type: SS
#: build/C/man2/kill.2:146 build/C/man3/sigpause.3:75 build/C/man2/wait.2:477
#, no-wrap
msgid "Linux Notes"
msgstr ""

#.  In the 0.* kernels things chopped and changed quite
#.  a bit - MTK, 24 Jul 02
#. type: Plain text
#: build/C/man2/kill.2:160
msgid ""
"Across different kernel versions, Linux has enforced different rules for the "
"permissions required for an unprivileged process to send a signal to another "
"process.  In kernels 1.0 to 1.2.2, a signal could be sent if the effective "
"user ID of the sender matched that of the receiver, or the real user ID of "
"the sender matched that of the receiver.  From kernel 1.2.3 until 1.3.77, a "
"signal could be sent if the effective user ID of the sender matched either "
"the real or effective user ID of the receiver.  The current rules, which "
"conform to POSIX.1-2001, were adopted in kernel 1.3.78."
msgstr ""

#. type: Plain text
#: build/C/man2/kill.2:170
msgid ""
"In 2.6 kernels up to and including 2.6.7, there was a bug that meant that "
"when sending signals to a process group, B<kill>()  failed with the error "
"B<EPERM> if the caller did have permission to send the signal to I<any> "
"(rather than I<all>) of the members of the process group.  Notwithstanding "
"this error return, the signal was still delivered to all of the processes "
"for which the caller had permission to signal."
msgstr ""

#. type: Plain text
#: build/C/man2/kill.2:180
msgid ""
"B<_exit>(2), B<killpg>(2), B<signal>(2), B<tkill>(2), B<exit>(3), "
"B<sigqueue>(3), B<capabilities>(7), B<credentials>(7), B<signal>(7)"
msgstr ""

#. type: TH
#: build/C/man2/killpg.2:40
#, no-wrap
msgid "KILLPG"
msgstr ""

#. type: TH
#: build/C/man2/killpg.2:40 build/C/man3/sigset.3:24 build/C/man2/wait4.2:34
#, no-wrap
msgid "2010-09-20"
msgstr ""

#. type: Plain text
#: build/C/man2/killpg.2:43
msgid "killpg - send signal to a process group"
msgstr ""

#. type: Plain text
#: build/C/man2/killpg.2:47
msgid "B<int killpg(int >I<pgrp>B<, int >I<sig>B<);>"
msgstr ""

#. type: TP
#: build/C/man2/killpg.2:54
#, no-wrap
msgid "B<killpg>():"
msgstr ""

#. type: Plain text
#: build/C/man2/killpg.2:58 build/C/man2/sigaltstack.2:44 build/C/man3/siginterrupt.3:49 build/C/man2/wait4.2:61
msgid ""
"_BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 || _XOPEN_SOURCE\\ &&\\ "
"_XOPEN_SOURCE_EXTENDED"
msgstr ""

#. type: Plain text
#: build/C/man2/killpg.2:68
msgid ""
"B<killpg>()  sends the signal I<sig> to the process group I<pgrp>.  See "
"B<signal>(7)  for a list of signals."
msgstr ""

#. type: Plain text
#: build/C/man2/killpg.2:77
msgid ""
"If I<pgrp> is 0, B<killpg>()  sends the signal to the calling process's "
"process group.  (POSIX says: If I<pgrp> is less than or equal to 1, the "
"behavior is undefined.)"
msgstr ""

#. type: Plain text
#: build/C/man2/killpg.2:98
msgid "I<Sig> is not a valid signal number."
msgstr ""

#. type: Plain text
#: build/C/man2/killpg.2:106
msgid "No process can be found in the process group specified by I<pgrp>."
msgstr ""

#. type: Plain text
#: build/C/man2/killpg.2:110
msgid ""
"The process group was given as 0 but the sending process does not have a "
"process group."
msgstr ""

#. type: Plain text
#: build/C/man2/killpg.2:114
msgid ""
"SVr4, 4.4BSD (the B<killpg>()  function call first appeared in 4BSD), "
"POSIX.1-2001."
msgstr ""

#. type: Plain text
#: build/C/man2/killpg.2:128
msgid ""
"There are various differences between the permission checking in BSD-type "
"systems and System V-type systems.  See the POSIX rationale for B<kill>().  "
"A difference not mentioned by POSIX concerns the return value B<EPERM>: BSD "
"documents that no signal is sent and B<EPERM> returned when the permission "
"check failed for at least one target process, while POSIX documents B<EPERM> "
"only when the permission check failed for all target processes."
msgstr ""

#. type: Plain text
#: build/C/man2/killpg.2:133
msgid ""
"On Linux, B<killpg>()  is implemented as a library function that makes the "
"call I<kill(-pgrp,\\ sig)>."
msgstr ""

#. type: Plain text
#: build/C/man2/killpg.2:139
msgid ""
"B<getpgrp>(2), B<kill>(2), B<signal>(2), B<capabilities>(7), "
"B<credentials>(7)"
msgstr ""

#. type: TH
#: build/C/man2/pause.2:30
#, no-wrap
msgid "PAUSE"
msgstr ""

#. type: TH
#: build/C/man2/pause.2:30
#, no-wrap
msgid "2008-10-06"
msgstr ""

#. type: Plain text
#: build/C/man2/pause.2:33
msgid "pause - wait for signal"
msgstr ""

#. type: Plain text
#: build/C/man2/pause.2:35 build/C/man3/profil.3:33
msgid "B<#include E<lt>unistd.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man2/pause.2:37
msgid "B<int pause(void);>"
msgstr ""

#. type: Plain text
#: build/C/man2/pause.2:42
msgid ""
"B<pause>()  causes the calling process (or thread) to sleep until a signal "
"is delivered that either terminates the process or causes the invocation of "
"a signal-catching function."
msgstr ""

#.  .BR ERESTARTNOHAND .
#. type: Plain text
#: build/C/man2/pause.2:53
msgid ""
"B<pause>()  only returns when a signal was caught and the signal-catching "
"function returned.  In this case B<pause>()  returns -1, and I<errno> is set "
"to B<EINTR>."
msgstr ""

#. type: TP
#: build/C/man2/pause.2:54 build/C/man2/sigsuspend.2:77 build/C/man2/sigwaitinfo.2:116 build/C/man2/wait.2:409
#, no-wrap
msgid "B<EINTR>"
msgstr ""

#. type: Plain text
#: build/C/man2/pause.2:57
msgid "a signal was caught and the signal-catching function returned."
msgstr ""

#. type: Plain text
#: build/C/man2/pause.2:64
msgid "B<kill>(2), B<select>(2), B<signal>(2), B<sigsuspend>(2)"
msgstr ""

#. type: TH
#: build/C/man2/prctl.2:46
#, no-wrap
msgid "PRCTL"
msgstr ""

#. type: TH
#: build/C/man2/prctl.2:46
#, no-wrap
msgid "2011-09-17"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:49
msgid "prctl - operations on a process"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:52
#, no-wrap
msgid "B<#include E<lt>sys/prctl.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:55
#, no-wrap
msgid ""
"B<int prctl(int >I<option>B<, unsigned long >I<arg2>B<, unsigned long "
">I<arg3>B<,>\n"
"B<          unsigned long >I<arg4>B<, unsigned long >I<arg5>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:62
msgid ""
"B<prctl>()  is called with a first argument describing what to do (with "
"values defined in I<E<lt>linux/prctl.hE<gt>>), and further arguments with a "
"significance depending on the first one.  The first argument can be:"
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:62
#, no-wrap
msgid "B<PR_CAPBSET_READ> (since Linux 2.6.25)"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:74
msgid ""
"Return (as the function result) 1 if the capability specified in I<arg2> is "
"in the calling thread's capability bounding set, or 0 if it is not.  (The "
"capability constants are defined in I<E<lt>linux/capability.hE<gt>>.)  The "
"capability bounding set dictates whether the process can receive the "
"capability through a file's permitted capability set on a subsequent call to "
"B<execve>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:79
msgid ""
"If the capability specified in I<arg2> is not valid, then the call fails "
"with the error B<EINVAL>."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:79
#, no-wrap
msgid "B<PR_CAPBSET_DROP> (since Linux 2.6.25)"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:88
msgid ""
"If the calling thread has the B<CAP_SETPCAP> capability, then drop the "
"capability specified by I<arg2> from the calling thread's capability "
"bounding set.  Any children of the calling thread will inherit the newly "
"reduced bounding set."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:100
msgid ""
"The call fails with the error: B<EPERM> if the calling thread does not have "
"the B<CAP_SETPCAP>; B<EINVAL> if I<arg2> does not represent a valid "
"capability; or B<EINVAL> if file capabilities are not enabled in the kernel, "
"in which case bounding sets are not supported."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:100
#, no-wrap
msgid "B<PR_SET_DUMPABLE> (since Linux 2.3.20)"
msgstr ""

#.  See http://marc.theaimsgroup.com/?l=linux-kernel&m=115270289030630&w=2
#.  Subject:    Fix prctl privilege escalation (CVE-2006-2451)
#.  From:       Marcel Holtmann <marcel () holtmann ! org>
#.  Date:       2006-07-12 11:12:00
#. type: Plain text
#: build/C/man2/prctl.2:126
msgid ""
"Set the state of the flag determining whether core dumps are produced for "
"this process upon delivery of a signal whose default behavior is to produce "
"a core dump.  (Normally this flag is set for a process by default, but it is "
"cleared when a set-user-ID or set-group-ID program is executed and also by "
"various system calls that manipulate process UIDs and GIDs).  In kernels up "
"to and including 2.6.12, I<arg2> must be either 0 (process is not dumpable) "
"or 1 (process is dumpable).  Between kernels 2.6.13 and 2.6.17, the value 2 "
"was also permitted, which caused any binary which normally would not be "
"dumped to be dumped readable by root only; for security reasons, this "
"feature has been removed.  (See also the description of "
"I</proc/sys/fs/suid_dumpable> in B<proc>(5).)  Processes that are not "
"dumpable can not be attached via B<ptrace(2)> B<PTRACE_ATTACH>."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:126
#, no-wrap
msgid "B<PR_GET_DUMPABLE> (since Linux 2.3.20)"
msgstr ""

#.  Since Linux 2.6.13, the dumpable flag can have the value 2,
#.  but in 2.6.13 PR_GET_DUMPABLE simply returns 1 if the dumpable
#.  flags has a nonzero value.  This was fixed in 2.6.14.
#. type: Plain text
#: build/C/man2/prctl.2:133
msgid ""
"Return (as the function result) the current state of the calling process's "
"dumpable flag."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:133
#, no-wrap
msgid "B<PR_SET_ENDIAN> (since Linux 2.6.18, PowerPC only)"
msgstr ""

#.  Respectively 0, 1, 2
#. type: Plain text
#: build/C/man2/prctl.2:143
msgid ""
"Set the endian-ness of the calling process to the value given in I<arg2>, "
"which should be one of the following: B<PR_ENDIAN_BIG>, B<PR_ENDIAN_LITTLE>, "
"or B<PR_ENDIAN_PPC_LITTLE> (PowerPC pseudo little endian)."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:143
#, no-wrap
msgid "B<PR_GET_ENDIAN> (since Linux 2.6.18, PowerPC only)"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:148
msgid ""
"Return the endian-ness of the calling process, in the location pointed to by "
"I<(int\\ *) arg2>."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:148
#, no-wrap
msgid "B<PR_SET_FPEMU> (since Linux 2.4.18, 2.5.9, only on ia64)"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:155
msgid ""
"Set floating-point emulation control bits to I<arg2>.  Pass "
"B<PR_FPEMU_NOPRINT> to silently emulate fp operations accesses, or "
"B<PR_FPEMU_SIGFPE> to not emulate fp operations and send B<SIGFPE> instead."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:155
#, no-wrap
msgid "B<PR_GET_FPEMU> (since Linux 2.4.18, 2.5.9, only on ia64)"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:160
msgid ""
"Return floating-point emulation control bits, in the location pointed to by "
"I<(int\\ *) arg2>."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:160
#, no-wrap
msgid "B<PR_SET_FPEXC> (since Linux 2.4.21, 2.5.32, only on PowerPC)"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:173
msgid ""
"Set floating-point exception mode to I<arg2>.  Pass B<PR_FP_EXC_SW_ENABLE> "
"to use FPEXC for FP exception enables, B<PR_FP_EXC_DIV> for floating-point "
"divide by zero, B<PR_FP_EXC_OVF> for floating-point overflow, "
"B<PR_FP_EXC_UND> for floating-point underflow, B<PR_FP_EXC_RES> for "
"floating-point inexact result, B<PR_FP_EXC_INV> for floating-point invalid "
"operation, B<PR_FP_EXC_DISABLED> for FP exceptions disabled, "
"B<PR_FP_EXC_NONRECOV> for async nonrecoverable exception mode, "
"B<PR_FP_EXC_ASYNC> for async recoverable exception mode, "
"B<PR_FP_EXC_PRECISE> for precise exception mode."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:173
#, no-wrap
msgid "B<PR_GET_FPEXC> (since Linux 2.4.21, 2.5.32, only on PowerPC)"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:178
msgid ""
"Return floating-point exception mode, in the location pointed to by I<(int\\ "
"*) arg2>."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:178
#, no-wrap
msgid "B<PR_SET_KEEPCAPS> (since Linux 2.2.18)"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:196
msgid ""
"Set the state of the thread's \"keep capabilities\" flag, which determines "
"whether the threads's permitted capability set is cleared when a change is "
"made to the threads's user IDs such that the threads's real UID, effective "
"UID, and saved set-user-ID all become nonzero when at least one of them "
"previously had the value 0.  By default, the permitted capability set is "
"cleared when such a change is made; setting the \"keep capabilities\" flag "
"prevents it from being cleared.  I<arg2> must be either 0 (permitted "
"capabilities are cleared)  or 1 (permitted capabilities are kept).  (A "
"thread's I<effective> capability set is always cleared when such a "
"credential change is made, regardless of the setting of the \"keep "
"capabilities\" flag.)  The \"keep capabilities\" value will be reset to 0 on "
"subsequent calls to B<execve>(2)."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:196
#, no-wrap
msgid "B<PR_GET_KEEPCAPS> (since Linux 2.2.18)"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:200
msgid ""
"Return (as the function result) the current state of the calling threads's "
"\"keep capabilities\" flag."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:200
#, no-wrap
msgid "B<PR_SET_NAME> (since Linux 2.6.9)"
msgstr ""

#.  TASK_COMM_LEN in include/linux/sched.h
#. type: Plain text
#: build/C/man2/prctl.2:208
msgid ""
"Set the process name for the calling process, using the value in the "
"location pointed to by I<(char\\ *) arg2>.  The name can be up to 16 bytes "
"long, and should be null-terminated if it contains fewer bytes."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:208
#, no-wrap
msgid "B<PR_GET_NAME> (since Linux 2.6.11)"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:215
msgid ""
"Return the process name for the calling process, in the buffer pointed to by "
"I<(char\\ *) arg2>.  The buffer should allow space for up to 16 bytes; the "
"returned string will be null-terminated if it is shorter than that."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:215
#, no-wrap
msgid "B<PR_SET_PDEATHSIG> (since Linux 2.1.57)"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:224
msgid ""
"Set the parent process death signal of the calling process to I<arg2> "
"(either a signal value in the range 1..maxsig, or 0 to clear).  This is the "
"signal that the calling process will get when its parent dies.  This value "
"is cleared for the child of a B<fork>(2)."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:224
#, no-wrap
msgid "B<PR_GET_PDEATHSIG> (since Linux 2.3.15)"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:229
msgid ""
"Return the current value of the parent process death signal, in the location "
"pointed to by I<(int\\ *) arg2>."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:229
#, no-wrap
msgid "B<PR_SET_SECCOMP> (since Linux 2.6.23)"
msgstr ""

#.  See http://thread.gmane.org/gmane.linux.kernel/542632
#.  [PATCH 0 of 2] seccomp updates
#.  andrea@cpushare.com
#. type: Plain text
#: build/C/man2/prctl.2:253
msgid ""
"Set the secure computing mode for the calling thread.  In the current "
"implementation, I<arg2> must be 1.  After the secure computing mode has been "
"set to 1, the only system calls that the thread is permitted to make are "
"B<read>(2), B<write>(2), B<_exit>(2), and B<sigreturn>(2).  Other system "
"calls result in the delivery of a B<SIGKILL> signal.  Secure computing mode "
"is useful for number-crunching applications that may need to execute "
"untrusted byte code, perhaps obtained by reading from a pipe or socket.  "
"This operation is only available if the kernel is configured with "
"CONFIG_SECCOMP enabled."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:253
#, no-wrap
msgid "B<PR_GET_SECCOMP> (since Linux 2.6.23)"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:266
msgid ""
"Return the secure computing mode of the calling thread.  Not very useful for "
"the current implementation (mode equals 1), but may be useful for other "
"possible future modes: if the caller is not in secure computing mode, this "
"operation returns 0; if the caller is in secure computing mode, then the "
"B<prctl>()  call will cause a B<SIGKILL> signal to be sent to the process.  "
"This operation is only available if the kernel is configured with "
"CONFIG_SECCOMP enabled."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:266
#, no-wrap
msgid "B<PR_SET_SECUREBITS> (since Linux 2.6.26)"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:272
msgid ""
"Set the \"securebits\" flags of the calling thread to the value supplied in "
"I<arg2>.  See B<capabilities>(7)."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:272
#, no-wrap
msgid "B<PR_GET_SECUREBITS> (since Linux 2.6.26)"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:278
msgid ""
"Return (as the function result)  the \"securebits\" flags of the calling "
"thread.  See B<capabilities>(7)."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:278
#, no-wrap
msgid "B<PR_SET_TIMING> (since Linux 2.6.0-test4)"
msgstr ""

#.  0
#.  1
#.  PR_TIMING_TIMESTAMP doesn't do anything in 2.6.26-rc8,
#.  and looking at the patch history, it appears
#.  that it never did anything.
#. type: Plain text
#: build/C/man2/prctl.2:295
msgid ""
"Set whether to use (normal, traditional) statistical process timing or "
"accurate timestamp-based process timing, by passing B<PR_TIMING_STATISTICAL> "
"or B<PR_TIMING_TIMESTAMP> to I<arg2>.  B<PR_TIMING_TIMESTAMP> is not "
"currently implemented (attempting to set this mode will yield the error "
"B<EINVAL>)."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:295
#, no-wrap
msgid "B<PR_GET_TIMING> (since Linux 2.6.0-test4)"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:299
msgid ""
"Return (as the function result) which process timing method is currently in "
"use."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:299
#, no-wrap
msgid "B<PR_SET_TSC> (since Linux 2.6.26, x86 only)"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:312
msgid ""
"Set the state of the flag determining whether the timestamp counter can be "
"read by the process.  Pass B<PR_TSC_ENABLE> to I<arg2> to allow it to be "
"read, or B<PR_TSC_SIGSEGV> to generate a B<SIGSEGV> when the process tries "
"to read the timestamp counter."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:312
#, no-wrap
msgid "B<PR_GET_TSC> (since Linux 2.6.26, x86 only)"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:318
msgid ""
"Return the state of the flag determining whether the timestamp counter can "
"be read, in the location pointed to by I<(int\\ *) arg2>."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:318
#, no-wrap
msgid "B<PR_SET_UNALIGN>"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:328
msgid ""
"(Only on: ia64, since Linux 2.3.48; parisc, since Linux 2.6.15; PowerPC, "
"since Linux 2.6.18; Alpha, since Linux 2.6.22)  Set unaligned access control "
"bits to I<arg2>.  Pass B<PR_UNALIGN_NOPRINT> to silently fix up unaligned "
"user accesses, or B<PR_UNALIGN_SIGBUS> to generate B<SIGBUS> on unaligned "
"user access."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:328
#, no-wrap
msgid "B<PR_GET_UNALIGN>"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:335
msgid ""
"(see B<PR_SET_UNALIGN> for information on versions and architectures)  "
"Return unaligned access control bits, in the location pointed to by I<(int\\ "
"*) arg2>."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:335
#, no-wrap
msgid "B<PR_MCE_KILL> (since Linux 2.6.32)"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:375
msgid ""
"Set the machine check memory corruption kill policy for the current thread.  "
"If I<arg2> is B<PR_MCE_KILL_CLEAR>, clear the thread memory corruption kill "
"policy and use the system-wide default.  (The system-wide default is defined "
"by I</proc/sys/vm/memory_failure_early_kill>; see B<proc>(5).)  If I<arg2> "
"is B<PR_MCE_KILL_SET>, use a thread-specific memory corruption kill policy.  "
"In this case, I<arg3> defines whether the policy is I<early kill> "
"(B<PR_MCE_KILL_EARLY>), I<late kill> (B<PR_MCE_KILL_LATE>), or the "
"system-wide default (B<PR_MCE_KILL_DEFAULT>).  Early kill means that the "
"thread receives a B<SIGBUS> signal as soon as hardware memory corruption is "
"detected inside its address space.  In late kill mode, the process is only "
"killed when it accesses a corrupted page.  See B<sigaction>(2)  for more "
"information on the B<SIGBUS> signal.  The policy is inherited by children.  "
"The remaining unused B<prctl>()  arguments must be zero for future "
"compatibility."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:375
#, no-wrap
msgid "B<PR_MCE_KILL_GET> (since Linux 2.6.32)"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:381
msgid ""
"Return the current per-process machine check kill policy.  All unused "
"B<prctl>()  arguments must be zero."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:398
msgid ""
"On success, B<PR_GET_DUMPABLE>, B<PR_GET_KEEPCAPS>, B<PR_CAPBSET_READ>, "
"B<PR_GET_TIMING>, B<PR_GET_SECUREBITS>, B<PR_MCE_KILL_GET>, and (if it "
"returns)  B<PR_GET_SECCOMP> return the nonnegative values described above.  "
"All other I<option> values return 0 on success.  On error, -1 is returned, "
"and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:403
msgid "I<arg2> is an invalid address."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:408
msgid "The value of I<option> is not recognized."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:418
msgid ""
"I<option> is B<PR_MCE_KILL> or B<PR_MCE_KILL_GET>, and unused B<prctl>()  "
"arguments were not specified as zero."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:423
msgid "I<arg2> is not valid value for this I<option>."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:432
msgid ""
"I<option> is B<PR_SET_SECCOMP> or B<PR_SET_SECCOMP>, and the kernel was not "
"configured with B<CONFIG_SECCOMP>."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:444
msgid ""
"I<option> is B<PR_SET_SECUREBITS>, and the caller does not have the "
"B<CAP_SETPCAP> capability, or tried to unset a \"locked\" flag, or tried to "
"set a flag whose corresponding locked flag was set (see B<capabilities>(7))."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:454
msgid ""
"I<option> is B<PR_SET_KEEPCAPS>, and the callers's "
"B<SECURE_KEEP_CAPS_LOCKED> flag is set (see B<capabilities>(7))."
msgstr ""

#.  The following can't actually happen, because prctl() in
#.  seccomp mode will cause SIGKILL.
#.  .TP
#.  .B EPERM
#.  .I option
#.  is
#.  .BR PR_SET_SECCOMP ,
#.  and secure computing mode is already 1.
#. type: Plain text
#: build/C/man2/prctl.2:470
msgid ""
"I<option> is B<PR_CAPBSET_DROP>, and the caller does not have the "
"B<CAP_SETPCAP> capability."
msgstr ""

#.  The library interface was added in glibc 2.0.6
#. type: Plain text
#: build/C/man2/prctl.2:475
msgid "The B<prctl>()  system call was introduced in Linux 2.1.57."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:482
msgid ""
"This call is Linux-specific.  IRIX has a B<prctl>()  system call (also "
"introduced in Linux 2.1.44 as irix_prctl on the MIPS architecture), with "
"prototype"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:484
msgid "B<ptrdiff_t prctl(int >I<option>B<, int >I<arg2>B<, int >I<arg3>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:489
msgid ""
"and options to get the maximum number of processes per user, get the maximum "
"number of processors the calling process can use, find out whether a "
"specified process is currently blocked, get or set the maximum stack size, "
"etc."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:492
msgid "B<signal>(2), B<core>(5)"
msgstr ""

#. type: TH
#: build/C/man3/profil.3:28
#, no-wrap
msgid "PROFIL"
msgstr ""

#. type: Plain text
#: build/C/man3/profil.3:31
msgid "profil - execution time profile"
msgstr ""

#. type: Plain text
#: build/C/man3/profil.3:36
msgid ""
"B<int profil(unsigned short *>I<buf>B<, size_t >I<bufsiz>B<, size_t "
">I<offset>B<, unsigned int >I<scale>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/profil.3:44
msgid "B<profil>(): _BSD_SOURCE || (_XOPEN_SOURCE && _XOPEN_SOURCE\\ E<lt>\\ 500)"
msgstr ""

#. type: Plain text
#: build/C/man3/profil.3:66
msgid ""
"This routine provides a means to find out in what areas your program spends "
"most of its time.  The argument I<buf> points to I<bufsiz> bytes of core.  "
"Every virtual 10 milliseconds, the user's program counter (PC)  is examined: "
"I<offset> is subtracted and the result is multiplied by I<scale> and divided "
"by 65536.  If the resulting value is less than I<bufsiz>, then the "
"corresponding entry in I<buf> is incremented.  If I<buf> is NULL, profiling "
"is disabled."
msgstr ""

#. type: Plain text
#: build/C/man3/profil.3:68
msgid "Zero is always returned."
msgstr ""

#. type: Plain text
#: build/C/man3/profil.3:70
msgid "Similar to a call in SVr4 (but not POSIX.1-2001)."
msgstr ""

#. type: Plain text
#: build/C/man3/profil.3:76
msgid ""
"B<profil>()  cannot be used on a program that also uses B<ITIMER_PROF> "
"interval timers (see B<setitimer>(2))."
msgstr ""

#. type: Plain text
#: build/C/man3/profil.3:79
msgid ""
"True kernel profiling provides more accurate results.  Libc 4.4 contained a "
"kernel patch providing a system call profil."
msgstr ""

#. type: Plain text
#: build/C/man3/profil.3:84
msgid "B<gprof>(1), B<setitimer>(2), B<sigaction>(2), B<signal>(2)"
msgstr ""

#. type: TH
#: build/C/man3/psignal.3:28
#, no-wrap
msgid "PSIGNAL"
msgstr ""

#. type: TH
#: build/C/man3/psignal.3:28
#, no-wrap
msgid "2010-10-06"
msgstr ""

#. type: TH
#: build/C/man3/psignal.3:28 build/C/man3/raise.3:27 build/C/man7/sigevent.7:24
#, no-wrap
msgid "GNU"
msgstr ""

#. type: Plain text
#: build/C/man3/psignal.3:31
msgid "psignal, psiginfo - print signal message"
msgstr ""

#. type: Plain text
#: build/C/man3/psignal.3:37
#, no-wrap
msgid ""
"B<void psignal(int >I<sig>B<, const char *>I<s>B<);>\n"
"B<void psiginfo(const siginfo_t *>I<pinfo>B<, const char *>I<s>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/psignal.3:39
#, no-wrap
msgid "B<extern const char *const >I<sys_siglist>B<[];>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/psignal.3:48
msgid "B<psignal>(): _SVID_SOURCE || _BSD_SOURCE"
msgstr ""

#. type: Plain text
#: build/C/man3/psignal.3:51
msgid ""
"B<psiginfo>(): _XOPEN_SOURCE\\ E<gt>=\\ 700 || _POSIX_C_SOURCE\\ E<gt>=\\ "
"200809L"
msgstr ""

#. type: Plain text
#: build/C/man3/psignal.3:54
msgid "I<sys_siglist>: _BSD_SOURCE"
msgstr ""

#. type: Plain text
#: build/C/man3/psignal.3:63
msgid ""
"The B<psignal>()  function displays a message on I<stderr> consisting of the "
"string I<s>, a colon, a space, a string describing the signal number I<sig>, "
"and a trailing newline.  If the string I<s> is NULL or empty, the colon and "
"space are omitted.  If I<sig> is invalid, the message displayed will "
"indicate an unknown signal."
msgstr ""

#. type: Plain text
#: build/C/man3/psignal.3:84
msgid ""
"The B<psiginfo>()  function is like B<psignal>(), except that it displays "
"information about the signal described by I<pinfo>, which should point to a "
"valid I<siginfo_t> structure.  As well as the signal description, "
"B<psiginfo>()  displays information about the origin of the signal, and "
"other information relevant to the signal (e.g., the relevant memory address "
"for hardware-generated signals, the child process ID for B<SIGCHLD>, and the "
"user ID and process ID of the sender, for signals set using B<kill>(2)  or "
"B<sigqueue>(3))."
msgstr ""

#. type: Plain text
#: build/C/man3/psignal.3:87
msgid ""
"The array I<sys_siglist> holds the signal description strings indexed by "
"signal number."
msgstr ""

#. type: Plain text
#: build/C/man3/psignal.3:93
msgid "The B<psignal>()  and B<psiginfo>()  functions return no value."
msgstr ""

#. type: Plain text
#: build/C/man3/psignal.3:97
msgid "The B<psiginfo>()  function was added to glibc in version 2.10."
msgstr ""

#. type: Plain text
#: build/C/man3/psignal.3:99
msgid "POSIX.1-2008, 4.3BSD."
msgstr ""

#. type: Plain text
#: build/C/man3/psignal.3:103
msgid "In glibc versions up to 2.12, B<psiginfo>()  had the following bugs:"
msgstr ""

#.  FIXME http://sourceware.org/bugzilla/show_bug.cgi?id=12107
#.  Reportedly now fixed; check glibc 2.13
#. type: Plain text
#: build/C/man3/psignal.3:107
msgid "In some circumstances, a trailing newline is not printed."
msgstr ""

#.  FIXME http://sourceware.org/bugzilla/show_bug.cgi?id=12108
#.  Reportedly now fixed; check glibc 2.13
#. type: Plain text
#: build/C/man3/psignal.3:111
msgid "Additional details are not displayed for real-time signals."
msgstr ""

#. type: Plain text
#: build/C/man3/psignal.3:116
msgid "B<sigaction>(2), B<perror>(3), B<strsignal>(3), B<signal>(7)"
msgstr ""

#. type: TH
#: build/C/man3/raise.3:27
#, no-wrap
msgid "RAISE"
msgstr ""

#. type: TH
#: build/C/man3/raise.3:27 build/C/man2/sigprocmask.2:27
#, no-wrap
msgid "2008-10-17"
msgstr ""

#. type: Plain text
#: build/C/man3/raise.3:30
msgid "raise - send a signal to the caller"
msgstr ""

#. type: Plain text
#: build/C/man3/raise.3:35
#, no-wrap
msgid "B<int raise(int >I<sig>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/raise.3:41
msgid ""
"The B<raise>()  function sends a signal to the calling process or thread.  "
"In a single-threaded program it is equivalent to"
msgstr ""

#. type: Plain text
#: build/C/man3/raise.3:45
#, no-wrap
msgid "kill(getpid(), sig);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/raise.3:49
msgid "In a multithreaded program it is equivalent to"
msgstr ""

#. type: Plain text
#: build/C/man3/raise.3:53
#, no-wrap
msgid "pthread_kill(pthread_self(), sig);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/raise.3:59
msgid ""
"If the signal causes a handler to be called, B<raise>()  will only return "
"after the signal handler has returned."
msgstr ""

#. type: Plain text
#: build/C/man3/raise.3:62
msgid "B<raise>()  returns 0 on success, and nonzero for failure."
msgstr ""

#. type: Plain text
#: build/C/man3/raise.3:64 build/C/man2/signal.2:107
msgid "C89, C99, POSIX.1-2001."
msgstr ""

#. type: Plain text
#: build/C/man3/raise.3:71
msgid ""
"B<getpid>(2), B<kill>(2), B<sigaction>(2), B<signal>(2), B<pthread_kill>(3), "
"B<signal>(7)"
msgstr ""

#. type: TH
#: build/C/man2/rt_sigqueueinfo.2:23
#, no-wrap
msgid "RT_SIGQUEUEINFO"
msgstr ""

#. type: TH
#: build/C/man2/rt_sigqueueinfo.2:23 build/C/man7/signal.7:44 build/C/man2/tkill.2:29
#, no-wrap
msgid "2011-09-18"
msgstr ""

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:26
msgid "rt_sigqueueinfo, rt_tgsigqueueinfo - queue a signal and data"
msgstr ""

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:29
#, no-wrap
msgid ""
"B<int rt_sigqueueinfo(pid_t >I<tgid>B<, int >I<sig>B<, siginfo_t "
"*>I<uinfo>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:32
#, no-wrap
msgid ""
"B<int rt_tgsigqueueinfo(pid_t >I<tgid>B<, pid_t >I<tid>B<, int >I<sig>B<,>\n"
"B<                      siginfo_t *>I<uinfo>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:45
msgid ""
"The B<rt_sigqueueinfo>()  and B<rt_tgsigqueueinfo>()  system calls are the "
"low-level interfaces used to send a signal plus data to a process or "
"thread.  The receiver of the signal can obtain the accompanying data by "
"establishing a signal handler with the B<sigaction>(2)  B<SA_SIGINFO> flag."
msgstr ""

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:51
msgid ""
"These system calls are not intended for direct application use; they are "
"provided to allow the implementation of B<sigqueue>(3)  and "
"B<pthread_sigqueue>(3)."
msgstr ""

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:63
msgid ""
"The B<rt_sigqueueinfo>()  system call sends the signal I<sig> to the thread "
"group with the ID I<tgid>.  (The term \"thread group\" is synonymous with "
"\"process\", and I<tid> corresponds to the traditional UNIX process ID.)  "
"The signal will be delivered to an arbitrary member of the thread group "
"(i.e., one of the threads that is not currently blocking the signal)."
msgstr ""

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:74
msgid ""
"The I<uinfo> argument specifies the data to accompany the signal.  This "
"argument is a pointer to a structure of type I<siginfo_t>, described in "
"B<sigaction>(2)  (and defined by including I<E<lt>sigaction.hE<gt>>).  The "
"caller should set the following fields in this structure:"
msgstr ""

#. type: TP
#: build/C/man2/rt_sigqueueinfo.2:74 build/C/man7/sigevent.7:86 build/C/man2/wait.2:315
#, no-wrap
msgid "I<si_code>"
msgstr ""

#.  tkill(2) or
#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:90
msgid ""
"This must be one of the B<SI_*> codes in the kernel source file "
"I<include/asm-generic/siginfo.h>, with the restriction that the code must be "
"negative (i.e., cannot be B<SI_USER>, which is used by the kernel to "
"indicate a signal sent by B<kill>(2))  and cannot (since Linux 2.6.39) be "
"B<SI_TKILL> (which is used by the kernel to indicate a signal sent using "
"B<tgkill>(2))."
msgstr ""

#. type: TP
#: build/C/man2/rt_sigqueueinfo.2:90 build/C/man2/wait.2:294
#, no-wrap
msgid "I<si_pid>"
msgstr ""

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:94
msgid "This should be set to a process ID, typically the process ID of the sender."
msgstr ""

#. type: TP
#: build/C/man2/rt_sigqueueinfo.2:94 build/C/man2/wait.2:297
#, no-wrap
msgid "I<si_uid>"
msgstr ""

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:98
msgid "This should be set to a user ID, typically the real user ID of the sender."
msgstr ""

#. type: TP
#: build/C/man2/rt_sigqueueinfo.2:98 build/C/man7/sigevent.7:94
#, no-wrap
msgid "I<si_value>"
msgstr ""

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:105
msgid ""
"This field contains the user data to accompany the signal.  For more "
"information, see the description of the last (I<union sigval>)  argument of "
"B<sigqueue>(3)."
msgstr ""

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:112
msgid ""
"Internally, the kernel sets the I<si_signo> field to the value specified in "
"I<sig>, so that the receiver of the signal can also obtain the signal number "
"via that field."
msgstr ""

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:124
msgid ""
"The B<rt_tgsigqueueinfo>()  system call is like B<rt_sigqueueinfo>(), but "
"sends the signal and data to the single thread specified by the combination "
"of I<tgid>, a thread group ID, and I<tid>, a thread in that thread group."
msgstr ""

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:129
msgid ""
"On success, these system calls return 0.  On error, they return -1 and "
"I<errno> is set to indicate the error."
msgstr ""

#. type: TP
#: build/C/man2/rt_sigqueueinfo.2:130 build/C/man3/sigqueue.3:90 build/C/man2/sigwaitinfo.2:108 build/C/man2/timer_create.2:174
#, no-wrap
msgid "B<EAGAIN>"
msgstr ""

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:136 build/C/man3/sigqueue.3:96
msgid ""
"The limit of signals which may be queued has been reached.  (See "
"B<signal>(7)  for further information.)"
msgstr ""

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:143
msgid "I<sig>, I<tgid>, or I<tid> was invalid."
msgstr ""

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:151
msgid ""
"The caller does not have permission to send the signal to the target.  For "
"the required permissions, see B<kill>(2).  Or: I<uinfo-E<gt>si_code> is "
"invalid."
msgstr ""

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:157
msgid "B<rt_sigqueueinfo>(): No thread group matching I<tgid> was found."
msgstr ""

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:164
msgid "B<rt_tgsigqueinfo>(): No thread matching I<tgid> and I<tid> was found."
msgstr ""

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:171
msgid ""
"The B<rt_sigqueueinfo>()  system call was added to Linux in version 2.2.  "
"The B<rt_tgsigqueueinfo>()  system call was added to Linux in version "
"2.6.31."
msgstr ""

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:173 build/C/man2/sgetmask.2:63 build/C/man2/timerfd_create.2:372
msgid "These system calls are Linux-specific."
msgstr ""

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:178
msgid ""
"Since these system calls are not intended for application use, there are no "
"glibc wrapper functions; use B<syscall>(2)  in the unlikely case that you "
"want to call them directly."
msgstr ""

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:183
msgid ""
"As with B<kill>(2), the null signal (0) can be used to check if the "
"specified process or thread exists."
msgstr ""

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:191
msgid ""
"B<kill>(2), B<sigaction>(2), B<sigprocmask>(2), B<tgkill>(2), "
"B<pthread_sigqueue>(3), B<sigqueue>(3), B<signal>(7)"
msgstr ""

#. type: TH
#: build/C/man2/sgetmask.2:24
#, no-wrap
msgid "SGETMASK"
msgstr ""

#. type: TH
#: build/C/man2/sgetmask.2:24
#, no-wrap
msgid "2007-07-05"
msgstr ""

#. type: Plain text
#: build/C/man2/sgetmask.2:27
msgid "sgetmask, ssetmask - manipulation of signal mask (obsolete)"
msgstr ""

#. type: Plain text
#: build/C/man2/sgetmask.2:29
msgid "B<long sgetmask(void);>"
msgstr ""

#. type: Plain text
#: build/C/man2/sgetmask.2:31
msgid "B<long ssetmask(long >I<newmask>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/sgetmask.2:37
msgid ""
"These system calls are obsolete.  I<Do not use them>; use B<sigprocmask>(2)  "
"instead."
msgstr ""

#. type: Plain text
#: build/C/man2/sgetmask.2:40
msgid "B<sgetmask>()  returns the signal mask of the calling process."
msgstr ""

#. type: Plain text
#: build/C/man2/sgetmask.2:45
msgid ""
"B<ssetmask>()  sets the signal mask of the calling process to the value "
"given in I<newmask>.  The previous signal mask is returned."
msgstr ""

#. type: Plain text
#: build/C/man2/sgetmask.2:54
msgid ""
"The signal masks dealt with by these two system calls are plain bit masks "
"(unlike the I<sigset_t> used by B<sigprocmask>(2)); use B<sigmask>(3)  to "
"create and inspect these masks."
msgstr ""

#. type: Plain text
#: build/C/man2/sgetmask.2:59
msgid ""
"B<sgetmask>()  always successfully returns the signal mask.  B<ssetmask>()  "
"always succeeds, and returns the previous signal mask."
msgstr ""

#. type: Plain text
#: build/C/man2/sgetmask.2:61
msgid "These system calls always succeed."
msgstr ""

#. type: Plain text
#: build/C/man2/sgetmask.2:66
msgid "Glibc does not provide wrappers for these system calls; use B<syscall>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/sgetmask.2:69
msgid ""
"These system calls are unaware of signal numbers greater than 31 (i.e., "
"real-time signals)."
msgstr ""

#. type: Plain text
#: build/C/man2/sgetmask.2:74
msgid "It is not possible to block B<SIGSTOP> or B<SIGKILL>."
msgstr ""

#. type: Plain text
#: build/C/man2/sgetmask.2:77
msgid "B<sigprocmask>(2), B<signal>(7)"
msgstr ""

#. type: TH
#: build/C/man2/sigaction.2:45
#, no-wrap
msgid "SIGACTION"
msgstr ""

#. type: TH
#: build/C/man2/sigaction.2:45
#, no-wrap
msgid "2011-09-08"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:48
msgid "sigaction - examine and change a signal action"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:54
#, no-wrap
msgid ""
"B<int sigaction(int >I<signum>B<, const struct sigaction *>I<act>B<,>\n"
"B<              struct sigaction *>I<oldact>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:64
msgid ""
"B<sigaction>(): _POSIX_C_SOURCE\\ E<gt>=\\ 1 || _XOPEN_SOURCE || "
"_POSIX_SOURCE"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:73
msgid ""
"The B<sigaction>()  system call is used to change the action taken by a "
"process on receipt of a specific signal.  (See B<signal>(7)  for an overview "
"of signals.)"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:79
msgid ""
"I<signum> specifies the signal and can be any valid signal except B<SIGKILL> "
"and B<SIGSTOP>."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:90
msgid ""
"If I<act> is non-NULL, the new action for signal I<signum> is installed from "
"I<act>.  If I<oldact> is non-NULL, the previous action is saved in "
"I<oldact>."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:94
msgid "The I<sigaction> structure is defined as something like:"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:104
#, no-wrap
msgid ""
"struct sigaction {\n"
"    void     (*sa_handler)(int);\n"
"    void     (*sa_sigaction)(int, siginfo_t *, void *);\n"
"    sigset_t   sa_mask;\n"
"    int        sa_flags;\n"
"    void     (*sa_restorer)(void);\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:111
msgid ""
"On some architectures a union is involved: do not assign to both "
"I<sa_handler> and I<sa_sigaction>."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:118
msgid ""
"The I<sa_restorer> element is obsolete and should not be used.  POSIX does "
"not specify a I<sa_restorer> element."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:128
msgid ""
"I<sa_handler> specifies the action to be associated with I<signum> and may "
"be B<SIG_DFL> for the default action, B<SIG_IGN> to ignore this signal, or a "
"pointer to a signal handling function.  This function receives the signal "
"number as its only argument."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:150
msgid ""
"If B<SA_SIGINFO> is specified in I<sa_flags>, then I<sa_sigaction> (instead "
"of I<sa_handler>)  specifies the signal-handling function for I<signum>.  "
"This function receives the signal number as its first argument, a pointer to "
"a I<siginfo_t> as its second argument and a pointer to a I<ucontext_t> (cast "
"to I<void\\ *>) as its third argument.  (Commonly, the handler function "
"doesn't make any use of the third argument.  See B<getcontext>(2)  for "
"further information about I<ucontext_t>.)"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:160
msgid ""
"I<sa_mask> specifies a mask of signals which should be blocked (i.e., added "
"to the signal mask of the thread in which the signal handler is invoked)  "
"during execution of the signal handler.  In addition, the signal which "
"triggered the handler will be blocked, unless the B<SA_NODEFER> flag is "
"used."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:164
msgid ""
"I<sa_flags> specifies a set of flags which modify the behavior of the "
"signal.  It is formed by the bitwise OR of zero or more of the following:"
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:165
#, no-wrap
msgid "B<SA_NOCLDSTOP>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:182
msgid ""
"If I<signum> is B<SIGCHLD>, do not receive notification when child processes "
"stop (i.e., when they receive one of B<SIGSTOP>, B<SIGTSTP>, B<SIGTTIN> or "
"B<SIGTTOU>)  or resume (i.e., they receive B<SIGCONT>)  (see B<wait>(2)).  "
"This flag is only meaningful when establishing a handler for B<SIGCHLD>."
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:182
#, no-wrap
msgid "B<SA_NOCLDWAIT> (since Linux 2.6)"
msgstr ""

#.  To be precise: Linux 2.5.60 -- MTK
#. type: Plain text
#: build/C/man2/sigaction.2:196
msgid ""
"If I<signum> is B<SIGCHLD>, do not transform children into zombies when they "
"terminate.  See also B<waitpid>(2).  This flag is only meaningful when "
"establishing a handler for B<SIGCHLD>, or when setting that signal's "
"disposition to B<SIG_DFL>."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:208
msgid ""
"If the B<SA_NOCLDWAIT> flag is set when establishing a handler for "
"B<SIGCHLD>, POSIX.1 leaves it unspecified whether a B<SIGCHLD> signal is "
"generated when a child process terminates.  On Linux, a B<SIGCHLD> signal is "
"generated in this case; on some other implementations, it is not."
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:208
#, no-wrap
msgid "B<SA_NODEFER>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:215
msgid ""
"Do not prevent the signal from being received from within its own signal "
"handler.  This flag is only meaningful when establishing a signal handler.  "
"B<SA_NOMASK> is an obsolete, nonstandard synonym for this flag."
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:215
#, no-wrap
msgid "B<SA_ONSTACK>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:221
msgid ""
"Call the signal handler on an alternate signal stack provided by "
"B<sigaltstack>(2).  If an alternate stack is not available, the default "
"stack will be used.  This flag is only meaningful when establishing a signal "
"handler."
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:221
#, no-wrap
msgid "B<SA_RESETHAND>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:228
msgid ""
"Restore the signal action to the default state once the signal handler has "
"been called.  This flag is only meaningful when establishing a signal "
"handler.  B<SA_ONESHOT> is an obsolete, nonstandard synonym for this flag."
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:228
#, no-wrap
msgid "B<SA_RESTART>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:236
msgid ""
"Provide behavior compatible with BSD signal semantics by making certain "
"system calls restartable across signals.  This flag is only meaningful when "
"establishing a signal handler.  See B<signal>(7)  for a discussion of system "
"call restarting."
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:236
#, no-wrap
msgid "B<SA_SIGINFO> (since Linux 2.2)"
msgstr ""

#.  (The
#.  .I sa_sigaction
#.  field was added in Linux 2.1.86.)
#. type: Plain text
#: build/C/man2/sigaction.2:247
msgid ""
"The signal handler takes 3 arguments, not one.  In this case, "
"I<sa_sigaction> should be set instead of I<sa_handler>.  This flag is only "
"meaningful when establishing a signal handler."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:254
msgid ""
"The I<siginfo_t> argument to I<sa_sigaction> is a struct with the following "
"elements:"
msgstr ""

#.  FIXME
#.  si_trapno seems to be only used on SPARC and Alpha;
#.  this page could use a little more detail on its purpose there.
#.  In the kernel: si_tid
#. type: Plain text
#: build/C/man2/sigaction.2:285
#, no-wrap
msgid ""
"siginfo_t {\n"
"    int      si_signo;    /* Signal number */\n"
"    int      si_errno;    /* An errno value */\n"
"    int      si_code;     /* Signal code */\n"
"    int      si_trapno;   /* Trap number that caused\n"
"                             hardware-generated signal\n"
"                             (unused on most architectures) */\n"
"    pid_t    si_pid;      /* Sending process ID */\n"
"    uid_t    si_uid;      /* Real user ID of sending process */\n"
"    int      si_status;   /* Exit value or signal */\n"
"    clock_t  si_utime;    /* User time consumed */\n"
"    clock_t  si_stime;    /* System time consumed */\n"
"    sigval_t si_value;    /* Signal value */\n"
"    int      si_int;      /* POSIX.1b signal */\n"
"    void    *si_ptr;      /* POSIX.1b signal */\n"
"    int      si_overrun;  /* Timer overrun count; POSIX.1b timers */\n"
"    int      si_timerid;  /* Timer ID; POSIX.1b timers */\n"
"    void    *si_addr;     /* Memory location which caused fault */\n"
"    long     si_band;     /* Band event (was I<int> in\n"
"                             glibc 2.3.2 and earlier) */\n"
"    int      si_fd;       /* File descriptor */\n"
"    short    si_addr_lsb; /* Least significant bit of address\n"
"                             (since kernel 2.6.32) */\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:294
msgid ""
"I<si_signo>, I<si_errno> and I<si_code> are defined for all signals.  "
"(I<si_errno> is generally unused on Linux.)  The rest of the struct may be a "
"union, so that one should only read the fields that are meaningful for the "
"given signal:"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:309
msgid ""
"Signals sent with B<kill>(2)  and B<sigqueue>(3)  fill in I<si_pid> and "
"I<si_uid>.  In addition, signals sent with B<sigqueue>(3)  fill in I<si_int> "
"and I<si_ptr> with the values specified by the sender of the signal; see "
"B<sigqueue>(3)  for more details."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:325
msgid ""
"Signals sent by POSIX.1b timers (since Linux 2.6) fill in I<si_overrun> and "
"I<si_timerid>.  The I<si_timerid> field is an internal ID used by the kernel "
"to identify the timer; it is not the same as the timer ID returned by "
"B<timer_create>(2).  The I<si_overrun> field is the timer overrun count; "
"this is the same information as is obtained by a call to "
"B<timer_getoverrun>(2).  These fields are nonstandard Linux extensions."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:340
msgid ""
"Signals sent for message queue notification (see the description of "
"B<SIGEV_SIGNAL> in B<mq_notify>(3))  fill in I<si_int>/I<si_ptr>, with the "
"I<sigev_value> supplied to B<mq_notify>(3); I<si_pid>, with the process ID "
"of the message sender; and I<si_uid>, with the real user ID of the message "
"sender."
msgstr ""

#.  FIXME .
#.  When si_utime and si_stime where originally implemented, the
#.  measurement unit was HZ, which was the same as clock ticks
#.  (sysconf(_SC_CLK_TCK)).  In 2.6, HZ became configurable, and
#.  was *still* used as the unit to return the info these fields,
#.  with the result that the field values depended on the the
#.  configured HZ.  Of course, the should have been measured in
#.  USER_HZ instead, so that sysconf(_SC_CLK_TCK) could be used to
#.  convert to seconds.  I have a queued patch to fix this:
#.  http://thread.gmane.org/gmane.linux.kernel/698061/ .
#.  This patch made it into 2.6.27.
#.  But note that these fields still don't return the times of
#.  waited-for children (as is done by getrusage() and times()
#.  and wait4()).  Solaris 8 does include child times.
#. type: Plain text
#: build/C/man2/sigaction.2:387
msgid ""
"B<SIGCHLD> fills in I<si_pid>, I<si_uid>, I<si_status>, I<si_utime> and "
"I<si_stime>, providing information about the child.  The I<si_pid> field is "
"the process ID of the child; I<si_uid> is the child's real user ID.  The "
"I<si_status> field contains the exit status of the child (if I<si_code> is "
"B<CLD_EXITED>), or the signal number that caused the process to change "
"state.  The I<si_utime> and I<si_stime> contain the user and system CPU time "
"used by the child process; these fields do not include the times used by "
"waited-for children (unlike B<getrusage>(2)  and B<time>(2)).  In kernels up "
"to 2.6, and since 2.6.27, these fields report CPU time in units of "
"I<sysconf(_SC_CLK_TCK)>.  In 2.6 kernels before 2.6.27, a bug meant that "
"these fields reported time in units of the (configurable) system jiffy (see "
"B<time>(7))."
msgstr ""

#.  FIXME SIGTRAP also sets the following for ptrace_notify() ?
#.      info.si_code = exit_code;
#.      info.si_pid = task_pid_vnr(current);
#.      info.si_uid = current_uid();  /* Real UID */
#. type: Plain text
#: build/C/man2/sigaction.2:423
msgid ""
"B<SIGILL>, B<SIGFPE>, B<SIGSEGV>, B<SIGBUS>, and B<SIGTRAP> fill in "
"I<si_addr> with the address of the fault.  On some architectures, these "
"signals also fill in the I<si_trapno> filed.  Some suberrors of B<SIGBUS>, "
"in particular B<BUS_MCEERR_AO> and B<BUS_MCEERR_AR>, also fill in "
"I<si_addr_lsb>.  This field indicates the least significant bit of the "
"reported address and therefore the extent of the corruption.  For example, "
"if a full page was corrupted, I<si_addr_lsb> contains "
"I<log2(sysconf(_SC_PAGESIZE))>.  B<BUS_MCERR_*> and I<si_addr_lsb> are "
"Linux-specific extensions."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:436
msgid ""
"B<SIGPOLL>/B<SIGIO> fills in I<si_band> and I<si_fd>.  The I<si_band> event "
"is a bit mask containing the same values as are filled in the I<revents> "
"field by B<poll>(2).  The I<si_fd> field indicates the file descriptor for "
"which the I/O event occurred."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:443
msgid ""
"I<si_code> is a value (not a bit mask)  indicating why this signal was "
"sent.  The following list shows the values which can be placed in I<si_code> "
"for any signal, along with reason that the signal was generated."
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:444
#, no-wrap
msgid "B<SI_USER>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:449
msgid "B<kill>(2)  or B<raise>(3)"
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:449
#, no-wrap
msgid "B<SI_KERNEL>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:452
msgid "Sent by the kernel."
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:452
#, no-wrap
msgid "B<SI_QUEUE>"
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:455 build/C/man7/signal.7:126
#, no-wrap
msgid "B<sigqueue>(3)"
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:455
#, no-wrap
msgid "B<SI_TIMER>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:458
msgid "POSIX timer expired"
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:458
#, no-wrap
msgid "B<SI_MESGQ>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:462
msgid "POSIX message queue state changed (since Linux 2.6.6); see B<mq_notify>(3)"
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:462
#, no-wrap
msgid "B<SI_ASYNCIO>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:465
msgid "AIO completed"
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:465
#, no-wrap
msgid "B<SI_SIGIO>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:468
msgid "queued SIGIO"
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:468
#, no-wrap
msgid "B<SI_TKILL>"
msgstr ""

#.  SI_DETHREAD is defined in 2.6.9 sources, but isn't implemented
#.  It appears to have been an idea that was tried during 2.5.6
#.  through to 2.5.24 and then was backed out.
#. type: Plain text
#: build/C/man2/sigaction.2:477
msgid "B<tkill>(2)  or B<tgkill>(2)  (since Linux 2.4.19)"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:484
msgid "The following values can be placed in I<si_code> for a B<SIGILL> signal:"
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:485
#, no-wrap
msgid "B<ILL_ILLOPC>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:488
msgid "illegal opcode"
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:488
#, no-wrap
msgid "B<ILL_ILLOPN>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:491
msgid "illegal operand"
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:491
#, no-wrap
msgid "B<ILL_ILLADR>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:494
msgid "illegal addressing mode"
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:494
#, no-wrap
msgid "B<ILL_ILLTRP>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:497
msgid "illegal trap"
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:497
#, no-wrap
msgid "B<ILL_PRVOPC>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:500
msgid "privileged opcode"
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:500
#, no-wrap
msgid "B<ILL_PRVREG>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:503
msgid "privileged register"
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:503
#, no-wrap
msgid "B<ILL_COPROC>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:506
msgid "coprocessor error"
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:506
#, no-wrap
msgid "B<ILL_BADSTK>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:509
msgid "internal stack error"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:516
msgid "The following values can be placed in I<si_code> for a B<SIGFPE> signal:"
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:517
#, no-wrap
msgid "B<FPE_INTDIV>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:520
msgid "integer divide by zero"
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:520
#, no-wrap
msgid "B<FPE_INTOVF>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:523
msgid "integer overflow"
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:523
#, no-wrap
msgid "B<FPE_FLTDIV>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:526
msgid "floating-point divide by zero"
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:526
#, no-wrap
msgid "B<FPE_FLTOVF>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:529
msgid "floating-point overflow"
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:529
#, no-wrap
msgid "B<FPE_FLTUND>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:532
msgid "floating-point underflow"
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:532
#, no-wrap
msgid "B<FPE_FLTRES>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:535
msgid "floating-point inexact result"
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:535
#, no-wrap
msgid "B<FPE_FLTINV>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:538
msgid "floating-point invalid operation"
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:538
#, no-wrap
msgid "B<FPE_FLTSUB>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:541
msgid "subscript out of range"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:548
msgid "The following values can be placed in I<si_code> for a B<SIGSEGV> signal:"
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:549
#, no-wrap
msgid "B<SEGV_MAPERR>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:552
msgid "address not mapped to object"
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:552
#, no-wrap
msgid "B<SEGV_ACCERR>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:555
msgid "invalid permissions for mapped object"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:562
msgid "The following values can be placed in I<si_code> for a B<SIGBUS> signal:"
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:563
#, no-wrap
msgid "B<BUS_ADRALN>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:566
msgid "invalid address alignment"
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:566
#, no-wrap
msgid "B<BUS_ADRERR>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:569
msgid "nonexistent physical address"
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:569
#, no-wrap
msgid "B<BUS_OBJERR>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:572
msgid "object-specific hardware error"
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:572
#, no-wrap
msgid "B<BUS_MCEERR_AR> (since Linux 2.6.32)"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:575
msgid "Hardware memory error consumed on a machine check; action required."
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:575
#, no-wrap
msgid "B<BUS_MCEERR_AO> (since Linux 2.6.32)"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:578
msgid "Hardware memory error detected in process but not consumed; action optional."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:585
msgid "The following values can be placed in I<si_code> for a B<SIGTRAP> signal:"
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:586
#, no-wrap
msgid "B<TRAP_BRKPT>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:589
msgid "process breakpoint"
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:589
#, no-wrap
msgid "B<TRAP_TRACE>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:592
msgid "process trace trap"
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:592
#, no-wrap
msgid "B<TRAP_BRANCH> (since Linux 2.4)"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:595
msgid "process taken branch trap"
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:595
#, no-wrap
msgid "B<TRAP_HWBKPT> (since Linux 2.4)"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:598
msgid "hardware breakpoint/watchpoint"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:605
msgid "The following values can be placed in I<si_code> for a B<SIGCHLD> signal:"
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:606
#, no-wrap
msgid "B<CLD_EXITED>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:609
msgid "child has exited"
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:609
#, no-wrap
msgid "B<CLD_KILLED>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:612
msgid "child was killed"
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:612
#, no-wrap
msgid "B<CLD_DUMPED>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:615
msgid "child terminated abnormally"
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:615
#, no-wrap
msgid "B<CLD_TRAPPED>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:618
msgid "traced child has trapped"
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:618
#, no-wrap
msgid "B<CLD_STOPPED>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:621
msgid "child has stopped"
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:621
#, no-wrap
msgid "B<CLD_CONTINUED>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:624
msgid "stopped child has continued (since Linux 2.6.9)"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:631
msgid "The following values can be placed in I<si_code> for a B<SIGPOLL> signal:"
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:632
#, no-wrap
msgid "B<POLL_IN>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:635
msgid "data input available"
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:635
#, no-wrap
msgid "B<POLL_OUT>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:638
msgid "output buffers available"
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:638
#, no-wrap
msgid "B<POLL_MSG>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:641
msgid "input message available"
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:641
#, no-wrap
msgid "B<POLL_ERR>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:644
msgid "I/O error"
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:644
#, no-wrap
msgid "B<POLL_PRI>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:647
msgid "high priority input available"
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:647
#, no-wrap
msgid "B<POLL_HUP>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:650
msgid "device disconnected"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:654
msgid "B<sigaction>()  returns 0 on success and -1 on error."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:659
msgid ""
"I<act> or I<oldact> points to memory which is not a valid part of the "
"process address space."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:666
msgid ""
"An invalid signal was specified.  This will also be generated if an attempt "
"is made to change the action for B<SIGKILL> or B<SIGSTOP>, which cannot be "
"caught or ignored."
msgstr ""

#.  SVr4 does not document the EINTR condition.
#. type: Plain text
#: build/C/man2/sigaction.2:669
msgid "POSIX.1-2001, SVr4."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:677 build/C/man7/signal.7:103
msgid ""
"A child created via B<fork>(2)  inherits a copy of its parent's signal "
"dispositions.  During an B<execve>(2), the dispositions of handled signals "
"are reset to the default; the dispositions of ignored signals are left "
"unchanged."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:695 build/C/man2/signal.2:129
msgid ""
"According to POSIX, the behavior of a process is undefined after it ignores "
"a B<SIGFPE>, B<SIGILL>, or B<SIGSEGV> signal that was not generated by "
"B<kill>(2)  or B<raise>(3).  Integer division by zero has undefined result.  "
"On some architectures it will generate a B<SIGFPE> signal.  (Also dividing "
"the most negative integer by -1 may generate B<SIGFPE>.)  Ignoring this "
"signal might lead to an endless loop."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:712
msgid ""
"POSIX.1-1990 disallowed setting the action for B<SIGCHLD> to B<SIG_IGN>.  "
"POSIX.1-2001 allows this possibility, so that ignoring B<SIGCHLD> can be "
"used to prevent the creation of zombies (see B<wait>(2)).  Nevertheless, the "
"historical BSD and System V behaviors for ignoring B<SIGCHLD> differ, so "
"that the only completely portable method of ensuring that terminated "
"children do not become zombies is to catch the B<SIGCHLD> signal and perform "
"a B<wait>(2)  or similar."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:725
msgid ""
"POSIX.1-1990 only specified B<SA_NOCLDSTOP>.  POSIX.1-2001 added "
"B<SA_NOCLDWAIT>, B<SA_RESETHAND>, B<SA_NODEFER>, and B<SA_SIGINFO>.  Use of "
"these latter values in I<sa_flags> may be less portable in applications "
"intended for older UNIX implementations."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:729
msgid "The B<SA_RESETHAND> flag is compatible with the SVr4 flag of the same name."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:739
msgid ""
"The B<SA_NODEFER> flag is compatible with the SVr4 flag of the same name "
"under kernels 1.3.9 and newer.  On older kernels the Linux implementation "
"allowed the receipt of any signal, not just the one we are installing "
"(effectively overriding any I<sa_mask> settings)."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:745
msgid ""
"B<sigaction>()  can be called with a NULL second argument to query the "
"current signal handler.  It can also be used to check whether a given signal "
"is valid for the current machine by calling it with NULL second and third "
"arguments."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:751
msgid ""
"It is not possible to block B<SIGKILL> or B<SIGSTOP> (by specifying them in "
"I<sa_mask>).  Attempts to do so are silently ignored."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:755 build/C/man2/sigpending.2:65 build/C/man2/sigprocmask.2:131 build/C/man2/sigsuspend.2:104
msgid "See B<sigsetops>(3)  for details on manipulating signal sets."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:760
msgid ""
"See B<signal>(7)  for a list of the async-signal-safe functions that can be "
"safely called inside from inside a signal handler."
msgstr ""

#. type: SS
#: build/C/man2/sigaction.2:760
#, no-wrap
msgid "Undocumented"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:770
msgid ""
"Before the introduction of B<SA_SIGINFO> it was also possible to get some "
"additional information, namely by using a I<sa_handler> with second argument "
"of type I<struct sigcontext>.  See the relevant kernel sources for details.  "
"This use is obsolete now."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:779
msgid ""
"In kernels up to and including 2.6.13, specifying B<SA_NODEFER> in "
"I<sa_flags> prevents not only the delivered signal from being masked during "
"execution of the handler, but also the signals specified in I<sa_mask>.  "
"This bug was fixed in kernel 2.6.14."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:782
msgid "See B<mprotect>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:801
msgid ""
"B<kill>(1), B<kill>(2), B<killpg>(2), B<pause>(2), B<sigaltstack>(2), "
"B<signal>(2), B<signalfd>(2), B<sigpending>(2), B<sigprocmask>(2), "
"B<sigsuspend>(2), B<wait>(2), B<raise>(3), B<siginterrupt>(3), "
"B<sigqueue>(3), B<sigsetops>(3), B<sigvec>(3), B<core>(5), B<signal>(7)"
msgstr ""

#. type: TH
#: build/C/man2/sigaltstack.2:25
#, no-wrap
msgid "SIGALTSTACK"
msgstr ""

#. type: TH
#: build/C/man2/sigaltstack.2:25 build/C/man2/wait.2:50
#, no-wrap
msgid "2010-09-26"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaltstack.2:28
msgid "sigaltstack - set and/or get signal stack context"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaltstack.2:32
msgid "B<int sigaltstack(const stack_t *>I<ss>B<, stack_t *>I<oss>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaltstack.2:39
msgid "B<sigaltstack>():"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaltstack.2:46 build/C/man3/siginterrupt.3:51 build/C/man2/wait.2:79
msgid "|| /* Since glibc 2.12: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200809L"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaltstack.2:58
msgid ""
"B<sigaltstack>()  allows a process to define a new alternate signal stack "
"and/or retrieve the state of an existing alternate signal stack.  An "
"alternate signal stack is used during the execution of a signal handler if "
"the establishment of that handler (see B<sigaction>(2))  requested it."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaltstack.2:61
msgid ""
"The normal sequence of events for using an alternate signal stack is the "
"following:"
msgstr ""

#. type: IP
#: build/C/man2/sigaltstack.2:61 build/C/man7/signal.7:383
#, no-wrap
msgid "1."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaltstack.2:65
msgid "Allocate an area of memory to be used for the alternate signal stack."
msgstr ""

#. type: IP
#: build/C/man2/sigaltstack.2:65 build/C/man7/signal.7:387
#, no-wrap
msgid "2."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaltstack.2:71
msgid ""
"Use B<sigaltstack>()  to inform the system of the existence and location of "
"the alternate signal stack."
msgstr ""

#. type: IP
#: build/C/man2/sigaltstack.2:71 build/C/man7/signal.7:407
#, no-wrap
msgid "3."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaltstack.2:78
msgid ""
"When establishing a signal handler using B<sigaction>(2), inform the system "
"that the signal handler should be executed on the alternate signal stack by "
"specifying the B<SA_ONSTACK> flag."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaltstack.2:86
msgid ""
"The I<ss> argument is used to specify a new alternate signal stack, while "
"the I<oss> argument is used to retrieve information about the currently "
"established signal stack.  If we are interested in performing just one of "
"these tasks then the other argument can be specified as NULL.  Each of these "
"arguments is a structure of the following type:"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaltstack.2:94
#, no-wrap
msgid ""
"typedef struct {\n"
"    void  *ss_sp;     /* Base address of stack */\n"
"    int    ss_flags;  /* Flags */\n"
"    size_t ss_size;   /* Number of bytes in stack */\n"
"} stack_t;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaltstack.2:105
msgid ""
"To establish a new alternate signal stack, I<ss.ss_flags> is set to zero, "
"and I<ss.ss_sp> and I<ss.ss_size> specify the starting address and size of "
"the stack.  The constant B<SIGSTKSZ> is defined to be large enough to cover "
"the usual size requirements for an alternate signal stack, and the constant "
"B<MINSIGSTKSZ> defines the minimum size required to execute a signal "
"handler."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaltstack.2:109
msgid ""
"When a signal handler is invoked on the alternate stack, the kernel "
"automatically aligns the address given in I<ss.ss_sp> to a suitable address "
"boundary for the underlying hardware architecture."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaltstack.2:114
msgid ""
"To disable an existing stack, specify I<ss.ss_flags> as B<SS_DISABLE>.  In "
"this case, the remaining fields in I<ss> are ignored."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaltstack.2:122
msgid ""
"If I<oss> is not NULL, then it is used to return information about the "
"alternate signal stack which was in effect prior to the call to "
"B<sigaltstack>().  The I<oss.ss_sp> and I<oss.ss_size> fields return the "
"starting address and size of that stack.  The I<oss.ss_flags> may return "
"either of the following values:"
msgstr ""

#. type: TP
#: build/C/man2/sigaltstack.2:122
#, no-wrap
msgid "B<SS_ONSTACK>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaltstack.2:128
msgid ""
"The process is currently executing on the alternate signal stack.  (Note "
"that it is not possible to change the alternate signal stack if the process "
"is currently executing on it.)"
msgstr ""

#. type: TP
#: build/C/man2/sigaltstack.2:128
#, no-wrap
msgid "B<SS_DISABLE>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaltstack.2:131
msgid "The alternate signal stack is currently disabled."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaltstack.2:135
msgid ""
"B<sigaltstack>()  returns 0 on success, or -1 on failure with I<errno> set "
"to indicate the error."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaltstack.2:140
msgid ""
"Either I<ss> or I<oss> is not NULL and points to an area outside of the "
"process's address space."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaltstack.2:145
msgid ""
"I<ss> is not NULL and the I<ss_flags> field contains a nonzero value other "
"than B<SS_DISABLE>."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaltstack.2:149
msgid ""
"The specified size of the new alternate signal stack (I<ss.ss_size>) was "
"less than B<MINSTKSZ>."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaltstack.2:154
msgid ""
"An attempt was made to change the alternate signal stack while it was active "
"(i.e., the process was already executing on the current alternate signal "
"stack)."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaltstack.2:156
msgid "SUSv2, SVr4, POSIX.1-2001."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaltstack.2:164
msgid ""
"The most common usage of an alternate signal stack is to handle the "
"B<SIGSEGV> signal that is generated if the space available for the normal "
"process stack is exhausted: in this case, a signal handler for B<SIGSEGV> "
"cannot be invoked on the process stack; if we wish to handle it, we must use "
"an alternate signal stack."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaltstack.2:174
msgid ""
"Establishing an alternate signal stack is useful if a process expects that "
"it may exhaust its standard stack.  This may occur, for example, because the "
"stack grows so large that it encounters the upwardly growing heap, or it "
"reaches a limit established by a call to B<setrlimit(RLIMIT_STACK, &rlim)>.  "
"If the standard stack is exhausted, the kernel sends the process a "
"B<SIGSEGV> signal.  In these circumstances the only way to catch this signal "
"is on an alternate signal stack."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaltstack.2:180
msgid ""
"On most hardware architectures supported by Linux, stacks grow downward.  "
"B<sigaltstack>()  automatically takes account of the direction of stack "
"growth."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaltstack.2:189
msgid ""
"Functions called from a signal handler executing on an alternate signal "
"stack will also use the alternate signal stack.  (This also applies to any "
"handlers invoked for other signals while the process is executing on the "
"alternate signal stack.)  Unlike the standard stack, the system does not "
"automatically extend the alternate signal stack.  Exceeding the allocated "
"size of the alternate signal stack will lead to unpredictable results."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaltstack.2:197
msgid ""
"A successful call to B<execve>(2)  removes any existing alternate signal "
"stack.  A child process created via B<fork>(2)  inherits a copy of its "
"parent's alternate signal stack settings."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaltstack.2:206
msgid ""
"B<sigaltstack>()  supersedes the older B<sigstack>()  call.  For backward "
"compatibility, glibc also provides B<sigstack>().  All new applications "
"should be written using B<sigaltstack>()."
msgstr ""

#. type: SS
#: build/C/man2/sigaltstack.2:206 build/C/man3/sigpause.3:59
#, no-wrap
msgid "History"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaltstack.2:213
msgid ""
"4.2BSD had a B<sigstack>()  system call.  It used a slightly different "
"struct, and had the major disadvantage that the caller had to know the "
"direction of stack growth."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaltstack.2:216
msgid "The following code segment demonstrates the use of B<sigaltstack>():"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaltstack.2:220
#, no-wrap
msgid "stack_t ss;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaltstack.2:228
#, no-wrap
msgid ""
"ss.ss_sp = malloc(SIGSTKSZ);\n"
"if (ss.ss_sp == NULL)\n"
"    /* Handle error */;\n"
"ss.ss_size = SIGSTKSZ;\n"
"ss.ss_flags = 0;\n"
"if (sigaltstack(&ss, NULL) == -1)\n"
"    /* Handle error */;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaltstack.2:237
msgid ""
"B<execve>(2), B<setrlimit>(2), B<sigaction>(2), B<siglongjmp>(3), "
"B<sigsetjmp>(3), B<signal>(7)"
msgstr ""

#. type: TH
#: build/C/man7/sigevent.7:24
#, no-wrap
msgid "SIGEVENT"
msgstr ""

#. type: TH
#: build/C/man7/sigevent.7:24 build/C/man3/siginterrupt.3:29
#, no-wrap
msgid "2011-09-09"
msgstr ""

#. type: Plain text
#: build/C/man7/sigevent.7:27
msgid "sigevent - structure for notification from asynchronous routines"
msgstr ""

#. type: Plain text
#: build/C/man7/sigevent.7:34
#, no-wrap
msgid ""
"union sigval {          /* Data passed with notification */\n"
"    int     sival_int;         /* Integer value */\n"
"    void   *sival_ptr;         /* Pointer value */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man7/sigevent.7:49
#, no-wrap
msgid ""
"struct sigevent {\n"
"    int          sigev_notify; /* Notification method */\n"
"    int          sigev_signo;  /* Notification signal */\n"
"    union sigval sigev_value;  /* Data passed with\n"
"                                  notification */\n"
"    void       (*sigev_notify_function) (union sigval);\n"
"                     /* Function used for thread\n"
"                        notification (SIGEV_THREAD) */\n"
"    void        *sigev_notify_attributes;\n"
"                     /* Attributes for notification thread\n"
"                        (SIGEV_THREAD) */\n"
"    pid_t        sigev_notify_thread_id;\n"
"                     /* ID of thread to signal (SIGEV_THREAD_ID) */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man7/sigevent.7:58
msgid ""
"The I<sigevent> structure is used by various APIs to describe the way a "
"process is to be notified about an event (e.g., completion of an "
"asynchronous request, expiration of a timer, or the arrival of a message)."
msgstr ""

#. type: Plain text
#: build/C/man7/sigevent.7:66
msgid ""
"The definition shown in the SYNOPSIS is approximate: some of the fields in "
"the I<sigevent> structure may be defined as part of a union.  Programs "
"should only employ those fields relevant to the value specified in "
"I<sigev_notify>."
msgstr ""

#. type: Plain text
#: build/C/man7/sigevent.7:71
msgid ""
"The I<sigev_notify> field specifies how notification is to be performed.  "
"This field can have one of the following values:"
msgstr ""

#. type: TP
#: build/C/man7/sigevent.7:71 build/C/man2/timer_create.2:105
#, no-wrap
msgid "B<SIGEV_NONE>"
msgstr ""

#. type: Plain text
#: build/C/man7/sigevent.7:74
msgid "A \"null\" notification: don't do anything when the event occurs."
msgstr ""

#. type: TP
#: build/C/man7/sigevent.7:74 build/C/man2/timer_create.2:110
#, no-wrap
msgid "B<SIGEV_SIGNAL>"
msgstr ""

#. type: Plain text
#: build/C/man7/sigevent.7:78
msgid "Notify the process by sending the signal specified in I<sigev_signo>."
msgstr ""

#. type: Plain text
#: build/C/man7/sigevent.7:85
msgid ""
"If the signal is caught with a signal handler that was registered using the "
"B<sigaction>(2)  B<SA_SIGINFO> flag, then the following fields are set in "
"the I<siginfo_t> structure that is passed as the second argument of the "
"handler:"
msgstr ""

#. type: Plain text
#: build/C/man7/sigevent.7:90
msgid ""
"This field is set to a value that depends on the API delivering the "
"notification."
msgstr ""

#. type: TP
#: build/C/man7/sigevent.7:90 build/C/man2/wait.2:301
#, no-wrap
msgid "I<si_signo>"
msgstr ""

#. type: Plain text
#: build/C/man7/sigevent.7:94
msgid ""
"This field is set to the signal number (i.e., the same value as in "
"I<sigev_signo>)."
msgstr ""

#. type: Plain text
#: build/C/man7/sigevent.7:98
msgid "This field is set to the value specified in I<sigev_value>."
msgstr ""

#. type: Plain text
#: build/C/man7/sigevent.7:103
msgid ""
"Depending on the API, other fields may also be set in the I<siginfo_t> "
"structure."
msgstr ""

#. type: Plain text
#: build/C/man7/sigevent.7:106
msgid ""
"The same information is also available if the signal is accepted using "
"B<sigwaitinfo>(2)."
msgstr ""

#. type: TP
#: build/C/man7/sigevent.7:106 build/C/man2/timer_create.2:128
#, no-wrap
msgid "B<SIGEV_THREAD>"
msgstr ""

#. type: Plain text
#: build/C/man7/sigevent.7:123
msgid ""
"Notify the process by invoking I<sigev_notify_function> \"as if\" it were "
"the start function of a new thread.  (Among the implementation possibilities "
"here are that each timer notification could result in the creation of a new "
"thread, or that a single thread is created to receive all notifications.)  "
"The function is invoked with I<sigev_value> as its sole argument.  If "
"I<sigev_notify_attributes> is not NULL, it should point to a "
"I<pthread_attr_t> structure that defines attributes for the new thread (see "
"B<pthread_attr_init>(3))."
msgstr ""

#. type: TP
#: build/C/man7/sigevent.7:123 build/C/man2/timer_create.2:136
#, no-wrap
msgid "B<SIGEV_THREAD_ID> (Linux-specific)"
msgstr ""

#.  | SIGEV_SIGNAL vs not?
#. type: Plain text
#: build/C/man7/sigevent.7:128
msgid "Currently used only by POSIX timers; see B<timer_create>(2)."
msgstr ""

#. type: Plain text
#: build/C/man7/sigevent.7:130 build/C/man2/sigpending.2:61 build/C/man2/sigprocmask.2:101 build/C/man3/sigqueue.3:114 build/C/man3/sigsetops.3:128 build/C/man2/sigsuspend.2:82 build/C/man3/sigwait.3:79 build/C/man2/sigwaitinfo.2:128 build/C/man2/timer_create.2:193 build/C/man2/timer_delete.2:66 build/C/man2/timer_getoverrun.2:96 build/C/man2/timer_settime.2:205
msgid "POSIX.1-2001."
msgstr ""

#. type: Plain text
#: build/C/man7/sigevent.7:140
msgid ""
"B<timer_create>(2), B<aio_fsync>(3), B<aio_read>(3), B<aio_write>(3), "
"B<getaddrinfo_a>(3), B<lio_listio>(3), B<mq_notify>(3), B<aio>(7), "
"B<pthreads>(7)"
msgstr ""

#. type: TH
#: build/C/man3/siginterrupt.3:29
#, no-wrap
msgid "SIGINTERRUPT"
msgstr ""

#. type: Plain text
#: build/C/man3/siginterrupt.3:32
msgid "siginterrupt - allow signals to interrupt system calls"
msgstr ""

#. type: Plain text
#: build/C/man3/siginterrupt.3:37
#, no-wrap
msgid "B<int siginterrupt(int >I<sig>B<, int >I<flag>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/siginterrupt.3:45
msgid "B<siginterrupt>():"
msgstr ""

#. type: Plain text
#: build/C/man3/siginterrupt.3:62
msgid ""
"The B<siginterrupt>()  function changes the restart behavior when a system "
"call is interrupted by the signal I<sig>.  If the I<flag> argument is false "
"(0), then system calls will be restarted if interrupted by the specified "
"signal I<sig>.  This is the default behavior in Linux."
msgstr ""

#. type: Plain text
#: build/C/man3/siginterrupt.3:67
msgid ""
"If the I<flag> argument is true (1) and no data has been transferred, then a "
"system call interrupted by the signal I<sig> will return -1 and I<errno> "
"will be set to B<EINTR>."
msgstr ""

#. type: Plain text
#: build/C/man3/siginterrupt.3:71
msgid ""
"If the I<flag> argument is true (1) and data transfer has started, then the "
"system call will be interrupted and will return the actual amount of data "
"transferred."
msgstr ""

#. type: Plain text
#: build/C/man3/siginterrupt.3:76
msgid ""
"The B<siginterrupt>()  function returns 0 on success, or -1 if the signal "
"number I<sig> is invalid."
msgstr ""

#. type: Plain text
#: build/C/man3/siginterrupt.3:80
msgid "The specified signal number is invalid."
msgstr ""

#. type: Plain text
#: build/C/man3/siginterrupt.3:89
msgid ""
"4.3BSD, POSIX.1-2001.  POSIX.1-2008 marks B<siginterrupt>()  as obsolete, "
"recommending the use of B<sigaction>(2)  with the B<SA_RESTART> flag "
"instead."
msgstr ""

#. type: Plain text
#: build/C/man3/siginterrupt.3:91
msgid "B<signal>(2)"
msgstr ""

#. type: TH
#: build/C/man2/signal.2:34 build/C/man7/signal.7:44
#, no-wrap
msgid "SIGNAL"
msgstr ""

#. type: TH
#: build/C/man2/signal.2:34
#, no-wrap
msgid "2008-07-11"
msgstr ""

#. type: Plain text
#: build/C/man2/signal.2:37
msgid "signal - ANSI C signal handling"
msgstr ""

#. type: Plain text
#: build/C/man2/signal.2:43
msgid "B<sighandler_t signal(int >I<signum>B<, sighandler_t >I<handler>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/signal.2:52
msgid ""
"The behavior of B<signal>()  varies across UNIX versions, and has also "
"varied historically across different versions of Linux.  B<Avoid its use>: "
"use B<sigaction>(2)  instead.  See I<Portability> below."
msgstr ""

#. type: Plain text
#: build/C/man2/signal.2:62
msgid ""
"B<signal>()  sets the disposition of the signal I<signum> to I<handler>, "
"which is either B<SIG_IGN>, B<SIG_DFL>, or the address of a "
"programmer-defined function (a \"signal handler\")."
msgstr ""

#. type: Plain text
#: build/C/man2/signal.2:66
msgid ""
"If the signal I<signum> is delivered to the process, then one of the "
"following happens:"
msgstr ""

#. type: Plain text
#: build/C/man2/signal.2:71
msgid "If the disposition is set to B<SIG_IGN>, then the signal is ignored."
msgstr ""

#. type: Plain text
#: build/C/man2/signal.2:78
msgid ""
"If the disposition is set to B<SIG_DFL>, then the default action associated "
"with the signal (see B<signal>(7))  occurs."
msgstr ""

#. type: Plain text
#: build/C/man2/signal.2:89
msgid ""
"If the disposition is set to a function, then first either the disposition "
"is reset to B<SIG_DFL>, or the signal is blocked (see I<Portability> below), "
"and then I<handler> is called with argument I<signum>.  If invocation of the "
"handler caused the signal to be blocked, then the signal is unblocked upon "
"return from the handler."
msgstr ""

#. type: Plain text
#: build/C/man2/signal.2:95
msgid "The signals B<SIGKILL> and B<SIGSTOP> cannot be caught or ignored."
msgstr ""

#. type: Plain text
#: build/C/man2/signal.2:100
msgid ""
"B<signal>()  returns the previous value of the signal handler, or B<SIG_ERR> "
"on error."
msgstr ""

#. type: Plain text
#: build/C/man2/signal.2:105
msgid "I<signum> is invalid."
msgstr ""

#. type: Plain text
#: build/C/man2/signal.2:111
msgid "The effects of B<signal>()  in a multithreaded process are unspecified."
msgstr ""

#. type: Plain text
#: build/C/man2/signal.2:136
msgid ""
"See B<sigaction>(2)  for details on what happens when B<SIGCHLD> is set to "
"B<SIG_IGN>."
msgstr ""

#. type: Plain text
#: build/C/man2/signal.2:141
msgid ""
"See B<signal>(7)  for a list of the async-signal-safe functions that can be "
"safely called from inside a signal handler."
msgstr ""

#. type: Plain text
#: build/C/man2/signal.2:156
msgid ""
"The use of I<sighandler_t> is a GNU extension.  Various versions of libc "
"predefine this type; libc4 and libc5 define I<SignalHandler>; glibc defines "
"I<sig_t> and, when B<_GNU_SOURCE> is defined, also I<sighandler_t>.  Without "
"use of such a type, the declaration of B<signal>()  is the somewhat harder "
"to read:"
msgstr ""

#. type: Plain text
#: build/C/man2/signal.2:160
#, no-wrap
msgid ""
"B<void ( *>I<signal>B<(int >I<signum>B<, void (*>I<handler>B<)(int)) ) "
"(int);>\n"
msgstr ""

#. type: SS
#: build/C/man2/signal.2:162
#, no-wrap
msgid "Portability"
msgstr ""

#. type: Plain text
#: build/C/man2/signal.2:174
msgid ""
"The only portable use of B<signal>()  is to set a signal's disposition to "
"B<SIG_DFL> or B<SIG_IGN>.  The semantics when using B<signal>()  to "
"establish a signal handler vary across systems (and POSIX.1 explicitly "
"permits this variation); B<do not use it for this purpose.>"
msgstr ""

#. type: Plain text
#: build/C/man2/signal.2:180
msgid ""
"POSIX.1 solved the portability mess by specifying B<sigaction>(2), which "
"provides explicit control of the semantics when a signal handler is invoked; "
"use that interface instead of B<signal>()."
msgstr ""

#. type: Plain text
#: build/C/man2/signal.2:193
msgid ""
"In the original UNIX systems, when a handler that was established using "
"B<signal>()  was invoked by the delivery of a signal, the disposition of the "
"signal would be reset to B<SIG_DFL>, and the system did not block delivery "
"of further instances of the signal.  System V also provides these semantics "
"for B<signal>().  This was bad because the signal might be delivered again "
"before the handler had a chance to reestablish itself.  Furthermore, rapid "
"deliveries of the same signal could result in recursive invocations of the "
"handler."
msgstr ""

#. type: Plain text
#: build/C/man2/signal.2:203
msgid ""
"BSD improved on this situation by changing the semantics of signal handling "
"(but, unfortunately, silently changed the semantics when establishing a "
"handler with B<signal>()).  On BSD, when a signal handler is invoked, the "
"signal disposition is not reset, and further instances of the signal are "
"blocked from being delivered while the handler is executing."
msgstr ""

#. type: Plain text
#: build/C/man2/signal.2:205
msgid "The situation on Linux is as follows:"
msgstr ""

#. type: Plain text
#: build/C/man2/signal.2:209
msgid "The kernel's B<signal>()  system call provides System V semantics."
msgstr ""

#. type: Plain text
#: build/C/man2/signal.2:225
msgid ""
"By default, in glibc 2 and later, the B<signal>()  wrapper function does not "
"invoke the kernel system call.  Instead, it calls B<sigaction>(2)  using "
"flags that supply BSD semantics.  This default behavior is provided as long "
"as the B<_BSD_SOURCE> feature test macro is defined.  By default, "
"B<_BSD_SOURCE> is defined; it is also implicitly defined if one defines "
"B<_GNU_SOURCE>, and can of course be explicitly defined."
msgstr ""

#
#.  System V semantics are also provided if one uses the separate
#.  .BR sysv_signal (3)
#.  function.
#. type: Plain text
#: build/C/man2/signal.2:248
msgid ""
"On glibc 2 and later, if the B<_BSD_SOURCE> feature test macro is not "
"defined, then B<signal>()  provides System V semantics.  (The default "
"implicit definition of B<_BSD_SOURCE> is not provided if one invokes "
"B<gcc>(1)  in one of its standard modes (I<-std=xxx> or I<-ansi>)  or "
"defines various other feature test macros such as B<_POSIX_SOURCE>, "
"B<_XOPEN_SOURCE>, or B<_SVID_SOURCE>; see B<feature_test_macros>(7).)"
msgstr ""

#. type: Plain text
#: build/C/man2/signal.2:259
msgid ""
"The B<signal>()  function in Linux libc4 and libc5 provide System V "
"semantics.  If one on a libc5 system includes I<E<lt>bsd/signal.hE<gt>> "
"instead of I<E<lt>signal.hE<gt>>, then B<signal>()  provides BSD semantics."
msgstr ""

#. type: Plain text
#: build/C/man2/signal.2:278
msgid ""
"B<kill>(1), B<alarm>(2), B<kill>(2), B<killpg>(2), B<pause>(2), "
"B<sigaction>(2), B<signalfd>(2), B<sigpending>(2), B<sigprocmask>(2), "
"B<sigsuspend>(2), B<bsd_signal>(3), B<raise>(3), B<siginterrupt>(3), "
"B<sigqueue>(3), B<sigsetops>(3), B<sigvec>(3), B<sysv_signal>(3), "
"B<signal>(7)"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:47
msgid "signal - overview of signals"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:50
msgid ""
"Linux supports both POSIX reliable signals (hereinafter \"standard "
"signals\") and POSIX real-time signals."
msgstr ""

#. type: SS
#: build/C/man7/signal.7:50
#, no-wrap
msgid "Signal Dispositions"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:55
msgid ""
"Each signal has a current I<disposition>, which determines how the process "
"behaves when it is delivered the signal."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:58
msgid ""
"The entries in the \"Action\" column of the tables below specify the default "
"disposition for each signal, as follows:"
msgstr ""

#. type: IP
#: build/C/man7/signal.7:58
#, no-wrap
msgid "Term"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:60
msgid "Default action is to terminate the process."
msgstr ""

#. type: IP
#: build/C/man7/signal.7:60
#, no-wrap
msgid "Ign"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:62
msgid "Default action is to ignore the signal."
msgstr ""

#. type: IP
#: build/C/man7/signal.7:62
#, no-wrap
msgid "Core"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:65
msgid "Default action is to terminate the process and dump core (see B<core>(5))."
msgstr ""

#. type: IP
#: build/C/man7/signal.7:65
#, no-wrap
msgid "Stop"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:67
msgid "Default action is to stop the process."
msgstr ""

#. type: IP
#: build/C/man7/signal.7:67
#, no-wrap
msgid "Cont"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:69
msgid "Default action is to continue the process if it is currently stopped."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:91
msgid ""
"A process can change the disposition of a signal using B<sigaction>(2)  or "
"B<signal>(2).  (The latter is less portable when establishing a signal "
"handler; see B<signal>(2)  for details.)  Using these system calls, a "
"process can elect one of the following behaviors to occur on delivery of the "
"signal: perform the default action; ignore the signal; or catch the signal "
"with a I<signal handler>, a programmer-defined function that is "
"automatically invoked when the signal is delivered.  (By default, the signal "
"handler is invoked on the normal process stack.  It is possible to arrange "
"that the signal handler uses an alternate stack; see B<sigaltstack>(2)  for "
"a discussion of how to do this and when it might be useful.)"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:95
msgid ""
"The signal disposition is a per-process attribute: in a multithreaded "
"application, the disposition of a particular signal is the same for all "
"threads."
msgstr ""

#. type: SS
#: build/C/man7/signal.7:103
#, no-wrap
msgid "Sending a Signal"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:106
msgid ""
"The following system calls and library functions allow the caller to send a "
"signal:"
msgstr ""

#. type: TP
#: build/C/man7/signal.7:106
#, no-wrap
msgid "B<raise>(3)"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:109
msgid "Sends a signal to the calling thread."
msgstr ""

#. type: TP
#: build/C/man7/signal.7:109
#, no-wrap
msgid "B<kill>(2)"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:114
msgid ""
"Sends a signal to a specified process, to all members of a specified process "
"group, or to all processes on the system."
msgstr ""

#. type: TP
#: build/C/man7/signal.7:114
#, no-wrap
msgid "B<killpg>(2)"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:117
msgid "Sends a signal to all of the members of a specified process group."
msgstr ""

#. type: TP
#: build/C/man7/signal.7:117
#, no-wrap
msgid "B<pthread_kill>(3)"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:121
msgid ""
"Sends a signal to a specified POSIX thread in the same process as the "
"caller."
msgstr ""

#. type: TP
#: build/C/man7/signal.7:121
#, no-wrap
msgid "B<tgkill>(2)"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:126
msgid ""
"Sends a signal to a specified thread within a specific process.  (This is "
"the system call used to implement B<pthread_kill>(3).)"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:129
msgid "Sends a real-time signal with accompanying data to a specified process."
msgstr ""

#. type: SS
#: build/C/man7/signal.7:129
#, no-wrap
msgid "Waiting for a Signal to be Caught"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:133
msgid ""
"The following system calls suspend execution of the calling process or "
"thread until a signal is caught (or an unhandled signal terminates the "
"process):"
msgstr ""

#. type: TP
#: build/C/man7/signal.7:133
#, no-wrap
msgid "B<pause>(2)"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:136
msgid "Suspends execution until any signal is caught."
msgstr ""

#. type: TP
#: build/C/man7/signal.7:136
#, no-wrap
msgid "B<sigsuspend>(2)"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:140
msgid ""
"Temporarily changes the signal mask (see below) and suspends execution until "
"one of the unmasked signals is caught."
msgstr ""

#. type: SS
#: build/C/man7/signal.7:140
#, no-wrap
msgid "Synchronously Accepting a Signal"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:147
msgid ""
"Rather than asynchronously catching a signal via a signal handler, it is "
"possible to synchronously accept the signal, that is, to block execution "
"until the signal is delivered, at which point the kernel returns information "
"about the signal to the caller.  There are two general ways to do this:"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:155
msgid ""
"B<sigwaitinfo>(2), B<sigtimedwait>(2), and B<sigwait>(3)  suspend execution "
"until one of the signals in a specified set is delivered.  Each of these "
"calls returns information about the delivered signal."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:168
msgid ""
"B<signalfd>(2)  returns a file descriptor that can be used to read "
"information about signals that are delivered to the caller.  Each B<read>(2)  "
"from this file descriptor blocks until one of the signals in the set "
"specified in the B<signalfd>(2)  call is delivered to the caller.  The "
"buffer returned by B<read>(2)  contains a structure describing the signal."
msgstr ""

#. type: SS
#: build/C/man7/signal.7:168
#, no-wrap
msgid "Signal Mask and Pending Signals"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:175
msgid ""
"A signal may be I<blocked>, which means that it will not be delivered until "
"it is later unblocked.  Between the time when it is generated and when it is "
"delivered a signal is said to be I<pending>."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:184
msgid ""
"Each thread in a process has an independent I<signal mask>, which indicates "
"the set of signals that the thread is currently blocking.  A thread can "
"manipulate its signal mask using B<pthread_sigmask>(3).  In a traditional "
"single-threaded application, B<sigprocmask>(2)  can be used to manipulate "
"the signal mask."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:190 build/C/man2/sigprocmask.2:113
msgid ""
"A child created via B<fork>(2)  inherits a copy of its parent's signal mask; "
"the signal mask is preserved across B<execve>(2)."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:207
msgid ""
"A signal may be generated (and thus pending)  for a process as a whole "
"(e.g., when sent using B<kill>(2))  or for a specific thread (e.g., certain "
"signals, such as B<SIGSEGV> and B<SIGFPE>, generated as a consequence of "
"executing a specific machine-language instruction are thread directed, as "
"are signals targeted at a specific thread using B<pthread_kill>(3)).  A "
"process-directed signal may be delivered to any one of the threads that does "
"not currently have the signal blocked.  If more than one of the threads has "
"the signal unblocked, then the kernel chooses an arbitrary thread to which "
"to deliver the signal."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:214
msgid ""
"A thread can obtain the set of signals that it currently has pending using "
"B<sigpending>(2).  This set will consist of the union of the set of pending "
"process-directed signals and the set of signals pending for the calling "
"thread."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:220 build/C/man2/sigpending.2:76
msgid ""
"A child created via B<fork>(2)  initially has an empty pending signal set; "
"the pending signal set is preserved across an B<execve>(2)."
msgstr ""

#. type: SS
#: build/C/man7/signal.7:220
#, no-wrap
msgid "Standard Signals"
msgstr ""

#.  parisc is a law unto itself
#. type: Plain text
#: build/C/man7/signal.7:230
msgid ""
"Linux supports the standard signals listed below.  Several signal numbers "
"are architecture-dependent, as indicated in the \"Value\" column.  (Where "
"three values are given, the first one is usually valid for alpha and sparc, "
"the middle one for ix86, ia64, ppc, s390, arm and sh, and the last one for "
"mips.  A - denotes that a signal is absent on the corresponding "
"architecture.)"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:232
msgid "First the signals described in the original POSIX.1-1990 standard."
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:236 build/C/man7/signal.7:272 build/C/man7/signal.7:301
#, no-wrap
msgid "Signal\tValue\tAction\tComment\n"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:237
#, no-wrap
msgid "SIGHUP\t\\01\tTerm\tHangup detected on controlling terminal\n"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:238
#, no-wrap
msgid "\t\t\tor death of controlling process\n"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:239
#, no-wrap
msgid "SIGINT\t\\02\tTerm\tInterrupt from keyboard\n"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:240
#, no-wrap
msgid "SIGQUIT\t\\03\tCore\tQuit from keyboard\n"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:241
#, no-wrap
msgid "SIGILL\t\\04\tCore\tIllegal Instruction\n"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:242
#, no-wrap
msgid "SIGABRT\t\\06\tCore\tAbort signal from B<abort>(3)\n"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:243
#, no-wrap
msgid "SIGFPE\t\\08\tCore\tFloating point exception\n"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:244
#, no-wrap
msgid "SIGKILL\t\\09\tTerm\tKill signal\n"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:245
#, no-wrap
msgid "SIGSEGV\t11\tCore\tInvalid memory reference\n"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:246
#, no-wrap
msgid "SIGPIPE\t13\tTerm\tBroken pipe: write to pipe with no\n"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:247
#, no-wrap
msgid "\t\t\treaders\n"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:248
#, no-wrap
msgid "SIGALRM\t14\tTerm\tTimer signal from B<alarm>(2)\n"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:249
#, no-wrap
msgid "SIGTERM\t15\tTerm\tTermination signal\n"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:250
#, no-wrap
msgid "SIGUSR1\t30,10,16\tTerm\tUser-defined signal 1\n"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:251
#, no-wrap
msgid "SIGUSR2\t31,12,17\tTerm\tUser-defined signal 2\n"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:252
#, no-wrap
msgid "SIGCHLD\t20,17,18\tIgn\tChild stopped or terminated\n"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:253
#, no-wrap
msgid "SIGCONT\t19,18,25\tCont\tContinue if stopped\n"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:254
#, no-wrap
msgid "SIGSTOP\t17,19,23\tStop\tStop process\n"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:255
#, no-wrap
msgid "SIGTSTP\t18,20,24\tStop\tStop typed at tty\n"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:256
#, no-wrap
msgid "SIGTTIN\t21,21,26\tStop\ttty input for background process\n"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:257
#, no-wrap
msgid "SIGTTOU\t22,22,27\tStop\ttty output for background process\n"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:265
msgid "The signals B<SIGKILL> and B<SIGSTOP> cannot be caught, blocked, or ignored."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:268
msgid ""
"Next the signals not in the POSIX.1-1990 standard but described in SUSv2 and "
"POSIX.1-2001."
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:273
#, no-wrap
msgid "SIGBUS\t10,7,10\tCore\tBus error (bad memory access)\n"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:274
#, no-wrap
msgid "SIGPOLL\t\tTerm\tPollable event (Sys V).\n"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:275
#, no-wrap
msgid "\t\t\tSynonym for B<SIGIO>\n"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:276
#, no-wrap
msgid "SIGPROF\t27,27,29\tTerm\tProfiling timer expired\n"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:277
#, no-wrap
msgid "SIGSYS\t12,31,12\tCore\tBad argument to routine (SVr4)\n"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:278
#, no-wrap
msgid "SIGTRAP\t5\tCore\tTrace/breakpoint trap\n"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:279
#, no-wrap
msgid "SIGURG\t16,23,21\tIgn\tUrgent condition on socket (4.2BSD)\n"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:280
#, no-wrap
msgid "SIGVTALRM\t26,26,28\tTerm\tVirtual alarm clock (4.2BSD)\n"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:281
#, no-wrap
msgid "SIGXCPU\t24,24,30\tCore\tCPU time limit exceeded (4.2BSD)\n"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:282
#, no-wrap
msgid "SIGXFSZ\t25,25,31\tCore\tFile size limit exceeded (4.2BSD)\n"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:295
msgid ""
"Up to and including Linux 2.2, the default behavior for B<SIGSYS>, "
"B<SIGXCPU>, B<SIGXFSZ>, and (on architectures other than SPARC and MIPS)  "
"B<SIGBUS> was to terminate the process (without a core dump).  (On some "
"other UNIX systems the default action for B<SIGXCPU> and B<SIGXFSZ> is to "
"terminate the process without a core dump.)  Linux 2.4 conforms to the "
"POSIX.1-2001 requirements for these signals, terminating the process with a "
"core dump."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:297
msgid "Next various other signals."
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:302
#, no-wrap
msgid "SIGIOT\t6\tCore\tIOT trap. A synonym for B<SIGABRT>\n"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:303
#, no-wrap
msgid "SIGEMT\t7,-,7\tTerm\n"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:304
#, no-wrap
msgid "SIGSTKFLT\t-,16,-\tTerm\tStack fault on coprocessor (unused)\n"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:305
#, no-wrap
msgid "SIGIO\t23,29,22\tTerm\tI/O now possible (4.2BSD)\n"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:306
#, no-wrap
msgid "SIGCLD\t-,-,18\tIgn\tA synonym for B<SIGCHLD>\n"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:307
#, no-wrap
msgid "SIGPWR\t29,30,19\tTerm\tPower failure (System V)\n"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:308
#, no-wrap
msgid "SIGINFO\t29,-,-\t\tA synonym for B<SIGPWR>\n"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:309
#, no-wrap
msgid "SIGLOST\t-,-,-\tTerm\tFile lock lost\n"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:310
#, no-wrap
msgid "SIGWINCH\t28,28,20\tIgn\tWindow resize signal (4.3BSD, Sun)\n"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:311
#, no-wrap
msgid "SIGUNUSED\t-,31,-\tCore\tSynonymous with B<SIGSYS>\n"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:321
msgid "(Signal 29 is B<SIGINFO> / B<SIGPWR> on an alpha but B<SIGLOST> on a sparc.)"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:327
msgid ""
"B<SIGEMT> is not specified in POSIX.1-2001, but nevertheless appears on most "
"other UNIX systems, where its default action is typically to terminate the "
"process with a core dump."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:331
msgid ""
"B<SIGPWR> (which is not specified in POSIX.1-2001) is typically ignored by "
"default on those other UNIX systems where it appears."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:335
msgid ""
"B<SIGIO> (which is not specified in POSIX.1-2001) is ignored by default on "
"several other UNIX systems."
msgstr ""

#.  parisc is the only exception: SIGSYS is 12, SIGUNUSED is 31
#. type: Plain text
#: build/C/man7/signal.7:342
msgid ""
"Where defined, B<SIGUNUSED> is synonymous with B<SIGSYS> on most "
"architectures."
msgstr ""

#. type: SS
#: build/C/man7/signal.7:342
#, no-wrap
msgid "Real-time Signals"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:352
msgid ""
"Linux supports real-time signals as originally defined in the POSIX.1b "
"real-time extensions (and now included in POSIX.1-2001).  The range of "
"supported real-time signals is defined by the macros B<SIGRTMIN> and "
"B<SIGRTMAX>.  POSIX.1-2001 requires that an implementation support at least "
"B<_POSIX_RTSIG_MAX> (8) real-time signals."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:374
msgid ""
"The Linux kernel supports a range of 32 different real-time signals, "
"numbered 33 to 64.  However, the glibc POSIX threads implementation "
"internally uses two (for NPTL) or three (for LinuxThreads) real-time signals "
"(see B<pthreads>(7)), and adjusts the value of B<SIGRTMIN> suitably (to 34 "
"or 35).  Because the range of available real-time signals varies according "
"to the glibc threading implementation (and this variation can occur at run "
"time according to the available kernel and glibc), and indeed the range of "
"real-time signals varies across UNIX systems, programs should I<never refer "
"to real-time signals using hard-coded numbers>, but instead should always "
"refer to real-time signals using the notation B<SIGRTMIN>+n, and include "
"suitable (run-time) checks that B<SIGRTMIN>+n does not exceed B<SIGRTMAX>."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:378
msgid ""
"Unlike standard signals, real-time signals have no predefined meanings: the "
"entire set of real-time signals can be used for application-defined "
"purposes."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:381
msgid ""
"The default action for an unhandled real-time signal is to terminate the "
"receiving process."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:383
msgid "Real-time signals are distinguished by the following:"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:387
msgid ""
"Multiple instances of real-time signals can be queued.  By contrast, if "
"multiple instances of a standard signal are delivered while that signal is "
"currently blocked, then only one instance is queued."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:407
msgid ""
"If the signal is sent using B<sigqueue>(3), an accompanying value (either an "
"integer or a pointer) can be sent with the signal.  If the receiving process "
"establishes a handler for this signal using the B<SA_SIGINFO> flag to "
"B<sigaction>(2)  then it can obtain this data via the I<si_value> field of "
"the I<siginfo_t> structure passed as the second argument to the handler.  "
"Furthermore, the I<si_pid> and I<si_uid> fields of this structure can be "
"used to obtain the PID and real user ID of the process sending the signal."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:416
msgid ""
"Real-time signals are delivered in a guaranteed order.  Multiple real-time "
"signals of the same type are delivered in the order they were sent.  If "
"different real-time signals are sent to a process, they are delivered "
"starting with the lowest-numbered signal.  (I.e., low-numbered signals have "
"highest priority.)  By contrast, if multiple standard signals are pending "
"for a process, the order in which they are delivered is unspecified."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:421
msgid ""
"If both standard and real-time signals are pending for a process, POSIX "
"leaves it unspecified which is delivered first.  Linux, like many other "
"implementations, gives priority to standard signals in this case."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:444
msgid ""
"According to POSIX, an implementation should permit at least "
"B<_POSIX_SIGQUEUE_MAX> (32) real-time signals to be queued to a process.  "
"However, Linux does things differently.  In kernels up to and including "
"2.6.7, Linux imposes a system-wide limit on the number of queued real-time "
"signals for all processes.  This limit can be viewed and (with privilege) "
"changed via the I</proc/sys/kernel/rtsig-max> file.  A related file, "
"I</proc/sys/kernel/rtsig-nr>, can be used to find out how many real-time "
"signals are currently queued.  In Linux 2.6.8, these I</proc> interfaces "
"were replaced by the B<RLIMIT_SIGPENDING> resource limit, which specifies a "
"per-user limit for queued signals; see B<setrlimit>(2)  for further details."
msgstr ""

#. type: SS
#: build/C/man7/signal.7:444
#, no-wrap
msgid "Async-signal-safe functions"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:453
msgid ""
"A signal handler function must be very careful, since processing elsewhere "
"may be interrupted at some arbitrary point in the execution of the program.  "
"POSIX has the concept of \"safe function\".  If a signal interrupts the "
"execution of an unsafe function, and I<handler> calls an unsafe function, "
"then the behavior of the program is undefined."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:457
msgid ""
"POSIX.1-2004 (also known as POSIX.1-2001 Technical Corrigendum 2)  requires "
"an implementation to guarantee that the following functions can be safely "
"called inside a signal handler:"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:578
#, no-wrap
msgid ""
"_Exit()\n"
"_exit()\n"
"abort()\n"
"accept()\n"
"access()\n"
"aio_error()\n"
"aio_return()\n"
"aio_suspend()\n"
"alarm()\n"
"bind()\n"
"cfgetispeed()\n"
"cfgetospeed()\n"
"cfsetispeed()\n"
"cfsetospeed()\n"
"chdir()\n"
"chmod()\n"
"chown()\n"
"clock_gettime()\n"
"close()\n"
"connect()\n"
"creat()\n"
"dup()\n"
"dup2()\n"
"execle()\n"
"execve()\n"
"fchmod()\n"
"fchown()\n"
"fcntl()\n"
"fdatasync()\n"
"fork()\n"
"fpathconf()\n"
"fstat()\n"
"fsync()\n"
"ftruncate()\n"
"getegid()\n"
"geteuid()\n"
"getgid()\n"
"getgroups()\n"
"getpeername()\n"
"getpgrp()\n"
"getpid()\n"
"getppid()\n"
"getsockname()\n"
"getsockopt()\n"
"getuid()\n"
"kill()\n"
"link()\n"
"listen()\n"
"lseek()\n"
"lstat()\n"
"mkdir()\n"
"mkfifo()\n"
"open()\n"
"pathconf()\n"
"pause()\n"
"pipe()\n"
"poll()\n"
"posix_trace_event()\n"
"pselect()\n"
"raise()\n"
"read()\n"
"readlink()\n"
"recv()\n"
"recvfrom()\n"
"recvmsg()\n"
"rename()\n"
"rmdir()\n"
"select()\n"
"sem_post()\n"
"send()\n"
"sendmsg()\n"
"sendto()\n"
"setgid()\n"
"setpgid()\n"
"setsid()\n"
"setsockopt()\n"
"setuid()\n"
"shutdown()\n"
"sigaction()\n"
"sigaddset()\n"
"sigdelset()\n"
"sigemptyset()\n"
"sigfillset()\n"
"sigismember()\n"
"signal()\n"
"sigpause()\n"
"sigpending()\n"
"sigprocmask()\n"
"sigqueue()\n"
"sigset()\n"
"sigsuspend()\n"
"sleep()\n"
"sockatmark()\n"
"socket()\n"
"socketpair()\n"
"stat()\n"
"symlink()\n"
"sysconf()\n"
"tcdrain()\n"
"tcflow()\n"
"tcflush()\n"
"tcgetattr()\n"
"tcgetpgrp()\n"
"tcsendbreak()\n"
"tcsetattr()\n"
"tcsetpgrp()\n"
"time()\n"
"timer_getoverrun()\n"
"timer_gettime()\n"
"timer_settime()\n"
"times()\n"
"umask()\n"
"uname()\n"
"unlink()\n"
"utime()\n"
"wait()\n"
"waitpid()\n"
"write()\n"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:583
msgid ""
"POSIX.1-2008 removes fpathconf(), pathconf(), and sysconf()  from the above "
"list, and adds the following functions:"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:606
#, no-wrap
msgid ""
"execl()\n"
"execv()\n"
"faccessat()\n"
"fchmodat()\n"
"fchownat()\n"
"fexecve()\n"
"fstatat()\n"
"futimens()\n"
"linkat()\n"
"mkdirat()\n"
"mkfifoat()\n"
"mknod()\n"
"mknodat()\n"
"openat()\n"
"readlinkat()\n"
"renameat()\n"
"symlinkat()\n"
"unlinkat()\n"
"utimensat()\n"
"utimes()\n"
msgstr ""

#. type: SS
#: build/C/man7/signal.7:608
#, no-wrap
msgid "Interruption of System Calls and Library Functions by Signal Handlers"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:611
msgid ""
"If a signal handler is invoked while a system call or library function call "
"is blocked, then either:"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:613
msgid "the call is automatically restarted after the signal handler returns; or"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:616
msgid "the call fails with the error B<EINTR>."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:624
msgid ""
"Which of these two behaviors occurs depends on the interface and whether or "
"not the signal handler was established using the B<SA_RESTART> flag (see "
"B<sigaction>(2)).  The details vary across UNIX systems; below, the details "
"for Linux."
msgstr ""

#.  The following system calls use ERESTARTSYS,
#.  so that they are restartable
#. type: Plain text
#: build/C/man7/signal.7:633
msgid ""
"If a blocked call to one of the following interfaces is interrupted by a "
"signal handler, then the call will be automatically restarted after the "
"signal handler returns if the B<SA_RESTART> flag was used; otherwise the "
"call will fail with the error B<EINTR>:"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:649
msgid ""
"B<read>(2), B<readv>(2), B<write>(2), B<writev>(2), and B<ioctl>(2)  calls "
"on \"slow\" devices.  A \"slow\" device is one where the I/O call may block "
"for an indefinite time, for example, a terminal, pipe, or socket.  (A disk "
"is not a slow device according to this definition.)  If an I/O call on a "
"slow device has already transferred some data by the time it is interrupted "
"by a signal handler, then the call will return a success status (normally, "
"the number of bytes transferred)."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:653
msgid "B<open>(2), if it can block (e.g., when opening a FIFO; see B<fifo>(7))."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:660
msgid "B<wait>(2), B<wait3>(2), B<wait4>(2), B<waitid>(2), and B<waitpid>(2)."
msgstr ""

#.  If a timeout (setsockopt()) is in effect on the socket, then these
#.  system calls switch to using EINTR.  Consequently, they and are not
#.  automatically restarted, and they show the stop/cont behavior
#.  described below.  (Verified from 2.6.26 source, and by experiment; mtk)
#. type: Plain text
#: build/C/man7/signal.7:676
msgid ""
"Socket interfaces: B<accept>(2), B<connect>(2), B<recv>(2), B<recvfrom>(2), "
"B<recvmsg>(2), B<send>(2), B<sendto>(2), and B<sendmsg>(2), unless a timeout "
"has been set on the socket (see below)."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:682
msgid "File locking interfaces: B<flock>(2)  and B<fcntl>(2)  B<F_SETLKW>."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:689
msgid ""
"POSIX message queue interfaces: B<mq_receive>(3), B<mq_timedreceive>(3), "
"B<mq_send>(3), and B<mq_timedsend>(3)."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:694
msgid ""
"B<futex>(2)  B<FUTEX_WAIT> (since Linux 2.6.22; beforehand, always failed "
"with B<EINTR>)."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:701
msgid ""
"POSIX semaphore interfaces: B<sem_wait>(3)  and B<sem_timedwait>(3)  (since "
"Linux 2.6.22; beforehand, always failed with B<EINTR>)."
msgstr ""

#.  These are the system calls that give EINTR or ERESTARTNOHAND
#.  on interruption by a signal handler.
#. type: Plain text
#: build/C/man7/signal.7:712
msgid ""
"The following interfaces are never restarted after being interrupted by a "
"signal handler, regardless of the use of B<SA_RESTART>; they always fail "
"with the error B<EINTR> when interrupted by a signal handler:"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:732 build/C/man7/signal.7:806
msgid ""
"Socket interfaces, when a timeout has been set on the socket using "
"B<setsockopt>(2): B<accept>(2), B<recv>(2), B<recvfrom>(2), and "
"B<recvmsg>(2), if a receive timeout (B<SO_RCVTIMEO>)  has been set; "
"B<connect>(2), B<send>(2), B<sendto>(2), and B<sendmsg>(2), if a send "
"timeout (B<SO_SNDTIMEO>)  has been set."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:739
msgid ""
"Interfaces used to wait for signals: B<pause>(2), B<sigsuspend>(2), "
"B<sigtimedwait>(2), and B<sigwaitinfo>(2)."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:748
msgid ""
"File descriptor multiplexing interfaces: B<epoll_wait>(2), "
"B<epoll_pwait>(2), B<poll>(2), B<ppoll>(2), B<select>(2), and B<pselect>(2)."
msgstr ""

#.  On some other systems, SA_RESTART does restart these system calls
#. type: Plain text
#: build/C/man7/signal.7:756
msgid ""
"System V IPC interfaces: B<msgrcv>(2), B<msgsnd>(2), B<semop>(2), and "
"B<semtimedop>(2)."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:762
msgid "Sleep interfaces: B<clock_nanosleep>(2), B<nanosleep>(2), and B<usleep>(3)."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:767 build/C/man7/signal.7:820
msgid "B<read>(2)  from an B<inotify>(7)  file descriptor."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:769
msgid "B<io_getevents>(2)."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:775
msgid ""
"The B<sleep>(3)  function is also never restarted if interrupted by a "
"handler, but gives a success return: the number of seconds remaining to "
"sleep."
msgstr ""

#. type: SS
#: build/C/man7/signal.7:775
#, no-wrap
msgid "Interruption of System Calls and Library Functions by Stop Signals"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:784
msgid ""
"On Linux, even in the absence of signal handlers, certain blocking "
"interfaces can fail with the error B<EINTR> after the process is stopped by "
"one of the stop signals and then resumed via B<SIGCONT>.  This behavior is "
"not sanctioned by POSIX.1, and doesn't occur on other systems."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:786
msgid "The Linux interfaces that display this behavior are:"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:809
msgid "B<epoll_wait>(2), B<epoll_pwait>(2)."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:812
msgid "B<semop>(2), B<semtimedop>(2)."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:815
msgid "B<sigtimedwait>(2), B<sigwaitinfo>(2)."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:826
msgid ""
"Linux 2.6.21 and earlier: B<futex>(2)  B<FUTEX_WAIT>, B<sem_timedwait>(3), "
"B<sem_wait>(3)."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:830
msgid "Linux 2.6.8 and earlier: B<msgrcv>(2), B<msgsnd>(2)."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:833
msgid "Linux 2.4 and earlier: B<nanosleep>(2)."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:836
msgid "POSIX.1, except as noted."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:845
msgid ""
"B<SIGIO> and B<SIGLOST> have the same value.  The latter is commented out in "
"the kernel source, but the build process of some software still thinks that "
"signal 29 is B<SIGLOST>."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:878
msgid ""
"B<kill>(1), B<getrlimit>(2), B<kill>(2), B<killpg>(2), "
"B<rt_sigqueueinfo>(2), B<setitimer>(2), B<setrlimit>(2), B<sgetmask>(2), "
"B<sigaction>(2), B<sigaltstack>(2), B<signal>(2), B<signalfd>(2), "
"B<sigpending>(2), B<sigprocmask>(2), B<sigsuspend>(2), B<sigwaitinfo>(2), "
"B<abort>(3), B<bsd_signal>(3), B<longjmp>(3), B<raise>(3), "
"B<pthread_sigqueue>(3), B<sigqueue>(3), B<sigset>(3), B<sigsetops>(3), "
"B<sigvec>(3), B<sigwait>(3), B<strsignal>(3), B<sysv_signal>(3), B<core>(5), "
"B<proc>(5), B<pthreads>(7), B<sigevent>(7)"
msgstr ""

#. type: TH
#: build/C/man2/signalfd.2:19
#, no-wrap
msgid "SIGNALFD"
msgstr ""

#. type: TH
#: build/C/man2/signalfd.2:19
#, no-wrap
msgid "2009-01-13"
msgstr ""

#. type: Plain text
#: build/C/man2/signalfd.2:22
msgid "signalfd - create a file descriptor for accepting signals"
msgstr ""

#. type: Plain text
#: build/C/man2/signalfd.2:24
msgid "B<#include E<lt>sys/signalfd.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man2/signalfd.2:26
msgid "B<int signalfd(int >I<fd>B<, const sigset_t *>I<mask>B<, int >I<flags>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/signalfd.2:37
msgid ""
"B<signalfd>()  creates a file descriptor that can be used to accept signals "
"targeted at the caller.  This provides an alternative to the use of a signal "
"handler or B<sigwaitinfo>(2), and has the advantage that the file descriptor "
"may be monitored by B<select>(2), B<poll>(2), and B<epoll>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/signalfd.2:57
msgid ""
"The I<mask> argument specifies the set of signals that the caller wishes to "
"accept via the file descriptor.  This argument is a signal set whose "
"contents can be initialized using the macros described in B<sigsetops>(3).  "
"Normally, the set of signals to be received via the file descriptor should "
"be blocked using B<sigprocmask>(2), to prevent the signals being handled "
"according to their default dispositions.  It is not possible to receive "
"B<SIGKILL> or B<SIGSTOP> signals via a signalfd file descriptor; these "
"signals are silently ignored if specified in I<mask>."
msgstr ""

#. type: Plain text
#: build/C/man2/signalfd.2:71
msgid ""
"If the I<fd> argument is -1, then the call creates a new file descriptor and "
"associates the signal set specified in I<mask> with that descriptor.  If "
"I<fd> is not -1, then it must specify a valid existing signalfd file "
"descriptor, and I<mask> is used to replace the signal set associated with "
"that descriptor."
msgstr ""

#. type: Plain text
#: build/C/man2/signalfd.2:76
msgid ""
"Starting with Linux 2.6.27, the following values may be bitwise ORed in "
"I<flags> to change the behaviour of B<signalfd>():"
msgstr ""

#. type: TP
#: build/C/man2/signalfd.2:76
#, no-wrap
msgid "B<SFD_NONBLOCK>"
msgstr ""

#. type: TP
#: build/C/man2/signalfd.2:84
#, no-wrap
msgid "B<SFD_CLOEXEC>"
msgstr ""

#. type: Plain text
#: build/C/man2/signalfd.2:101
msgid ""
"B<signalfd>()  returns a file descriptor that supports the following "
"operations:"
msgstr ""

#. type: Plain text
#: build/C/man2/signalfd.2:120
msgid ""
"If one or more of the signals specified in I<mask> is pending for the "
"process, then the buffer supplied to B<read>(2)  is used to return one or "
"more I<signalfd_siginfo> structures (see below) that describe the signals.  "
"The B<read>(2)  returns information for as many signals as are pending and "
"will fit in the supplied buffer.  The buffer must be at least "
"I<sizeof(struct signalfd_siginfo)> bytes.  The return value of the "
"B<read>(2)  is the total number of bytes read."
msgstr ""

#. type: Plain text
#: build/C/man2/signalfd.2:128
msgid ""
"As a consequence of the B<read>(2), the signals are consumed, so that they "
"are no longer pending for the process (i.e., will not be caught by signal "
"handlers, and cannot be accepted using B<sigwaitinfo>(2))."
msgstr ""

#. type: Plain text
#: build/C/man2/signalfd.2:139
msgid ""
"If none of the signals in I<mask> is pending for the process, then the "
"B<read>(2)  either blocks until one of the signals in I<mask> is generated "
"for the process, or fails with the error B<EAGAIN> if the file descriptor "
"has been made nonblocking."
msgstr ""

#. type: Plain text
#: build/C/man2/signalfd.2:152
msgid ""
"The file descriptor is readable (the B<select>(2)  I<readfds> argument; the "
"B<poll>(2)  B<POLLIN> flag)  if one or more of the signals in I<mask> is "
"pending for the process."
msgstr ""

#. type: Plain text
#: build/C/man2/signalfd.2:159
msgid ""
"The signalfd file descriptor also supports the other file-descriptor "
"multiplexing APIs: B<pselect>(2), B<ppoll>(2), and B<epoll>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/signalfd.2:164
msgid ""
"When the file descriptor is no longer required it should be closed.  When "
"all file descriptors associated with the same signalfd object have been "
"closed, the resources for object are freed by the kernel."
msgstr ""

#. type: SS
#: build/C/man2/signalfd.2:164
#, no-wrap
msgid "The signalfd_siginfo structure"
msgstr ""

#. type: Plain text
#: build/C/man2/signalfd.2:170
msgid ""
"The format of the I<signalfd_siginfo> structure(s) returned by B<read>(2)s "
"from a signalfd file descriptor is as follows:"
msgstr ""

#.  ssi_trapno is unused on most arches
#. type: Plain text
#: build/C/man2/signalfd.2:195
#, no-wrap
msgid ""
"struct signalfd_siginfo {\n"
"    uint32_t ssi_signo;   /* Signal number */\n"
"    int32_t  ssi_errno;   /* Error number (unused) */\n"
"    int32_t  ssi_code;    /* Signal code */\n"
"    uint32_t ssi_pid;     /* PID of sender */\n"
"    uint32_t ssi_uid;     /* Real UID of sender */\n"
"    int32_t  ssi_fd;      /* File descriptor (SIGIO) */\n"
"    uint32_t ssi_tid;     /* Kernel timer ID (POSIX timers)\n"
"    uint32_t ssi_band;    /* Band event (SIGIO) */\n"
"    uint32_t ssi_overrun; /* POSIX timer overrun count */\n"
"    uint32_t ssi_trapno;  /* Trap number that caused signal */\n"
"    int32_t  ssi_status;  /* Exit status or signal (SIGCHLD) */\n"
"    int32_t  ssi_int;     /* Integer sent by sigqueue(3) */\n"
"    uint64_t ssi_ptr;     /* Pointer sent by sigqueue(3) */\n"
"    uint64_t ssi_utime;   /* User CPU time consumed (SIGCHLD) */\n"
"    uint64_t ssi_stime;   /* System CPU time consumed (SIGCHLD) */\n"
"    uint64_t ssi_addr;    /* Address that generated signal\n"
"                             (for hardware-generated signals) */\n"
"    uint8_t  pad[I<X>];      /* Pad size to 128 bytes (allow for\n"
"                              additional fields in the future) */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/signalfd.2:218
msgid ""
"Each of the fields in this structure is analogous to the similarly named "
"field in the I<siginfo_t> structure.  The I<siginfo_t> structure is "
"described in B<sigaction>(2).  Not all fields in the returned "
"I<signalfd_siginfo> structure will be valid for a specific signal; the set "
"of valid fields can be determined from the value returned in the I<ssi_code> "
"field.  This field is the analog of the I<siginfo_t> I<si_code> field; see "
"B<sigaction>(2)  for details."
msgstr ""

#. type: SS
#: build/C/man2/signalfd.2:218 build/C/man2/timerfd_create.2:268
#, no-wrap
msgid "fork(2) semantics"
msgstr ""

#. type: Plain text
#: build/C/man2/signalfd.2:226
msgid ""
"After a B<fork>(2), the child inherits a copy of the signalfd file "
"descriptor.  A B<read>(2)  from the file descriptor in the child will return "
"information about signals queued to the child."
msgstr ""

#. type: SS
#: build/C/man2/signalfd.2:226 build/C/man2/timerfd_create.2:280
#, no-wrap
msgid "execve(2) semantics"
msgstr ""

#. type: Plain text
#: build/C/man2/signalfd.2:238
msgid ""
"Just like any other file descriptor, a signalfd file descriptor remains open "
"across an B<execve>(2), unless it has been marked for close-on-exec (see "
"B<fcntl>(2)).  Any signals that were available for reading before the "
"B<execve>(2)  remain available to the newly loaded program.  (This is "
"analogous to traditional signal semantics, where a blocked signal that is "
"pending remains pending across an B<execve>(2).)"
msgstr ""

#. type: SS
#: build/C/man2/signalfd.2:238
#, no-wrap
msgid "Thread semantics"
msgstr ""

#. type: Plain text
#: build/C/man2/signalfd.2:248
msgid ""
"The semantics of signalfd file descriptors in a multithreaded program mirror "
"the standard semantics for signals.  In other words, when a thread reads "
"from a signalfd file descriptor, it will read the signals that are directed "
"to the thread itself and the signals that are directed to the process (i.e., "
"the entire thread group).  (A thread will not be able to read signals that "
"are directed to other threads in the process.)"
msgstr ""

#. type: Plain text
#: build/C/man2/signalfd.2:262
msgid ""
"On success, B<signalfd>()  returns a signalfd file descriptor; this is "
"either a new file descriptor (if I<fd> was -1), or I<fd> if I<fd> was a "
"valid signalfd file descriptor.  On error, -1 is returned and I<errno> is "
"set to indicate the error."
msgstr ""

#. type: TP
#: build/C/man2/signalfd.2:263 build/C/man2/timerfd_create.2:337
#, no-wrap
msgid "B<EBADF>"
msgstr ""

#. type: Plain text
#: build/C/man2/signalfd.2:268
msgid "The I<fd> file descriptor is not a valid file descriptor."
msgstr ""

#.  or, the
#.  .I sizemask
#.  argument is not equal to
#.  .IR sizeof(sigset_t) ;
#. type: Plain text
#: build/C/man2/signalfd.2:276
msgid "I<fd> is not a valid signalfd file descriptor."
msgstr ""

#. type: Plain text
#: build/C/man2/signalfd.2:283 build/C/man2/timerfd_create.2:319
msgid "I<flags> is invalid; or, in Linux 2.6.26 or earlier, I<flags> is nonzero."
msgstr ""

#. type: Plain text
#: build/C/man2/signalfd.2:286 build/C/man2/timerfd_create.2:322
msgid "The per-process limit of open file descriptors has been reached."
msgstr ""

#. type: Plain text
#: build/C/man2/signalfd.2:296
msgid "There was insufficient memory to create a new signalfd file descriptor."
msgstr ""

#.  signalfd() is in glibc 2.7, but reportedly does not build
#. type: Plain text
#: build/C/man2/signalfd.2:304
msgid ""
"B<signalfd>()  is available on Linux since kernel 2.6.22.  Working support "
"is provided in glibc since version 2.8.  The B<signalfd4>()  system call "
"(see NOTES) is available on Linux since kernel 2.6.27."
msgstr ""

#. type: Plain text
#: build/C/man2/signalfd.2:309
msgid "B<signalfd>()  and B<signalfd4>()  are Linux-specific."
msgstr ""

#. type: Plain text
#: build/C/man2/signalfd.2:319
msgid ""
"The underlying Linux system call requires an additional argument, I<size_t "
"sizemask>, which specifies the size of the I<mask> argument.  The glibc "
"B<signalfd>()  wrapper function does not include this argument, since it "
"provides the required value for the underlying system call."
msgstr ""

#. type: Plain text
#: build/C/man2/signalfd.2:333
msgid ""
"A process can create multiple signalfd file descriptors.  This makes it "
"possible to accept different signals on different file descriptors.  (This "
"may be useful if monitoring the file descriptors using B<select>(2), "
"B<poll>(2), or B<epoll>(7): the arrival of different signals will make "
"different descriptors ready.)  If a signal appears in the I<mask> of more "
"than one of the file descriptors, then occurrences of that signal can be "
"read (once) from any one of the descriptors."
msgstr ""

#. type: Plain text
#: build/C/man2/signalfd.2:349
msgid ""
"There are two underlying Linux system calls: B<signalfd>()  and the more "
"recent B<signalfd4>().  The former system call does not implement a I<flags> "
"argument.  The latter system call implements the I<flags> values described "
"above.  Starting with glibc 2.9, the B<signalfd>()  wrapper function will "
"use B<signalfd4>()  where it is available."
msgstr ""

#.  The fix also was put into 2.6.24.5
#. type: Plain text
#: build/C/man2/signalfd.2:357
msgid ""
"In kernels before 2.6.25, the I<ssi_ptr> and I<ssi_int> fields are not "
"filled in with the data accompanying a signal sent by B<sigqueue>(3)."
msgstr ""

#. type: Plain text
#: build/C/man2/signalfd.2:367
msgid ""
"The program below accepts the signals B<SIGINT> and B<SIGQUIT> via a "
"signalfd file descriptor.  The program terminates after accepting a "
"B<SIGQUIT> signal.  The following shell session demonstrates the use of the "
"program:"
msgstr ""

#. type: Plain text
#: build/C/man2/signalfd.2:378
#, no-wrap
msgid ""
"$B< ./signalfd_demo>\n"
"B<^C>                   # Control-C generates SIGINT\n"
"Got SIGINT\n"
"B<^C>\n"
"Got SIGINT\n"
"B<^\\e>                    # Control-\\e generates SIGQUIT\n"
"Got SIGQUIT\n"
"$\n"
msgstr ""

#. type: Plain text
#: build/C/man2/signalfd.2:388
#, no-wrap
msgid ""
"#include E<lt>sys/signalfd.hE<gt>\n"
"#include E<lt>signal.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/signalfd.2:399
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    sigset_t mask;\n"
"    int sfd;\n"
"    struct signalfd_siginfo fdsi;\n"
"    ssize_t s;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/signalfd.2:403
#, no-wrap
msgid ""
"    sigemptyset(&mask);\n"
"    sigaddset(&mask, SIGINT);\n"
"    sigaddset(&mask, SIGQUIT);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/signalfd.2:406
#, no-wrap
msgid ""
"    /* Block signals so that they aren\\(aqt handled\n"
"       according to their default dispositions */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/signalfd.2:409
#, no-wrap
msgid ""
"    if (sigprocmask(SIG_BLOCK, &mask, NULL) == -1)\n"
"        handle_error(\"sigprocmask\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/signalfd.2:413
#, no-wrap
msgid ""
"    sfd = signalfd(-1, &mask, 0);\n"
"    if (sfd == -1)\n"
"        handle_error(\"signalfd\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/signalfd.2:418
#, no-wrap
msgid ""
"    for (;;) {\n"
"        s = read(sfd, &fdsi, sizeof(struct signalfd_siginfo));\n"
"        if (s != sizeof(struct signalfd_siginfo))\n"
"            handle_error(\"read\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/signalfd.2:429
#, no-wrap
msgid ""
"        if (fdsi.ssi_signo == SIGINT) {\n"
"            printf(\"Got SIGINT\\en\");\n"
"        } else if (fdsi.ssi_signo == SIGQUIT) {\n"
"            printf(\"Got SIGQUIT\\en\");\n"
"            exit(EXIT_SUCCESS);\n"
"        } else {\n"
"            printf(\"Read unexpected signal\\en\");\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/signalfd.2:443
msgid ""
"B<eventfd>(2), B<poll>(2), B<read>(2), B<select>(2), B<sigaction>(2), "
"B<sigprocmask>(2), B<sigwaitinfo>(2), B<timerfd_create>(2), B<sigsetops>(3), "
"B<sigwait>(3), B<epoll>(7), B<signal>(7)"
msgstr ""

#. type: TH
#: build/C/man3/sigpause.3:23
#, no-wrap
msgid "SIGPAUSE"
msgstr ""

#. type: TH
#: build/C/man3/sigpause.3:23
#, no-wrap
msgid "2010-09-12"
msgstr ""

#. type: Plain text
#: build/C/man3/sigpause.3:26
msgid "sigpause - atomically release blocked signals and wait for interrupt"
msgstr ""

#. type: Plain text
#: build/C/man3/sigpause.3:31
#, no-wrap
msgid "B<int sigpause(int >I<sigmask>B<);  /* BSD */>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/sigpause.3:33
#, no-wrap
msgid "B<int sigpause(int >I<sig>B<);      /* System V / UNIX 95 */>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/sigpause.3:39
msgid "Don't use this function.  Use B<sigsuspend>(2)  instead."
msgstr ""

#. type: Plain text
#: build/C/man3/sigpause.3:46
msgid ""
"The function B<sigpause>()  is designed to wait for some signal.  It changes "
"the process's signal mask (set of blocked signals), and then waits for a "
"signal to arrive.  Upon arrival of a signal, the original signal mask is "
"restored."
msgstr ""

#. type: Plain text
#: build/C/man3/sigpause.3:54
msgid ""
"If B<sigpause>()  returns, it was interrupted by a signal and the return "
"value is -1 with I<errno> set to B<EINTR>."
msgstr ""

#. type: Plain text
#: build/C/man3/sigpause.3:58
msgid "The System V version of B<sigpause>()  is standardized in POSIX.1-2001."
msgstr ""

#.  __xpg_sigpause: UNIX 95, spec 1170, SVID, SVr4, XPG
#. type: Plain text
#: build/C/man3/sigpause.3:75
msgid ""
"The classical BSD version of this function appeared in 4.2BSD.  It sets the "
"process's signal mask to I<sigmask>.  UNIX 95 standardized the incompatible "
"System V version of this function, which removes only the specified signal "
"I<sig> from the process's signal mask.  The unfortunate situation with two "
"incompatible functions with the same name was solved by the "
"B<\\%sigsuspend>(2)  function, that takes a I<sigset_t *> argument (instead "
"of an I<int>)."
msgstr ""

#. type: Plain text
#: build/C/man3/sigpause.3:78
msgid ""
"On Linux, this routine is a system call only on the Sparc (sparc64)  "
"architecture."
msgstr ""

#. type: Plain text
#: build/C/man3/sigpause.3:80
msgid "Libc4 and libc5 only know about the BSD version."
msgstr ""

#
#.  For the BSD version, one usually uses a zero
#.  .I sigmask
#.  to indicate that no signals are to be blocked.
#. type: Plain text
#: build/C/man3/sigpause.3:96
msgid ""
"Glibc uses the BSD version if the B<_BSD_SOURCE> feature test macro is "
"defined and none of B<_POSIX_SOURCE>, B<_POSIX_C_SOURCE>, B<_XOPEN_SOURCE>, "
"B<_GNU_SOURCE>, or B<_SVID_SOURCE> is defined.  Otherwise, the System V "
"version is used."
msgstr ""

#. type: Plain text
#: build/C/man3/sigpause.3:104
msgid ""
"B<kill>(2), B<sigaction>(2), B<sigprocmask>(2), B<sigsuspend>(2), "
"B<sigblock>(3), B<sigvec>(3), B<feature_test_macros>(7)"
msgstr ""

#. type: TH
#: build/C/man2/sigpending.2:27
#, no-wrap
msgid "SIGPENDING"
msgstr ""

#. type: TH
#: build/C/man2/sigpending.2:27
#, no-wrap
msgid "2008-10-04"
msgstr ""

#. type: Plain text
#: build/C/man2/sigpending.2:30
msgid "sigpending - examine pending signals"
msgstr ""

#. type: Plain text
#: build/C/man2/sigpending.2:34
msgid "B<int sigpending(sigset_t *>I<set>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigpending.2:43
msgid ""
"B<sigpending>(): _POSIX_C_SOURCE\\ E<gt>=\\ 1 || _XOPEN_SOURCE || "
"_POSIX_SOURCE"
msgstr ""

#. type: Plain text
#: build/C/man2/sigpending.2:51
msgid ""
"B<sigpending>()  returns the set of signals that are pending for delivery to "
"the calling thread (i.e., the signals which have been raised while "
"blocked).  The mask of pending signals is returned in I<set>."
msgstr ""

#. type: Plain text
#: build/C/man2/sigpending.2:54
msgid "B<sigpending>()  returns 0 on success and -1 on error."
msgstr ""

#. type: Plain text
#: build/C/man2/sigpending.2:59
msgid ""
"I<set> points to memory which is not a valid part of the process address "
"space."
msgstr ""

#. type: Plain text
#: build/C/man2/sigpending.2:70
msgid ""
"The set of signals that is pending for a thread is the union of the set of "
"signals that is pending for that thread and the set of signals that is "
"pending for the process as a whole; see B<signal>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/sigpending.2:82
msgid ""
"In versions of glibc up to and including 2.2.1, there is a bug in the "
"wrapper function for B<sigpending>()  which means that information about "
"pending real-time signals is not correctly returned."
msgstr ""

#. type: Plain text
#: build/C/man2/sigpending.2:90
msgid ""
"B<kill>(2), B<sigaction>(2), B<signal>(2), B<sigprocmask>(2), "
"B<sigsuspend>(2), B<sigsetops>(3), B<signal>(7)"
msgstr ""

#. type: TH
#: build/C/man2/sigprocmask.2:27
#, no-wrap
msgid "SIGPROCMASK"
msgstr ""

#. type: Plain text
#: build/C/man2/sigprocmask.2:30
msgid "sigprocmask - examine and change blocked signals"
msgstr ""

#. type: Plain text
#: build/C/man2/sigprocmask.2:35
msgid ""
"B<int sigprocmask(int >I<how>B<, const sigset_t *>I<set>B<,> B<sigset_t "
"*>I<oldset>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigprocmask.2:44
msgid ""
"B<sigprocmask>(): _POSIX_C_SOURCE\\ E<gt>=\\ 1 || _XOPEN_SOURCE || "
"_POSIX_SOURCE"
msgstr ""

#. type: Plain text
#: build/C/man2/sigprocmask.2:53
msgid ""
"B<sigprocmask>()  is used to fetch and/or change the signal mask of the "
"calling thread.  The signal mask is the set of signals whose delivery is "
"currently blocked for the caller (see also B<signal>(7)  for more details)."
msgstr ""

#. type: Plain text
#: build/C/man2/sigprocmask.2:57
msgid "The behavior of the call is dependent on the value of I<how>, as follows."
msgstr ""

#. type: TP
#: build/C/man2/sigprocmask.2:57
#, no-wrap
msgid "B<SIG_BLOCK>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigprocmask.2:62
msgid ""
"The set of blocked signals is the union of the current set and the I<set> "
"argument."
msgstr ""

#. type: TP
#: build/C/man2/sigprocmask.2:62
#, no-wrap
msgid "B<SIG_UNBLOCK>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigprocmask.2:68
msgid ""
"The signals in I<set> are removed from the current set of blocked signals.  "
"It is permissible to attempt to unblock a signal which is not blocked."
msgstr ""

#. type: TP
#: build/C/man2/sigprocmask.2:68
#, no-wrap
msgid "B<SIG_SETMASK>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigprocmask.2:72
msgid "The set of blocked signals is set to the argument I<set>."
msgstr ""

#. type: Plain text
#: build/C/man2/sigprocmask.2:77
msgid ""
"If I<oldset> is non-NULL, the previous value of the signal mask is stored in "
"I<oldset>."
msgstr ""

#. type: Plain text
#: build/C/man2/sigprocmask.2:86
msgid ""
"If I<set> is NULL, then the signal mask is unchanged (i.e., I<how> is "
"ignored), but the current value of the signal mask is nevertheless returned "
"in I<oldset> (if it is not NULL)."
msgstr ""

#. type: Plain text
#: build/C/man2/sigprocmask.2:91
msgid ""
"The use of B<sigprocmask>()  is unspecified in a multithreaded process; see "
"B<pthread_sigmask>(3)."
msgstr ""

#. type: Plain text
#: build/C/man2/sigprocmask.2:94
msgid "B<sigprocmask>()  returns 0 on success and -1 on error."
msgstr ""

#. type: Plain text
#: build/C/man2/sigprocmask.2:99
msgid "B<EINVAL> The value specified in I<how> was invalid."
msgstr ""

#. type: Plain text
#: build/C/man2/sigprocmask.2:105
msgid ""
"It is not possible to block B<SIGKILL> or B<SIGSTOP>.  Attempts to do so are "
"silently ignored."
msgstr ""

#. type: Plain text
#: build/C/man2/sigprocmask.2:107
msgid "Each of the threads in a process has its own signal mask."
msgstr ""

#. type: Plain text
#: build/C/man2/sigprocmask.2:127
msgid ""
"If B<SIGBUS>, B<SIGFPE>, B<SIGILL>, or B<SIGSEGV> are generated while they "
"are blocked, the result is undefined, unless the signal was generated by "
"B<kill>(2), B<sigqueue>(3), or B<raise>(3)."
msgstr ""

#. type: Plain text
#: build/C/man2/sigprocmask.2:142
msgid ""
"B<kill>(2), B<pause>(2), B<sigaction>(2), B<signal>(2), B<sigpending>(2), "
"B<sigsuspend>(2), B<pthread_sigmask>(3), B<sigqueue>(3), B<sigsetops>(3), "
"B<signal>(7)"
msgstr ""

#. type: TH
#: build/C/man3/sigqueue.3:26
#, no-wrap
msgid "SIGQUEUE"
msgstr ""

#. type: TH
#: build/C/man3/sigqueue.3:26
#, no-wrap
msgid "2012-03-25"
msgstr ""

#. type: Plain text
#: build/C/man3/sigqueue.3:29
msgid "sigqueue - queue a signal and data to a process"
msgstr ""

#. type: Plain text
#: build/C/man3/sigqueue.3:33
msgid ""
"B<int sigqueue(pid_t >I<pid>B<, int >I<sig>B<, const union sigval "
">I<value>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/sigqueue.3:41
msgid "B<sigqueue>(): _POSIX_C_SOURCE\\ E<gt>=\\ 199309L"
msgstr ""

#. type: Plain text
#: build/C/man3/sigqueue.3:53
msgid ""
"B<sigqueue>()  sends the signal specified in I<sig> to the process whose PID "
"is given in I<pid>.  The permissions required to send a signal are the same "
"as for B<kill>(2).  As with B<kill>(2), the null signal (0) can be used to "
"check if a process with a given PID exists."
msgstr ""

#. type: Plain text
#: build/C/man3/sigqueue.3:58
msgid ""
"The I<value> argument is used to specify an accompanying item of data "
"(either an integer or a pointer value) to be sent with the signal, and has "
"the following type:"
msgstr ""

#. type: Plain text
#: build/C/man3/sigqueue.3:65
#, no-wrap
msgid ""
"union sigval {\n"
"    int   sival_int;\n"
"    void *sival_ptr;\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man3/sigqueue.3:81
msgid ""
"If the receiving process has installed a handler for this signal using the "
"B<SA_SIGINFO> flag to B<sigaction>(2), then it can obtain this data via the "
"I<si_value> field of the I<siginfo_t> structure passed as the second "
"argument to the handler.  Furthermore, the I<si_code> field of that "
"structure will be set to B<SI_QUEUE>."
msgstr ""

#. type: Plain text
#: build/C/man3/sigqueue.3:89
msgid ""
"On success, B<sigqueue>()  returns 0, indicating that the signal was "
"successfully queued to the receiving process.  Otherwise -1 is returned and "
"I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: build/C/man3/sigqueue.3:100
msgid "I<sig> was invalid."
msgstr ""

#. type: Plain text
#: build/C/man3/sigqueue.3:106
msgid ""
"The process does not have permission to send the signal to the receiving "
"process.  For the required permissions, see B<kill>(2)."
msgstr ""

#. type: Plain text
#: build/C/man3/sigqueue.3:110
msgid "No process has a PID matching I<pid>."
msgstr ""

#. type: Plain text
#: build/C/man3/sigqueue.3:112
msgid "This system call first appeared in Linux 2.2."
msgstr ""

#. type: Plain text
#: build/C/man3/sigqueue.3:122
msgid ""
"If this function results in the sending of a signal to the process that "
"invoked it, and that signal was not blocked by the calling thread, and no "
"other threads were willing to handle this signal (either by having it "
"unblocked, or by waiting for it using B<sigwait>(3)), then at least some "
"signal must be delivered to this thread before this function returns."
msgstr ""

#. type: Plain text
#: build/C/man3/sigqueue.3:137
msgid ""
"On Linux, this function is implemented using the B<rt_sigqueueinfo>(2)  "
"system call.  The system call differs in its third argument, which is the "
"I<siginfo_t> structure that will be supplied to the receiving process's "
"signal handler or returned by the receiving process's B<sigtimedwait>(2)  "
"call.  Inside the glibc B<sigqueue>()  wrapper, this argument, I<uinfo>, is "
"initialized as follows:"
msgstr ""

#. type: Plain text
#: build/C/man3/sigqueue.3:145
#, no-wrap
msgid ""
"uinfo.si_signo = sig;      /* argument supplied to sigqueue() */\n"
"uinfo.si_code = SI_QUEUE;\n"
"uinfo.si_pid = getpid();   /* Process ID of sender */\n"
"uinfo.si_uid = getuid();   /* Real UID of sender */\n"
"uinfo.si_value = val;      /* argument supplied to sigqueue() */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/sigqueue.3:155
msgid ""
"B<kill>(2), B<rt_sigqueueinfo>(2), B<sigaction>(2), B<signal>(2), "
"B<pthread_sigqueue>(3), B<sigwait>(3), B<signal>(7)"
msgstr ""

#. type: TH
#: build/C/man2/sigreturn.2:27
#, no-wrap
msgid "SIGRETURN"
msgstr ""

#. type: TH
#: build/C/man2/sigreturn.2:27
#, no-wrap
msgid "2008-06-26"
msgstr ""

#. type: Plain text
#: build/C/man2/sigreturn.2:30
msgid "sigreturn - return from signal handler and cleanup stack frame"
msgstr ""

#. type: Plain text
#: build/C/man2/sigreturn.2:32
msgid "B<int sigreturn(unsigned long >I<__unused>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigreturn.2:40
msgid ""
"When the Linux kernel creates the stack frame for a signal handler, a call "
"to B<sigreturn>()  is inserted into the stack frame so that upon return from "
"the signal handler, B<sigreturn>()  will be called."
msgstr ""

#. type: Plain text
#: build/C/man2/sigreturn.2:51
msgid ""
"This B<sigreturn>()  call undoes everything that was done\\(emchanging the "
"process's signal mask, switching stacks (see B<sigaltstack>(2))\\(emin order "
"to invoke the signal handler: it restores the process's signal mask, "
"switches stacks, and restores the process's context (registers, processor "
"flags), so that the process directly resumes execution at the point where it "
"was interrupted by the signal."
msgstr ""

#. type: Plain text
#: build/C/man2/sigreturn.2:54
msgid "B<sigreturn>()  never returns."
msgstr ""

#. type: SH
#: build/C/man2/sigreturn.2:54
#, no-wrap
msgid "FILES"
msgstr ""

#. type: Plain text
#: build/C/man2/sigreturn.2:56
msgid "/usr/src/linux/arch/i386/kernel/signal.c"
msgstr ""

#. type: Plain text
#: build/C/man2/sigreturn.2:58
msgid "/usr/src/linux/arch/alpha/kernel/entry.S"
msgstr ""

#. type: Plain text
#: build/C/man2/sigreturn.2:62
msgid ""
"B<sigreturn>()  is specific to Linux and should not be used in programs "
"intended to be portable."
msgstr ""

#. type: Plain text
#: build/C/man2/sigreturn.2:72
msgid ""
"The B<sigreturn>()  call is used by the kernel to implement signal "
"handlers.  It should B<never> be called directly.  Better yet, the specific "
"use of the I<__unused> argument varies depending on the architecture."
msgstr ""

#. type: Plain text
#: build/C/man2/sigreturn.2:77
msgid "B<kill>(2), B<sigaltstack>(2), B<signal>(2), B<signal>(7)"
msgstr ""

#. type: TH
#: build/C/man3/sigset.3:24
#, no-wrap
msgid "SIGSET"
msgstr ""

#. type: Plain text
#: build/C/man3/sigset.3:27
msgid "sigset, sighold, sigrelse, sigignore - System V signal API"
msgstr ""

#. type: Plain text
#: build/C/man3/sigset.3:33
msgid "B<sighandler_t sigset(int >I<sig>B<, sighandler_t >I<disp>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/sigset.3:35
msgid "B<int sighold(int >I<sig>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/sigset.3:37
msgid "B<int sigrelse(int >I<sig>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/sigset.3:39
msgid "B<int sigignore(int >I<sig>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/sigset.3:50
msgid "B<sigset>(), B<sighold>(), B<sigrelse>(), B<sigignore>():"
msgstr ""

#. type: Plain text
#: build/C/man3/sigset.3:54
msgid "_XOPEN_SOURCE\\ E<gt>=\\ 500 || _XOPEN_SOURCE\\ &&\\ _XOPEN_SOURCE_EXTENDED"
msgstr ""

#. type: Plain text
#: build/C/man3/sigset.3:63
msgid ""
"These functions are provided in glibc as a compatibility interface for "
"programs that make use of the historical System V signal API.  This API is "
"obsolete: new applications should use the POSIX signal API (B<sigaction>(2), "
"B<sigprocmask>(2), etc.)"
msgstr ""

#. type: Plain text
#: build/C/man3/sigset.3:72
msgid ""
"The B<sigset>()  function modifies the disposition of the signal I<sig>.  "
"The I<disp> argument can be the address of a signal handler function, or one "
"of the following constants:"
msgstr ""

#. type: TP
#: build/C/man3/sigset.3:72
#, no-wrap
msgid "B<SIG_DFL>"
msgstr ""

#. type: Plain text
#: build/C/man3/sigset.3:77
msgid "Reset the disposition of I<sig> to the default."
msgstr ""

#. type: TP
#: build/C/man3/sigset.3:77
#, no-wrap
msgid "B<SIG_IGN>"
msgstr ""

#. type: Plain text
#: build/C/man3/sigset.3:81
msgid "Ignore I<sig>."
msgstr ""

#. type: TP
#: build/C/man3/sigset.3:81
#, no-wrap
msgid "B<SIG_HOLD>"
msgstr ""

#. type: Plain text
#: build/C/man3/sigset.3:88
msgid ""
"Add I<sig> to the process's signal mask, but leave the disposition of I<sig> "
"unchanged."
msgstr ""

#. type: Plain text
#: build/C/man3/sigset.3:94
msgid ""
"If I<disp> specifies the address of a signal handler, then I<sig> is added "
"to the process's signal mask during execution of the handler."
msgstr ""

#. type: Plain text
#: build/C/man3/sigset.3:102
msgid ""
"If I<disp> was specified as a value other than B<SIG_HOLD>, then I<sig> is "
"removed from the process's signal mask."
msgstr ""

#. type: Plain text
#: build/C/man3/sigset.3:108 build/C/man3/sigvec.3:85
msgid "The dispositions for B<SIGKILL> and B<SIGSTOP> cannot be changed."
msgstr ""

#. type: Plain text
#: build/C/man3/sigset.3:114
msgid "The B<sighold>()  function adds I<sig> to the calling process's signal mask."
msgstr ""

#. type: Plain text
#: build/C/man3/sigset.3:120
msgid ""
"The B<sigrelse>()  function removes I<sig> from the calling process's signal "
"mask."
msgstr ""

#. type: Plain text
#: build/C/man3/sigset.3:127
msgid "The B<sigignore>()  function sets the disposition of I<sig> to B<SIG_IGN>."
msgstr ""

#. type: Plain text
#: build/C/man3/sigset.3:143
msgid ""
"On success, B<sigset>()  returns B<SIG_HOLD> if I<sig> was blocked before "
"the call, or the signal's previous disposition if it was not blocked before "
"the call.  On error, B<sigset>()  returns -1, with I<errno> set to indicate "
"the error.  (But see BUGS below.)"
msgstr ""

#. type: Plain text
#: build/C/man3/sigset.3:152
msgid ""
"The B<sighold>(), B<sigrelse>(), and B<sigignore>()  functions return 0 on "
"success; on error, these functions return -1 and set I<errno> to indicate "
"the error."
msgstr ""

#. type: Plain text
#: build/C/man3/sigset.3:159
msgid ""
"For B<sigset>()  see the ERRORS under B<sigaction>(2)  and "
"B<sigprocmask>(2)."
msgstr ""

#. type: Plain text
#: build/C/man3/sigset.3:166
msgid "For B<sighold>()  and B<sigrelse>()  see the ERRORS under B<sigprocmask>(2)."
msgstr ""

#. type: Plain text
#: build/C/man3/sigset.3:171
msgid "For B<sigignore>(), see the errors under B<sigaction>(2)."
msgstr ""

#. type: Plain text
#: build/C/man3/sigset.3:188
msgid ""
"SVr4, POSIX.1-2001.  These functions are obsolete: do not use them in new "
"programs.  POSIX.1-2008 marks B<sighold>(), B<sigignore>(), B<sigpause>(), "
"B<sigrelse>(), and B<sigset>()  as obsolete, recommending the use of "
"B<sigaction>(2), B<sigprocmask>(2), B<pthread_sigmask>(3), and "
"B<sigsuspend>(2)  instead."
msgstr ""

#. type: Plain text
#: build/C/man3/sigset.3:190
msgid "These functions appeared in glibc version 2.1."
msgstr ""

#. type: Plain text
#: build/C/man3/sigset.3:196
msgid ""
"The I<sighandler_t> type is a GNU extension; it is only used on this page to "
"make the B<sigset>()  prototype more easily readable."
msgstr ""

#. type: Plain text
#: build/C/man3/sigset.3:204
msgid ""
"The B<sigset>()  function provides reliable signal handling semantics (as "
"when calling B<sigaction>(2)  with I<sa_mask> equal to 0)."
msgstr ""

#. type: Plain text
#: build/C/man3/sigset.3:222
msgid ""
"On System V, the B<signal>()  function provides unreliable semantics (as "
"when calling B<sigaction>(2)  with I<sa_mask> equal to I<SA_RESETHAND | "
"SA_NODEFER>).  On BSD, B<signal>()  provides reliable semantics.  "
"POSIX.1-2001 leaves these aspects of B<signal>()  unspecified.  See "
"B<signal>(2)  for further details."
msgstr ""

#. type: Plain text
#: build/C/man3/sigset.3:230 build/C/man3/sigvec.3:250
msgid ""
"In order to wait for a signal, BSD and System V both provided a function "
"named B<sigpause>(3), but this function has a different argument on the two "
"systems.  See B<sigpause>(3)  for details."
msgstr ""

#. type: Plain text
#: build/C/man3/sigset.3:239
msgid ""
"In versions of glibc before 2.2, B<sigset>()  did not unblock I<sig> if "
"I<disp> was specified as a value other than B<SIG_HOLD>."
msgstr ""

#.  See http://sourceware.org/bugzilla/show_bug.cgi?id=1951
#. type: Plain text
#: build/C/man3/sigset.3:264
msgid ""
"In versions of glibc before 2.5, B<sigset>()  does not correctly return the "
"previous disposition of the signal in two cases.  First, if I<disp> is "
"specified as B<SIG_HOLD>, then a successful B<sigset>()  always returns "
"B<SIG_HOLD>.  Instead, it should return the previous disposition of the "
"signal (unless the signal was blocked, in which case B<SIG_HOLD> should be "
"returned).  Second, if the signal is currently blocked, then the return "
"value of a successful B<sigset>()  should be B<SIG_HOLD>.  Instead, the "
"previous disposition of the signal is returned.  These problems have been "
"fixed since glibc 2.5."
msgstr ""

#. type: Plain text
#: build/C/man3/sigset.3:274
msgid ""
"B<kill>(2), B<pause>(2), B<sigaction>(2), B<signal>(2), B<sigprocmask>(2), "
"B<raise>(3), B<sigpause>(3), B<sigvec>(3), B<signal>(7)"
msgstr ""

#. type: TH
#: build/C/man3/sigsetops.3:29
#, no-wrap
msgid "SIGSETOPS"
msgstr ""

#. type: TH
#: build/C/man3/sigsetops.3:29
#, no-wrap
msgid "2008-09-01"
msgstr ""

#. type: Plain text
#: build/C/man3/sigsetops.3:33
msgid ""
"sigemptyset, sigfillset, sigaddset, sigdelset, sigismember - POSIX signal "
"set operations."
msgstr ""

#. type: Plain text
#: build/C/man3/sigsetops.3:37
msgid "B<int sigemptyset(sigset_t *>I<set>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/sigsetops.3:39
msgid "B<int sigfillset(sigset_t *>I<set>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/sigsetops.3:41
msgid "B<int sigaddset(sigset_t *>I<set>B<, int >I<signum>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/sigsetops.3:43
msgid "B<int sigdelset(sigset_t *>I<set>B<, int >I<signum>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/sigsetops.3:45
msgid "B<int sigismember(const sigset_t *>I<set>B<, int >I<signum>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/sigsetops.3:57
msgid ""
"B<sigemptyset>(), B<sigfillset>(), B<sigaddset>(), B<sigdelset>(), "
"B<sigismember>():"
msgstr ""

#. type: Plain text
#: build/C/man3/sigsetops.3:59
msgid "_POSIX_C_SOURCE\\ E<gt>=\\ 1 || _XOPEN_SOURCE || _POSIX_SOURCE"
msgstr ""

#. type: Plain text
#: build/C/man3/sigsetops.3:63
msgid "These functions allow the manipulation of POSIX signal sets."
msgstr ""

#. type: Plain text
#: build/C/man3/sigsetops.3:68
msgid ""
"B<sigemptyset>()  initializes the signal set given by I<set> to empty, with "
"all signals excluded from the set."
msgstr ""

#. type: Plain text
#: build/C/man3/sigsetops.3:73
msgid "B<sigfillset>()  initializes I<set> to full, including all signals."
msgstr ""

#. type: Plain text
#: build/C/man3/sigsetops.3:81
msgid ""
"B<sigaddset>()  and B<sigdelset>()  add and delete respectively signal "
"I<signum> from I<set>."
msgstr ""

#. type: Plain text
#: build/C/man3/sigsetops.3:87
msgid "B<sigismember>()  tests whether I<signum> is a member of I<set>."
msgstr ""

#. type: Plain text
#: build/C/man3/sigsetops.3:105
msgid ""
"Objects of type I<sigset_t> must be initialized by a call to either "
"B<sigemptyset>()  or B<sigfillset>()  before being passed to the functions "
"B<sigaddset>(), B<sigdelset>()  and B<sigismember>()  or the additional "
"glibc functions described below (B<sigisemptyset>(), B<sigandset>(), and "
"B<sigorset>()).  The results are undefined if this is not done."
msgstr ""

#. type: Plain text
#: build/C/man3/sigsetops.3:112
msgid ""
"B<sigemptyset>(), B<sigfillset>(), B<sigaddset>(), and B<sigdelset>()  "
"return 0 on success and -1 on error."
msgstr ""

#. type: Plain text
#: build/C/man3/sigsetops.3:121
msgid ""
"B<sigismember>()  returns 1 if I<signum> is a member of I<set>, 0 if "
"I<signum> is not a member, and -1 on error."
msgstr ""

#. type: Plain text
#: build/C/man3/sigsetops.3:126
msgid "I<sig> is not a valid signal."
msgstr ""

#. type: SS
#: build/C/man3/sigsetops.3:129
#, no-wrap
msgid "Glibc Notes"
msgstr ""

#. type: Plain text
#: build/C/man3/sigsetops.3:135
msgid ""
"If the B<_GNU_SOURCE> feature test macro is defined, then "
"I<E<lt>signal.hE<gt>> exposes three other functions for manipulating signal "
"sets."
msgstr ""

#. type: TP
#: build/C/man3/sigsetops.3:135
#, no-wrap
msgid "B<int sigisemptyset(sigset_t *>I<set>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/sigsetops.3:140
msgid "returns 1 if I<set> contains no signals, and 0 otherwise."
msgstr ""

#. type: TP
#: build/C/man3/sigsetops.3:140
#, no-wrap
msgid ""
"B<int sigorset(sigset_t *>I<dest>B<, sigset_t *>I<left>B<, sigset_t "
"*>I<right>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/sigsetops.3:149
msgid "places the union of the sets I<left> and I<right> in I<dest>."
msgstr ""

#. type: TP
#: build/C/man3/sigsetops.3:149
#, no-wrap
msgid ""
"B<int sigandset(sigset_t *>I<dest>B<, sigset_t *>I<left>B<, sigset_t "
"*>I<right>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/sigsetops.3:158
msgid "places the intersection of the sets I<left> and I<right> in I<dest>."
msgstr ""

#. type: Plain text
#: build/C/man3/sigsetops.3:163
msgid "B<sigorset>()  and B<sigandset>()  return 0 on success, and -1 on failure."
msgstr ""

#. type: Plain text
#: build/C/man3/sigsetops.3:166
msgid ""
"These functions are nonstandard (a few other systems provide similar "
"functions) and their use should be avoided in portable applications."
msgstr ""

#. type: Plain text
#: build/C/man3/sigsetops.3:171
msgid "B<sigaction>(2), B<sigpending>(2), B<sigprocmask>(2), B<sigsuspend>(2)"
msgstr ""

#. type: TH
#: build/C/man2/sigsuspend.2:27
#, no-wrap
msgid "SIGSUSPEND"
msgstr ""

#. type: TH
#: build/C/man2/sigsuspend.2:27
#, no-wrap
msgid "2008-08-29"
msgstr ""

#. type: Plain text
#: build/C/man2/sigsuspend.2:30
msgid "sigsuspend - wait for a signal"
msgstr ""

#. type: Plain text
#: build/C/man2/sigsuspend.2:34
msgid "B<int sigsuspend(const sigset_t *>I<mask>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigsuspend.2:43
msgid ""
"B<sigsuspend>(): _POSIX_C_SOURCE\\ E<gt>=\\ 1 || _XOPEN_SOURCE || "
"_POSIX_SOURCE"
msgstr ""

#. type: Plain text
#: build/C/man2/sigsuspend.2:51
msgid ""
"B<sigsuspend>()  temporarily replaces the signal mask of the calling process "
"with the mask given by I<mask> and then suspends the process until delivery "
"of a signal whose action is to invoke a signal handler or to terminate a "
"process."
msgstr ""

#. type: Plain text
#: build/C/man2/sigsuspend.2:60
msgid ""
"If the signal terminates the process, then B<sigsuspend>()  does not "
"return.  If the signal is caught, then B<sigsuspend>()  returns after the "
"signal handler returns, and the signal mask is restored to the state before "
"the call to B<sigsuspend>()."
msgstr ""

#. type: Plain text
#: build/C/man2/sigsuspend.2:68
msgid ""
"It is not possible to block B<SIGKILL> or B<SIGSTOP>; specifying these "
"signals in I<mask>, has no effect on the process's signal mask."
msgstr ""

#. type: Plain text
#: build/C/man2/sigsuspend.2:72
msgid "B<sigsuspend>()  always returns -1, normally with the error B<EINTR>."
msgstr ""

#. type: Plain text
#: build/C/man2/sigsuspend.2:77
msgid ""
"I<mask> points to memory which is not a valid part of the process address "
"space."
msgstr ""

#. type: Plain text
#: build/C/man2/sigsuspend.2:80
msgid "The call was interrupted by a signal."
msgstr ""

#. type: Plain text
#: build/C/man2/sigsuspend.2:100
msgid ""
"Normally, B<sigsuspend>()  is used in conjunction with B<sigprocmask>(2)  in "
"order to prevent delivery of a signal during the execution of a critical "
"code section.  The caller first blocks the signals with B<sigprocmask>(2).  "
"When the critical code has completed, the caller then waits for the signals "
"by calling B<sigsuspend>()  with the signal mask that was returned by "
"B<sigprocmask>(2)  (in the I<oldset> argument)."
msgstr ""

#. type: Plain text
#: build/C/man2/sigsuspend.2:114
msgid ""
"B<kill>(2), B<pause>(2), B<sigaction>(2), B<signal>(2), B<sigprocmask>(2), "
"B<sigwaitinfo>(2), B<sigsetops>(3), B<sigwait>(3), B<signal>(7)"
msgstr ""

#. type: TH
#: build/C/man3/sigvec.3:24
#, no-wrap
msgid "SIGVEC"
msgstr ""

#. type: Plain text
#: build/C/man3/sigvec.3:27
msgid "sigvec, sigblock, sigsetmask, siggetmask, sigmask - BSD signal API"
msgstr ""

#. type: Plain text
#: build/C/man3/sigvec.3:31
msgid ""
"B<int sigvec(int >I<sig>B<, struct sigvec *>I<vec>B<, struct sigvec "
"*>I<ovec>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/sigvec.3:33
msgid "B<int sigmask(int >I<signum>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/sigvec.3:35
msgid "B<int sigblock(int >I<mask>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/sigvec.3:37
msgid "B<int sigsetmask(int >I<mask>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/sigvec.3:39
msgid "B<int siggetmask(void);>"
msgstr ""

#. type: Plain text
#: build/C/man3/sigvec.3:47
msgid "All functions shown above: _BSD_SOURCE"
msgstr ""

#. type: Plain text
#: build/C/man3/sigvec.3:54
msgid ""
"These functions are provided in glibc as a compatibility interface for "
"programs that make use of the historical BSD signal API.  This API is "
"obsolete: new applications should use the POSIX signal API (B<sigaction>(2), "
"B<sigprocmask>(2), etc.)"
msgstr ""

#. type: Plain text
#: build/C/man3/sigvec.3:79
msgid ""
"The B<sigvec>()  function sets and/or gets the disposition of the signal "
"I<sig> (like the POSIX B<sigaction>(2)).  If I<vec> is not NULL, it points "
"to a I<sigvec> structure that defines the new disposition for I<sig>.  If "
"I<ovec> is not NULL, it points to a I<sigvec> structure that is used to "
"return the previous disposition of I<sig>.  To obtain the current "
"disposition of I<sig> without changing it, specify NULL for I<vec>, and a "
"non-NULL pointer for I<ovec>."
msgstr ""

#. type: Plain text
#: build/C/man3/sigvec.3:89
msgid "The I<sigvec> structure has the following form:"
msgstr ""

#. type: Plain text
#: build/C/man3/sigvec.3:97
#, no-wrap
msgid ""
"struct sigvec {\n"
"    void (*sv_handler)();  /* Signal disposition */\n"
"    int    sv_mask;        /* Signals to be blocked in handler */\n"
"    int    sv_flags;       /* Flags */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man3/sigvec.3:108
msgid ""
"The I<sv_handler> field specifies the disposition of the signal, and is "
"either: the address of a signal handler function; or B<SIG_DFL> meaning the "
"default disposition applies for the signal; or B<SIG_IGN> meaning that the "
"signal is ignored."
msgstr ""

#. type: Plain text
#: build/C/man3/sigvec.3:122
msgid ""
"If I<sv_handler> specifies the address of a signal handler, then I<sv_mask> "
"specifies a mask of signals that are to be blocked while the handler is "
"executing.  In addition, the signal for which the handler is invoked is also "
"blocked by default.  Attempts to block B<SIGKILL> or B<SIGSTOP> are silently "
"ignored."
msgstr ""

#. type: Plain text
#: build/C/man3/sigvec.3:129
msgid ""
"If I<sv_handler> specifies the address of a signal handler, then the "
"I<sv_flags> field specifies flags controlling what happens when the handler "
"is called.  This field may contain zero or more of the following flags:"
msgstr ""

#. type: TP
#: build/C/man3/sigvec.3:129
#, no-wrap
msgid "B<SV_INTERRUPT>"
msgstr ""

#. type: Plain text
#: build/C/man3/sigvec.3:137
msgid ""
"If the signal handler interrupts a blocking system call, then upon return "
"from the handler the system call will not be restarted: instead it will fail "
"with the error B<EINTR>.  If this flag is not specified, then system calls "
"are restarted by default."
msgstr ""

#. type: TP
#: build/C/man3/sigvec.3:137
#, no-wrap
msgid "B<SV_RESETHAND>"
msgstr ""

#. type: Plain text
#: build/C/man3/sigvec.3:146
msgid ""
"Reset the disposition of the signal to the default before calling the signal "
"handler.  If this flag is not specified, then the handler remains "
"established until explicitly removed by a later call to B<sigvec>()  or "
"until the process performs an B<execve>(2)."
msgstr ""

#. type: TP
#: build/C/man3/sigvec.3:146
#, no-wrap
msgid "B<SV_ONSTACK>"
msgstr ""

#. type: Plain text
#: build/C/man3/sigvec.3:153
msgid ""
"Handle the signal on the alternate signal stack (historically established "
"under BSD using the obsolete B<sigstack>()  function; the POSIX replacement "
"is B<sigaltstack>(2))."
msgstr ""

#. type: Plain text
#: build/C/man3/sigvec.3:163
msgid ""
"The B<sigmask>()  function constructs and returns a \"signal mask\" for "
"I<signum>.  For example, we can initialize the I<vec.sv_mask> field given to "
"B<sigvec>()  using code such as the following:"
msgstr ""

#. type: Plain text
#: build/C/man3/sigvec.3:168
#, no-wrap
msgid ""
"    vec.sv_mask = sigmask(SIGQUIT) | sigpause(SIGABRT);\n"
"                /* Block SIGQUIT and SIGABRT during\n"
"                   handler execution */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/sigvec.3:183
msgid ""
"The B<sigblock>()  function adds the signals in I<mask> to the process's "
"signal mask (like POSIX I<sigprocmask(SIG_BLOCK)>), and returns the "
"process's previous signal mask.  Attempts to block B<SIGKILL> or B<SIGSTOP> "
"are silently ignored."
msgstr ""

#. type: Plain text
#: build/C/man3/sigvec.3:191
msgid ""
"The B<sigsetmask>()  function sets the process's signal mask to the value "
"given in I<mask> (like POSIX I<sigprocmask(SIG_SETMASK)>), and returns the "
"process's previous signal mask."
msgstr ""

#. type: Plain text
#: build/C/man3/sigvec.3:197
msgid ""
"The B<siggetmask>()  function returns the process's current signal mask.  "
"This call is equivalent to I<sigblock(0)>."
msgstr ""

#. type: Plain text
#: build/C/man3/sigvec.3:203
msgid ""
"The B<sigvec>()  function returns 0 on success; on error, it returns -1 and "
"sets I<errno> to indicate the error."
msgstr ""

#. type: Plain text
#: build/C/man3/sigvec.3:209
msgid ""
"The B<sigblock>()  and B<sigsetmask>()  functions return the previous signal "
"mask."
msgstr ""

#. type: Plain text
#: build/C/man3/sigvec.3:214
msgid "The B<sigmask>()  function returns the signal mask for I<signum>."
msgstr ""

#. type: Plain text
#: build/C/man3/sigvec.3:219
msgid "See the ERRORS under B<sigaction>(2)  and B<sigprocmask>(2)."
msgstr ""

#. type: Plain text
#: build/C/man3/sigvec.3:225
msgid ""
"All of these functions were in 4.3BSD, except B<siggetmask>(), whose origin "
"is unclear.  These functions are obsolete: do not use them in new programs."
msgstr ""

#. type: Plain text
#: build/C/man3/sigvec.3:242
msgid ""
"On 4.3BSD, the B<signal>()  function provided reliable semantics (as when "
"calling B<sigvec>()  with I<vec.sv_mask> equal to 0).  On System V, "
"B<signal>()  provides unreliable semantics.  POSIX.1-2001 leaves these "
"aspects of B<signal>()  unspecified.  See B<signal>(2)  for further details."
msgstr ""

#. type: Plain text
#: build/C/man3/sigvec.3:260
msgid ""
"B<kill>(2), B<pause>(2), B<sigaction>(2), B<signal>(2), B<sigprocmask>(2), "
"B<raise>(3), B<sigpause>(3), B<sigset>(3), B<signal>(7)"
msgstr ""

#. type: TH
#: build/C/man3/sigwait.3:24
#, no-wrap
msgid "SIGWAIT"
msgstr ""

#. type: TH
#: build/C/man3/sigwait.3:24
#, no-wrap
msgid "2010-09-10"
msgstr ""

#. type: Plain text
#: build/C/man3/sigwait.3:27
msgid "sigwait - wait for a signal"
msgstr ""

#. type: Plain text
#: build/C/man3/sigwait.3:32
#, no-wrap
msgid "B< int sigwait(const sigset_t *>I<set>B<, int *>I<sig>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/sigwait.3:42
msgid "B<sigwait>(): _POSIX_C_SOURCE\\ E<gt>=\\ 1 || _XOPEN_SOURCE || _POSIX_SOURCE"
msgstr ""

#. type: Plain text
#: build/C/man3/sigwait.3:53
msgid ""
"The B<sigwait>()  function suspends execution of the calling thread until "
"the delivery of one of the signals specified in the signal set I<set>.  The "
"function accepts the signal (removes it from the pending list of signals), "
"and returns the signal number in I<sig>."
msgstr ""

#. type: Plain text
#: build/C/man3/sigwait.3:59
msgid ""
"The operation of B<sigwait>()  is the same as B<sigwaitinfo>(2), except "
"that:"
msgstr ""

#. type: Plain text
#: build/C/man3/sigwait.3:64
msgid ""
"B<sigwait>()  only returns the signal number, rather than a I<siginfo_t> "
"structure describing the signal."
msgstr ""

#. type: Plain text
#: build/C/man3/sigwait.3:66
msgid "The return values of the two functions are different."
msgstr ""

#. type: Plain text
#: build/C/man3/sigwait.3:71
msgid ""
"On success, B<sigwait>()  returns 0.  On error, it returns a positive error "
"number (listed in ERRORS)."
msgstr ""

#.  Does not occur for glibc.
#. type: Plain text
#: build/C/man3/sigwait.3:77
msgid "I<set> contains an invalid signal number."
msgstr ""

#. type: Plain text
#: build/C/man3/sigwait.3:83
msgid "B<sigwait>()  is implemented using B<sigtimedwait>(2)."
msgstr ""

#. type: Plain text
#: build/C/man3/sigwait.3:86
msgid "See B<pthread_sigmask>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/sigwait.3:94
msgid ""
"B<sigaction>(2), B<signalfd>(2), B<sigpending>(2), B<sigsuspend>(2), "
"B<sigwaitinfo>(2), B<sigsetops>(3), B<signal>(7)"
msgstr ""

#. type: TH
#: build/C/man2/sigwaitinfo.2:23
#, no-wrap
msgid "SIGWAITINFO"
msgstr ""

#. type: TH
#: build/C/man2/sigwaitinfo.2:23
#, no-wrap
msgid "2011-10-03"
msgstr ""

#. type: Plain text
#: build/C/man2/sigwaitinfo.2:26
msgid "sigwaitinfo, sigtimedwait - synchronously wait for queued signals"
msgstr ""

#. type: Plain text
#: build/C/man2/sigwaitinfo.2:31
#, no-wrap
msgid "B<int sigwaitinfo(const sigset_t *>I<set>B<, siginfo_t *>I<info>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sigwaitinfo.2:34
#, no-wrap
msgid ""
"B<int sigtimedwait(const sigset_t *>I<set>B<, siginfo_t *>I<info>B<, >\n"
"B<                 const struct timespec *>I<timeout>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sigwaitinfo.2:44
msgid "B<sigwaitinfo>(), B<sigtimedwait>(): _POSIX_C_SOURCE\\ E<gt>=\\ 199309L"
msgstr ""

#. type: Plain text
#: build/C/man2/sigwaitinfo.2:54
msgid ""
"B<sigwaitinfo>()  suspends execution of the calling thread until one of the "
"signals in I<set> is delivered.  (If one of the signals in I<set> is already "
"pending for the calling thread, B<sigwaitinfo>()  will return immediately "
"with information about that signal.)"
msgstr ""

#. type: Plain text
#: build/C/man2/sigwaitinfo.2:66
msgid ""
"B<sigwaitinfo>()  removes the delivered signal from the set of pending "
"signals and returns the signal number as its function result.  If the "
"I<info> argument is not NULL, then it returns a structure of type "
"I<siginfo_t> (see B<sigaction>(2))  containing information about the signal."
msgstr ""

#. type: Plain text
#: build/C/man2/sigwaitinfo.2:72
msgid ""
"Signals returned via B<sigwaitinfo>()  are delivered in the usual order; see "
"B<signal>(7)  for further details."
msgstr ""

#. type: Plain text
#: build/C/man2/sigwaitinfo.2:81
msgid ""
"B<sigtimedwait>()  operates in exactly the same way as B<sigwaitinfo>()  "
"except that it has an additional argument, I<timeout>, which enables an "
"upper bound to be placed on the time for which the thread is suspended.  "
"This argument is of the following type:"
msgstr ""

#. type: Plain text
#: build/C/man2/sigwaitinfo.2:88
#, no-wrap
msgid ""
"struct timespec {\n"
"    long    tv_sec;         /* seconds */\n"
"    long    tv_nsec;        /* nanoseconds */\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sigwaitinfo.2:98
msgid ""
"If both fields of this structure are specified as 0, a poll is performed: "
"B<sigtimedwait>()  returns immediately, either with information about a "
"signal that was pending for the caller, or with an error if none of the "
"signals in I<set> was pending."
msgstr ""

#. type: Plain text
#: build/C/man2/sigwaitinfo.2:107
msgid ""
"On success, both B<sigwaitinfo>()  and B<sigtimedwait>()  return a signal "
"number (i.e., a value greater than zero).  On failure both calls return -1, "
"with I<errno> set to indicate the error."
msgstr ""

#. type: Plain text
#: build/C/man2/sigwaitinfo.2:116
msgid ""
"No signal in I<set> was delivered within the I<timeout> period specified to "
"B<sigtimedwait>()."
msgstr ""

#. type: Plain text
#: build/C/man2/sigwaitinfo.2:122
msgid ""
"The wait was interrupted by a signal handler; see B<signal>(7).  (This "
"handler was for a signal other than one of those in I<set>.)"
msgstr ""

#. type: Plain text
#: build/C/man2/sigwaitinfo.2:126
msgid "I<timeout> was invalid."
msgstr ""

#. type: Plain text
#: build/C/man2/sigwaitinfo.2:145
msgid ""
"In normal usage, the calling program blocks the signals in I<set> via a "
"prior call to B<sigprocmask>(2)  (so that the default disposition for these "
"signals does not occur if they are delivered between successive calls to "
"B<sigwaitinfo>()  or B<sigtimedwait>())  and does not establish handlers for "
"these signals.  In a multithreaded program, the signal should be blocked in "
"all threads to prevent the signal being delivered to a thread other than the "
"one calling B<sigwaitinfo>()  or B<sigtimedwait>())."
msgstr ""

#. type: Plain text
#: build/C/man2/sigwaitinfo.2:150
msgid ""
"The set of signals that is pending for a given thread is the union of the "
"set of signals that is pending specifically for that thread and the set of "
"signals that is pending for the process as a whole (see B<signal>(7))."
msgstr ""

#. type: Plain text
#: build/C/man2/sigwaitinfo.2:156
msgid "Attempts to wait for B<SIGKILL> and B<SIGSTOP> are silently ignored."
msgstr ""

#. type: Plain text
#: build/C/man2/sigwaitinfo.2:165
msgid ""
"If multiple threads of a process are blocked waiting for the same signal(s) "
"in B<sigwaitinfo>()  or B<sigtimedwait>(), then exactly one of the threads "
"will actually receive the signal if it is delivered to the process as a "
"whole; which of the threads receives the signal is indeterminate."
msgstr ""

#. type: Plain text
#: build/C/man2/sigwaitinfo.2:174
msgid ""
"POSIX leaves the meaning of a NULL value for the I<timeout> argument of "
"B<sigtimedwait>()  unspecified, permitting the possibility that this has the "
"same meaning as a call to B<sigwaitinfo>(), and indeed this is what is done "
"on Linux."
msgstr ""

#. type: Plain text
#: build/C/man2/sigwaitinfo.2:179
msgid ""
"On Linux, B<sigwaitinfo>()  is a library function implemented on top of "
"B<sigtimedwait>()."
msgstr ""

#. type: Plain text
#: build/C/man2/sigwaitinfo.2:191
msgid ""
"B<kill>(2), B<sigaction>(2), B<signal>(2), B<signalfd>(2), B<sigpending>(2), "
"B<sigprocmask>(2), B<sigqueue>(3), B<sigsetops>(3), B<sigwait>(3), "
"B<signal>(7), B<time>(7)"
msgstr ""

#. type: TH
#: build/C/man3/sysv_signal.3:23
#, no-wrap
msgid "SYSV_SIGNAL"
msgstr ""

#. type: TH
#: build/C/man3/sysv_signal.3:23
#, no-wrap
msgid "2007-05-04"
msgstr ""

#. type: Plain text
#: build/C/man3/sysv_signal.3:26
msgid "sysv_signal - signal handling with System V semantics"
msgstr ""

#. type: Plain text
#: build/C/man3/sysv_signal.3:28
msgid "B<#define _GNU_SOURCE> /* See feature_test_macros(7) */"
msgstr ""

#. type: Plain text
#: build/C/man3/sysv_signal.3:34
msgid "B<sighandler_t sysv_signal(int >I<signum>B<, sighandler_t >I<handler>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/sysv_signal.3:39
msgid ""
"The B<sysv_signal>()  function takes the same arguments, and performs the "
"same task, as B<signal>(2)."
msgstr ""

#. type: Plain text
#: build/C/man3/sysv_signal.3:49
msgid ""
"However B<sysv_signal>()  provides the System V unreliable signal semantics, "
"that is: a) the disposition of the signal is reset to the default when the "
"handler is invoked; b) delivery of further instances of the signal is not "
"blocked while the signal handler is executing; and c) if the handler "
"interrupts (certain) blocking system calls, then the system call is not "
"automatically restarted."
msgstr ""

#. type: Plain text
#: build/C/man3/sysv_signal.3:55
msgid ""
"The B<sysv_signal>()  function returns the previous value of the signal "
"handler, or B<SIG_ERR> on error."
msgstr ""

#. type: Plain text
#: build/C/man3/sysv_signal.3:60
msgid "This function is nonstandard."
msgstr ""

#. type: Plain text
#: build/C/man3/sysv_signal.3:66
msgid "Use of B<sysv_signal>()  should be avoided; use B<sigaction>(2)  instead."
msgstr ""

#. type: Plain text
#: build/C/man3/sysv_signal.3:77
msgid ""
"On older Linux systems, B<sysv_signal>()  and B<signal>(2)  were "
"equivalent.  But on newer systems, B<signal>(2)  provides reliable signal "
"semantics; see B<signal>(2)  for details."
msgstr ""

#. type: Plain text
#: build/C/man3/sysv_signal.3:90
msgid "B<sigaction>(2), B<signal>(2), B<bsd_signal>(3), B<signal>(7)"
msgstr ""

#. type: TH
#: build/C/man2/timer_create.2:29
#, no-wrap
msgid "TIMER_CREATE"
msgstr ""

#. type: TH
#: build/C/man2/timer_create.2:29
#, no-wrap
msgid "2010-09-27"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:32
msgid "timer_create - create a POSIX per-process timer"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:36
#, no-wrap
msgid ""
"B<#include E<lt>signal.hE<gt>>\n"
"B<#include E<lt>time.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:39
#, no-wrap
msgid ""
"B<int timer_create(clockid_t >I<clockid>B<, struct sigevent *>I<sevp>B<,>\n"
"B<                 timer_t *>I<timerid>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:42 build/C/man2/timer_delete.2:34 build/C/man2/timer_getoverrun.2:34 build/C/man2/timer_settime.2:38
msgid "Link with I<-lrt>."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:50
msgid "B<timer_create>(): _POSIX_C_SOURCE\\ E<gt>=\\ 199309L"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:58
msgid ""
"B<timer_create>()  creates a new per-process interval timer.  The ID of the "
"new timer is returned in the buffer pointed to by I<timerid>, which must be "
"a non-NULL pointer.  This ID is unique within the process, until the timer "
"is deleted.  The new timer is initially disarmed."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:63
msgid ""
"The I<clockid> argument specifies the clock that the new timer uses to "
"measure time.  It can be specified as one of the following values:"
msgstr ""

#. type: TP
#: build/C/man2/timer_create.2:63
#, no-wrap
msgid "B<CLOCK_REALTIME>"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:66
msgid "A settable system-wide real-time clock."
msgstr ""

#. type: TP
#: build/C/man2/timer_create.2:66
#, no-wrap
msgid "B<CLOCK_MONOTONIC>"
msgstr ""

#.  Note: the CLOCK_MONOTONIC_RAW clock added for clock_gettime()
#.  in 2.6.28 is not supported for POSIX timers -- mtk, Feb 2009
#. type: Plain text
#: build/C/man2/timer_create.2:73
msgid ""
"A nonsettable monotonically increasing clock that measures time from some "
"unspecified point in the past that does not change after system startup."
msgstr ""

#. type: TP
#: build/C/man2/timer_create.2:73
#, no-wrap
msgid "B<CLOCK_PROCESS_CPUTIME_ID> (since Linux 2.6.12)"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:77
msgid ""
"A clock that measures (user and system) CPU time consumed by (all of the "
"threads in) the calling process."
msgstr ""

#. type: TP
#: build/C/man2/timer_create.2:77
#, no-wrap
msgid "B<CLOCK_THREAD_CPUTIME_ID> (since Linux 2.6.12)"
msgstr ""

#.  The CLOCK_MONOTONIC_RAW that was added in 2.6.28 can't be used
#.  to create a timer -- mtk, Feb 2009
#. type: Plain text
#: build/C/man2/timer_create.2:83
msgid ""
"A clock that measures (user and system) CPU time consumed by the calling "
"thread."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:92
msgid ""
"As well as the above values, I<clockid> can be specified as the I<clockid> "
"returned by a call to B<clock_getcpuclockid>(3)  or "
"B<pthread_getcpuclockid>(3)."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:101
msgid ""
"The I<sevp> argument points to a I<sigevent> structure that specifies how "
"the caller should be notified when the timer expires.  For the definition "
"and general details of this structure, see B<sigevent>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:105
msgid "The I<sevp.sigev_notify> field can have the following values:"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:110
msgid ""
"Don't asynchronously notify when the timer expires.  Progress of the timer "
"can be monitored using B<timer_gettime>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:128
msgid ""
"Upon timer expiration, generate the signal I<sigev_signo> for the process.  "
"See B<sigevent>(7)  for general details.  The I<si_code> field of the "
"I<siginfo_t> structure will be set to B<SI_TIMER>.  At any point in time, at "
"most one signal is queued to the process for a given timer; see "
"B<timer_getoverrun>(2)  for more details."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:136
msgid ""
"Upon timer expiration, invoke I<sigev_notify_function> as if it were the "
"start function of a new thread.  See B<sigevent>(7)  for details."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:150
msgid ""
"As for B<SIGEV_SIGNAL>, but the signal is targeted at the thread whose ID is "
"given in I<sigev_notify_thread_id>, which must be a thread in the same "
"process as the caller.  The I<sigev_notify_thread_id> field specifies a "
"kernel thread ID, that is, the value returned by B<clone>(2)  or "
"B<gettid>(2).  This flag is only intended for use by threading libraries."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:165
msgid ""
"Specifying I<sevp> as NULL is equivalent to specifying a pointer to a "
"I<sigevent> structure in which I<sigev_notify> is B<SIGEV_SIGNAL>, "
"I<sigev_signo> is B<SIGALRM>, and I<sigev_value.sival_int> is the timer ID."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:173
msgid ""
"On success, B<timer_create>()  returns 0, and the ID of the new timer is "
"placed in I<*timerid>.  On failure, -1 is returned, and I<errno> is set to "
"indicate the error."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:177
msgid "Temporary error during kernel allocation of timer structures."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:185
msgid ""
"Clock ID, I<sigev_notify>, I<sigev_signo>, or I<sigev_notify_thread_id> is "
"invalid."
msgstr ""

#.  glibc layer: malloc()
#. type: Plain text
#: build/C/man2/timer_create.2:189
msgid "Could not allocate memory."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:191 build/C/man2/timer_delete.2:64 build/C/man2/timer_getoverrun.2:94
msgid "This system call is available since Linux 2.6."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:196
msgid "A program may create multiple interval timers using B<timer_create>()."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:201
msgid ""
"Timers are not inherited by the child of a B<fork>(2), and are disarmed and "
"deleted during an B<execve>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:209
msgid ""
"The kernel preallocates a \"queued real-time signal\" for each timer created "
"using B<timer_create>().  Consequently, the number of timers is limited by "
"the B<RLIMIT_SIGPENDING> resource limit (see B<setrlimit>(2))."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:214
msgid ""
"The timers created by B<timer_create>()  are commonly known as \"POSIX "
"(interval) timers\".  The POSIX timers API consists of the following "
"interfaces:"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:217
msgid "B<timer_create>(): Create a timer."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:220
msgid "B<timer_settime>(2): Arm (start) or disarm (stop) a timer."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:224
msgid ""
"B<timer_gettime>(2): Fetch the time remaining until the next expiration of a "
"timer, along with the interval setting of the timer."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:227
msgid ""
"B<timer_getoverrun>(2): Return the overrun count for the last timer "
"expiration."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:230
msgid "B<timer_delete>(2): Disarm and delete a timer."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:233
msgid ""
"Part of the implementation of the POSIX timers API is provided by glibc.  In "
"particular:"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:237
msgid ""
"The functionality for B<SIGEV_THREAD> is implemented within glibc, rather "
"than the kernel."
msgstr ""

#.  See the glibc source file kernel-posix-timers.h for the structure
#.  that glibc uses to map userspace timer IDs to kernel timer IDs
#.  The kernel-level timer ID is exposed via siginfo.si_tid.
#. type: Plain text
#: build/C/man2/timer_create.2:243
msgid ""
"The timer IDs presented at user level are maintained by glibc, which maps "
"these IDs to the timer IDs employed by the kernel."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:251
msgid ""
"The POSIX timers system calls first appeared in Linux 2.6.  Prior to this, "
"glibc provided an incomplete userspace implementation (B<CLOCK_REALTIME> "
"timers only) using POSIX threads, and current glibc falls back to this "
"implementation on systems running pre-2.6 Linux kernels."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:263
msgid ""
"The program below takes two arguments: a sleep period in seconds, and a "
"timer frequency in nanoseconds.  The program establishes a handler for the "
"signal it uses for the timer, blocks that signal, creates and arms a timer "
"that expires with the given frequency, sleeps for the specified number of "
"seconds, and then unblocks the timer signal.  Assuming that the timer "
"expired at least once while the program slept, the signal handler will be "
"invoked, and the handler displays some information about the timer "
"notification.  The program terminates after one invocation of the signal "
"handler."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:268
msgid ""
"In the following example run, the program sleeps for 1 second, after "
"creating a timer that has a frequency of 100 nanoseconds.  By the time the "
"signal is unblocked and delivered, there have been around ten million "
"overruns."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:280
#, no-wrap
msgid ""
"$ B<./a.out 1 100>\n"
"Establishing handler for signal 34\n"
"Blocking signal 34\n"
"timer ID is 0x804c008\n"
"Sleeping for 1 seconds\n"
"Unblocking signal 34\n"
"Caught signal 34\n"
"    sival_ptr = 0xbfb174f4;     *sival_ptr = 0x804c008\n"
"    overrun count = 10004886\n"
msgstr ""

#. type: SS
#: build/C/man2/timer_create.2:282
#, no-wrap
msgid "Program Source"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:290
#, no-wrap
msgid ""
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>signal.hE<gt>\n"
"#include E<lt>time.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:293
#, no-wrap
msgid ""
"#define CLOCKID CLOCK_REALTIME\n"
"#define SIG SIGRTMIN\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:296
#, no-wrap
msgid ""
"#define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \\e\n"
"                        } while (0)\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:302
#, no-wrap
msgid ""
"static void\n"
"print_siginfo(siginfo_t *si)\n"
"{\n"
"    timer_t *tidp;\n"
"    int or;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:304
#, no-wrap
msgid "    tidp = si-E<gt>si_value.sival_ptr;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:307
#, no-wrap
msgid ""
"    printf(\"    sival_ptr = %p; \", si-E<gt>si_value.sival_ptr);\n"
"    printf(\"    *sival_ptr = 0x%lx\\en\", (long) *tidp);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:314
#, no-wrap
msgid ""
"    or = timer_getoverrun(*tidp);\n"
"    if (or == -1)\n"
"        errExit(\"timer_getoverrun\");\n"
"    else\n"
"        printf(\"    overrun count = %d\\en\", or);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:321
#, no-wrap
msgid ""
"static void\n"
"handler(int sig, siginfo_t *si, void *uc)\n"
"{\n"
"    /* Note: calling printf() from a signal handler is not\n"
"       strictly correct, since printf() is not async-signal-safe;\n"
"       see signal(7) */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:326
#, no-wrap
msgid ""
"    printf(\"Caught signal %d\\en\", sig);\n"
"    print_siginfo(si);\n"
"    signal(sig, SIG_IGN);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:336
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    timer_t timerid;\n"
"    struct sigevent sev;\n"
"    struct itimerspec its;\n"
"    long long freq_nanosecs;\n"
"    sigset_t mask;\n"
"    struct sigaction sa;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:342
#, no-wrap
msgid ""
"    if (argc != 3) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>sleep-secsE<gt> "
"E<lt>freq-nanosecsE<gt>\\en\",\n"
"                argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:344
#, no-wrap
msgid "    /* Establish handler for timer signal */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:351
#, no-wrap
msgid ""
"    printf(\"Establishing handler for signal %d\\en\", SIG);\n"
"    sa.sa_flags = SA_SIGINFO;\n"
"    sa.sa_sigaction = handler;\n"
"    sigemptyset(&sa.sa_mask);\n"
"    if (sigaction(SIG, &sa, NULL) == -1)\n"
"        errExit(\"sigaction\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:353
#, no-wrap
msgid "    /* Block timer signal temporarily */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:359
#, no-wrap
msgid ""
"    printf(\"Blocking signal %d\\en\", SIG);\n"
"    sigemptyset(&mask);\n"
"    sigaddset(&mask, SIG);\n"
"    if (sigprocmask(SIG_SETMASK, &mask, NULL) == -1)\n"
"        errExit(\"sigprocmask\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:361
#, no-wrap
msgid "    /* Create the timer */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:367
#, no-wrap
msgid ""
"    sev.sigev_notify = SIGEV_SIGNAL;\n"
"    sev.sigev_signo = SIG;\n"
"    sev.sigev_value.sival_ptr = &timerid;\n"
"    if (timer_create(CLOCKID, &sev, &timerid) == -1)\n"
"        errExit(\"timer_create\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:369
#, no-wrap
msgid "    printf(\"timer ID is 0x%lx\\en\", (long) timerid);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:371
#, no-wrap
msgid "    /* Start the timer */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:377
#, no-wrap
msgid ""
"    freq_nanosecs = atoll(argv[2]);\n"
"    its.it_value.tv_sec = freq_nanosecs / 1000000000;\n"
"    its.it_value.tv_nsec = freq_nanosecs % 1000000000;\n"
"    its.it_interval.tv_sec = its.it_value.tv_sec;\n"
"    its.it_interval.tv_nsec = its.it_value.tv_nsec;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:380
#, no-wrap
msgid ""
"    if (timer_settime(timerid, 0, &its, NULL) == -1)\n"
"         errExit(\"timer_settime\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:383
#, no-wrap
msgid ""
"    /* Sleep for a while; meanwhile, the timer may expire\n"
"       multiple times */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:386
#, no-wrap
msgid ""
"    printf(\"Sleeping for %d seconds\\en\", atoi(argv[1]));\n"
"    sleep(atoi(argv[1]));\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:389
#, no-wrap
msgid ""
"    /* Unlock the timer signal, so that timer notification\n"
"       can be delivered */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:393
#, no-wrap
msgid ""
"    printf(\"Unblocking signal %d\\en\", SIG);\n"
"    if (sigprocmask(SIG_UNBLOCK, &mask, NULL) == -1)\n"
"        errExit(\"sigprocmask\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:396 build/C/man2/timerfd_create.2:533
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:410
msgid ""
"B<clock_gettime>(2), B<setitimer>(2), B<timer_delete>(2), "
"B<timer_getoverrun>(2), B<timer_settime>(2), B<timerfd_create>(2), "
"B<clock_getcpuclockid>(3), B<pthread_getcpuclockid>(3), B<pthreads>(7), "
"B<sigevent>(7), B<signal>(7), B<time>(7)"
msgstr ""

#. type: TH
#: build/C/man2/timer_delete.2:23
#, no-wrap
msgid "TIMER_DELETE"
msgstr ""

#. type: TH
#: build/C/man2/timer_delete.2:23 build/C/man2/timer_getoverrun.2:23 build/C/man2/timer_settime.2:23
#, no-wrap
msgid "2009-02-20"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_delete.2:26
msgid "timer_delete - delete a POSIX per-process timer"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_delete.2:29 build/C/man2/timer_getoverrun.2:29 build/C/man2/timer_settime.2:30
#, no-wrap
msgid "B<#include E<lt>time.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_delete.2:31
#, no-wrap
msgid "B<int timer_delete(timer_t >I<timerid>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_delete.2:42
msgid "B<timer_delete>(): _POSIX_C_SOURCE\\ E<gt>=\\ 199309L"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_delete.2:50
msgid ""
"B<timer_delete>()  deletes the timer whose ID is given in I<timerid>.  If "
"the timer was armed at the time of this call, it is disarmed before being "
"deleted.  The treatment of any pending signal generated by the deleted timer "
"is unspecified."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_delete.2:57
msgid ""
"On success, B<timer_delete>()  returns 0.  On failure, -1 is returned, and "
"I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_delete.2:62 build/C/man2/timer_getoverrun.2:92
msgid "I<timerid> is not a valid timer ID."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_delete.2:72
msgid ""
"B<clock_gettime>(2), B<timer_create>(2), B<timer_getoverrun>(2), "
"B<timer_settime>(2), B<time>(7)"
msgstr ""

#. type: TH
#: build/C/man2/timer_getoverrun.2:23
#, no-wrap
msgid "TIMER_GETOVERRUN"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_getoverrun.2:26
msgid "timer_getoverrun - get overrun count for a POSIX per-process timer"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_getoverrun.2:31
#, no-wrap
msgid "B<int timer_getoverrun(timer_t >I<timerid>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_getoverrun.2:42
msgid "B<timer_getoverrun>(): _POSIX_C_SOURCE\\ E<gt>=\\ 199309L"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_getoverrun.2:53
msgid ""
"B<timer_getoverrun>()  returns the \"overrun count\" for the timer referred "
"to by I<timerid>.  An application can use the overrun count to accurately "
"calculate the number of timer expirations that would have occurred over a "
"given time interval.  Timer overruns can occur both when receiving "
"expiration notifications via signals (B<SIGEV_SIGNAL>), and via threads "
"(B<SIGEV_THREAD>)."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_getoverrun.2:73
msgid ""
"When expiration notifications are delivered via a signal, overruns can occur "
"as follows.  Regardless of whether or not a real-time signal is used for "
"timer notifications, the system queues at most one signal per timer.  (This "
"is the behavior specified by POSIX.1-2001.  The alternative, queuing one "
"signal for each timer expiration, could easily result in overflowing the "
"allowed limits for queued signals on the system.)  Because of system "
"scheduling delays, or because the signal may be temporarily blocked, there "
"can be a delay between the time when the notification signal is generated "
"and the time when it is delivered (e.g., caught by a signal handler) or "
"accepted (e.g., using B<sigwaitinfo>(2)).  In this interval, further timer "
"expirations may occur.  The timer overrun count is the number of additional "
"timer expirations that occurred between the time when the signal was "
"generated and when it was delivered or accepted."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_getoverrun.2:79
msgid ""
"Timer overruns can also occur when expiration notifications are delivered "
"via invocation of a thread, since there may be an arbitrary delay between an "
"expiration of the timer and the invocation of the notification thread, and "
"in that delay interval, additional timer expirations may occur"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_getoverrun.2:87
msgid ""
"On success, B<timer_getoverrun>()  returns the overrun count of the "
"specified timer; this count may be 0 if no overruns have occurred.  On "
"failure, -1 is returned, and I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_getoverrun.2:108
msgid ""
"When timer notifications are delivered via signals (B<SIGEV_SIGNAL>), on "
"Linux it is also possible to obtain the overrun count via the I<si_overrun> "
"field of the I<siginfo_t> structure (see B<sigaction>(2)).  This allows an "
"application to avoid the overhead of making a system call to obtain the "
"overrun count, but is a nonportable extension to POSIX.1-2001."
msgstr ""

#.  FIXME . Austin bug filed, 11 Feb 09
#. type: Plain text
#: build/C/man2/timer_getoverrun.2:112
msgid ""
"POSIX.1-2001 only discusses timer overruns in the context of timer "
"notifications using signals."
msgstr ""

#.  Bug filed: http://bugzilla.kernel.org/show_bug.cgi?id=12665
#.  http://thread.gmane.org/gmane.linux.kernel/113276/
#. type: Plain text
#: build/C/man2/timer_getoverrun.2:125
msgid ""
"POSIX.1-2001 specifies that if the timer overrun count is equal to or "
"greater than an implementation-defined maximum, B<DELAYTIMER_MAX>, then "
"B<timer_getoverrun>()  should return B<DELAYTIMER_MAX>.  However, Linux does "
"not implement this feature: instead, if the timer overrun value exceeds the "
"maximum representable integer, the counter cycles, starting once more from "
"low values."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_getoverrun.2:128 build/C/man2/timer_settime.2:208
msgid "See B<timer_create>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_getoverrun.2:138
msgid ""
"B<clock_gettime>(2), B<sigaction>(2), B<signalfd>(2), B<sigwaitinfo>(2), "
"B<timer_create>(2), B<timer_delete>(2), B<timer_settime>(2), B<signal>(7), "
"B<time>(7)"
msgstr ""

#. type: TH
#: build/C/man2/timer_settime.2:23
#, no-wrap
msgid "TIMER_SETTIME"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_settime.2:27
msgid ""
"timer_settime, timer_gettime - arm/disarm and fetch state of POSIX "
"per-process timer"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_settime.2:35
#, no-wrap
msgid ""
"B<int timer_settime(timer_t >I<timerid>B<, int >I<flags>B<,>\n"
"B<                  const struct itimerspec *>I<new_value>B<,>\n"
"B<                  struct itimerspec * >I<old_value>B<);>\n"
"B<int timer_gettime(timer_t >I<timerid>B<, struct itimerspec "
"*>I<curr_value>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_settime.2:47
msgid "B<timer_settime>(), B<timer_gettime>(): _POSIX_C_SOURCE\\ E<gt>=\\ 199309L"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_settime.2:60
msgid ""
"B<timer_settime>()  arms or disarms the timer identified by I<timerid>.  The "
"I<new_value> argument is an I<itimerspec> structure that specifies the new "
"initial value and the new interval for the timer.  The I<itimerspec> "
"structure is defined as follows:"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_settime.2:67 build/C/man2/timerfd_create.2:127
#, no-wrap
msgid ""
"struct timespec {\n"
"    time_t tv_sec;                /* Seconds */\n"
"    long   tv_nsec;               /* Nanoseconds */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_settime.2:72
#, no-wrap
msgid ""
"struct itimerspec {\n"
"    struct timespec it_interval;  /* Timer interval */\n"
"    struct timespec it_value;     /* Initial expiration */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_settime.2:84
msgid ""
"Each of the substructures of the I<itimerspec> structure is a I<timespec> "
"structure that allows a time value to be specified in seconds and "
"nanoseconds.  These time values are measured according to the clock that was "
"specified when the timer was created by B<timer_create>(2)"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_settime.2:98
msgid ""
"If I<new_value-E<gt>it_value> specifies a nonzero value (i.e., either "
"subfield is nonzero), then B<timer_settime>()  arms (starts) the timer, "
"setting it to initially expire at the given time.  (If the timer was already "
"armed, then the previous settings are overwritten.)  If "
"I<new_value-E<gt>it_value> specifies a zero value (i.e., both subfields are "
"zero), then the timer is disarmed."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_settime.2:110
msgid ""
"The I<new_value-E<gt>it_interval> field specifies the period of the timer, "
"in seconds and nanoseconds.  If this field is nonzero, then each time that "
"an armed timer expires, the timer is reloaded from the value specified in "
"I<new_value-E<gt>it_interval>.  If I<new_value-E<gt>it_interval> specifies a "
"zero value then the timer expires just once, at the time specified by "
"I<it_value>."
msgstr ""

#.  By experiment: the overrun count is set correctly, for CLOCK_REALTIME.
#. type: Plain text
#: build/C/man2/timer_settime.2:131
msgid ""
"By default, the initial expiration time specified in "
"I<new_value-E<gt>it_value> is interpreted relative to the current time on "
"the timer's clock at the time of the call.  This can be modified by "
"specifying B<TIMER_ABSTIME> in I<flags>, in which case "
"I<new_value-E<gt>it_value> is interpreted as an absolute value as measured "
"on the timer's clock; that is, the timer will expire when the clock value "
"reaches the value specified by I<new_value-E<gt>it_value>.  If the specified "
"absolute time has already passed, then the timer expires immediately, and "
"the overrun count (see B<timer_getoverrun>(2))  will be set correctly."
msgstr ""

#.  Similar remarks might apply with respect to process and thread CPU time
#.  clocks, but these clocks are not currently (2.6.28) settable on Linux.
#. type: Plain text
#: build/C/man2/timer_settime.2:141
msgid ""
"If the value of the B<CLOCK_REALTIME> clock is adjusted while an absolute "
"timer based on that clock is armed, then the expiration of the timer will be "
"appropriately adjusted.  Adjustments to the B<CLOCK_REALTIME> clock have no "
"effect on relative timers based on that clock."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_settime.2:149
msgid ""
"If I<old_value> is not NULL, then it returns the previous interval of the "
"timer (in I<old_value-E<gt>it_interval>)  and the amount of time until the "
"timer would previously have next expired (in I<old_value-E<gt>it_value>)."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_settime.2:169
msgid ""
"B<timer_gettime>()  returns the time until next expiration, and the "
"interval, for the timer specified by I<timerid>, in the buffer pointed to by "
"I<curr_value>.  The time remaining until the next timer expiration is "
"returned in I<curr_value-E<gt>it_value>; this is always a relative value, "
"regardless of whether the B<TIMER_ABSTIME> flag was used when arming the "
"timer.  If the value returned in I<curr_value-E<gt>it_value> is zero, then "
"the timer is currently disarmed.  The timer interval is returned in "
"I<curr_value-E<gt>it_interval>.  If the value returned in "
"I<curr_value-E<gt>it_interval> is zero, then this is a \"one-shot\" timer."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_settime.2:178
msgid ""
"On success, B<timer_settime>()  and B<timer_gettime>()  return 0.  On error, "
"-1 is returned, and I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_settime.2:180
msgid "These functions may fail with the following errors:"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_settime.2:187
msgid "I<new_value>, I<old_value>, or I<curr_value> is not a valid pointer."
msgstr ""

#.  FIXME . eventually: invalid value in flags
#. type: Plain text
#: build/C/man2/timer_settime.2:192
msgid "I<timerid> is invalid."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_settime.2:195
msgid "B<timer_settime>()  may fail with the following errors:"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_settime.2:201
msgid ""
"I<new_value.it_value> is negative; or I<new_value.it_value.tv_nsec> is "
"negative or greater than 999,999,999."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_settime.2:203
msgid "These system calls are available since Linux 2.6."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_settime.2:212
msgid "B<timer_create>(2), B<timer_getoverrun>(2), B<time>(7)"
msgstr ""

#. type: TH
#: build/C/man2/timerfd_create.2:20
#, no-wrap
msgid "TIMERFD_CREATE"
msgstr ""

#. type: TH
#: build/C/man2/timerfd_create.2:20
#, no-wrap
msgid "2011-09-14"
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:24
msgid ""
"timerfd_create, timerfd_settime, timerfd_gettime - timers that notify via "
"file descriptors"
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:27
#, no-wrap
msgid "B<#include E<lt>sys/timerfd.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:29
#, no-wrap
msgid "B<int timerfd_create(int >I<clockid>B<, int >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:33
#, no-wrap
msgid ""
"B<int timerfd_settime(int >I<fd>B<, int >I<flags>B<,>\n"
"B<                    const struct itimerspec *>I<new_value>B<,>\n"
"B<                    struct itimerspec *>I<old_value>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:35
#, no-wrap
msgid "B<int timerfd_gettime(int >I<fd>B<, struct itimerspec *>I<curr_value>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:48
msgid ""
"These system calls create and operate on a timer that delivers timer "
"expiration notifications via a file descriptor.  They provide an alternative "
"to the use of B<setitimer>(2)  or B<timer_create>(2), with the advantage "
"that the file descriptor may be monitored by B<select>(2), B<poll>(2), and "
"B<epoll>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:60
msgid ""
"The use of these three system calls is analogous to the use of "
"B<timer_create>(2), B<timer_settime>(2), and B<timer_gettime>(2).  (There is "
"no analog of B<timer_getoverrun>(2), since that functionality is provided by "
"B<read>(2), as described below.)"
msgstr ""

#. type: SS
#: build/C/man2/timerfd_create.2:60
#, no-wrap
msgid "timerfd_create()"
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:79
msgid ""
"B<timerfd_create>()  creates a new timer object, and returns a file "
"descriptor that refers to that timer.  The I<clockid> argument specifies the "
"clock that is used to mark the progress of the timer, and must be either "
"B<CLOCK_REALTIME> or B<CLOCK_MONOTONIC>.  B<CLOCK_REALTIME> is a settable "
"system-wide clock.  B<CLOCK_MONOTONIC> is a nonsettable clock that is not "
"affected by discontinuous changes in the system clock (e.g., manual changes "
"to system time).  The current value of each of these clocks can be retrieved "
"using B<clock_gettime>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:84
msgid ""
"Starting with Linux 2.6.27, the following values may be bitwise ORed in "
"I<flags> to change the behavior of B<timerfd_create>():"
msgstr ""

#. type: TP
#: build/C/man2/timerfd_create.2:84
#, no-wrap
msgid "B<TFD_NONBLOCK>"
msgstr ""

#. type: TP
#: build/C/man2/timerfd_create.2:92
#, no-wrap
msgid "B<TFD_CLOEXEC>"
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:106
msgid ""
"In Linux versions up to and including 2.6.26, I<flags> must be specified as "
"zero."
msgstr ""

#. type: SS
#: build/C/man2/timerfd_create.2:106
#, no-wrap
msgid "timerfd_settime()"
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:111
msgid ""
"B<timerfd_settime>()  arms (starts) or disarms (stops)  the timer referred "
"to by the file descriptor I<fd>."
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:120
msgid ""
"The I<new_value> argument specifies the initial expiration and interval for "
"the timer.  The I<itimer> structure used for this argument contains two "
"fields, each of which is in turn a structure of type I<timespec>:"
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:132
#, no-wrap
msgid ""
"struct itimerspec {\n"
"    struct timespec it_interval;  /* Interval for periodic timer */\n"
"    struct timespec it_value;     /* Initial expiration */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:144
msgid ""
"I<new_value.it_value> specifies the initial expiration of the timer, in "
"seconds and nanoseconds.  Setting either field of I<new_value.it_value> to a "
"nonzero value arms the timer.  Setting both fields of I<new_value.it_value> "
"to zero disarms the timer."
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:153
msgid ""
"Setting one or both fields of I<new_value.it_interval> to nonzero values "
"specifies the period, in seconds and nanoseconds, for repeated timer "
"expirations after the initial expiration.  If both fields of "
"I<new_value.it_interval> are zero, the timer expires just once, at the time "
"specified by I<new_value.it_value>."
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:169
msgid ""
"The I<flags> argument is either 0, to start a relative timer "
"(I<new_value.it_value> specifies a time relative to the current value of the "
"clock specified by I<clockid>), or B<TFD_TIMER_ABSTIME>, to start an "
"absolute timer (I<new_value.it_value> specifies an absolute time for the "
"clock specified by I<clockid>; that is, the timer will expire when the value "
"of that clock reaches the value specified in I<new_value.it_value>)."
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:180
msgid ""
"If the I<old_value> argument is not NULL, then the I<itimerspec> structure "
"that it points to is used to return the setting of the timer that was "
"current at the time of the call; see the description of B<timerfd_gettime>()  "
"following."
msgstr ""

#. type: SS
#: build/C/man2/timerfd_create.2:180
#, no-wrap
msgid "timerfd_gettime()"
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:189
msgid ""
"B<timerfd_gettime>()  returns, in I<curr_value>, an I<itimerspec> structure "
"that contains the current setting of the timer referred to by the file "
"descriptor I<fd>."
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:199
msgid ""
"The I<it_value> field returns the amount of time until the timer will next "
"expire.  If both fields of this structure are zero, then the timer is "
"currently disarmed.  This field always contains a relative value, regardless "
"of whether the B<TFD_TIMER_ABSTIME> flag was specified when setting the "
"timer."
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:206
msgid ""
"The I<it_interval> field returns the interval of the timer.  If both fields "
"of this structure are zero, then the timer is set to expire just once, at "
"the time specified by I<curr_value.it_value>."
msgstr ""

#. type: SS
#: build/C/man2/timerfd_create.2:206
#, no-wrap
msgid "Operating on a timer file descriptor"
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:210
msgid ""
"The file descriptor returned by B<timerfd_create>()  supports the following "
"operations:"
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:224
msgid ""
"If the timer has already expired one or more times since its settings were "
"last modified using B<timerfd_settime>(), or since the last successful "
"B<read>(2), then the buffer given to B<read>(2)  returns an unsigned 8-byte "
"integer (I<uint64_t>)  containing the number of expirations that have "
"occurred.  (The returned value is in host byte order, i.e., the native byte "
"order for integers on the host machine.)"
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:237
msgid ""
"If no timer expirations have occurred at the time of the B<read>(2), then "
"the call either blocks until the next timer expiration, or fails with the "
"error B<EAGAIN> if the file descriptor has been made nonblocking (via the "
"use of the B<fcntl>(2)  B<F_SETFL> operation to set the B<O_NONBLOCK> flag)."
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:243
msgid ""
"A B<read>(2)  will fail with the error B<EINVAL> if the size of the supplied "
"buffer is less than 8 bytes."
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:254
msgid ""
"The file descriptor is readable (the B<select>(2)  I<readfds> argument; the "
"B<poll>(2)  B<POLLIN> flag)  if one or more timer expirations have occurred."
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:261
msgid ""
"The file descriptor also supports the other file-descriptor multiplexing "
"APIs: B<pselect>(2), B<ppoll>(2), and B<epoll>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:268
msgid ""
"When the file descriptor is no longer required it should be closed.  When "
"all file descriptors associated with the same timer object have been closed, "
"the timer is disarmed and its resources are freed by the kernel."
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:280
msgid ""
"After a B<fork>(2), the child inherits a copy of the file descriptor created "
"by B<timerfd_create>().  The file descriptor refers to the same underlying "
"timer object as the corresponding file descriptor in the parent, and "
"B<read>(2)s in the child will return information about expirations of the "
"timer."
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:286
msgid ""
"A file descriptor created by B<timerfd_create>()  is preserved across "
"B<execve>(2), and continues to generate timer expirations if the timer was "
"armed."
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:293
msgid ""
"On success, B<timerfd_create>()  returns a new file descriptor.  On error, "
"-1 is returned and I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:301
msgid ""
"B<timerfd_settime>()  and B<timerfd_gettime>()  return 0 on success; on "
"error they return -1, and set I<errno> to indicate the error."
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:304
msgid "B<timerfd_create>()  can fail with the following errors:"
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:312
msgid "The I<clockid> argument is neither B<CLOCK_MONOTONIC> nor B<CLOCK_REALTIME>;"
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:332
msgid "There was insufficient kernel memory to create the timer."
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:337
msgid ""
"B<timerfd_settime>()  and B<timerfd_gettime>()  can fail with the following "
"errors:"
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:341
msgid "I<fd> is not a valid file descriptor."
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:352
msgid "I<fd> is not a valid timerfd file descriptor."
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:355
msgid "B<timerfd_settime>()  can also fail with the following errors:"
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:361
msgid ""
"I<new_value> is not properly initialized (one of the I<tv_nsec> falls "
"outside the range zero to 999,999,999)."
msgstr ""

#.  This case only checked since 2.6.29, and 2.2.2[78].some-stable-version.
#.  In older kernel versions, no check was made for invalid flags.
#. type: Plain text
#: build/C/man2/timerfd_create.2:367
msgid "I<flags> is invalid."
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:370
msgid ""
"These system calls are available on Linux since kernel 2.6.25.  Library "
"support is provided by glibc since version 2.8."
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:381
msgid ""
"The following program creates a timer and then monitors its progress.  The "
"program accepts up to three command-line arguments.  The first argument "
"specifies the number of seconds for the initial expiration of the timer.  "
"The second argument specifies the interval for the timer, in seconds.  The "
"third argument specifies the number of times the program should allow the "
"timer to expire before terminating.  The second and third command-line "
"arguments are optional."
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:383 build/C/man2/wait.2:541
msgid "The following shell session demonstrates the use of the program:"
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:398
#, no-wrap
msgid ""
"$B< a.out 3 1 100>\n"
"0.000: timer started\n"
"3.000: read: 1; total=1\n"
"4.000: read: 1; total=2\n"
"B<^Z >                 # type control-Z to suspend the program\n"
"[1]+  Stopped                 ./timerfd3_demo 3 1 100\n"
"$ B<fg>                # Resume execution after a few seconds\n"
"a.out 3 1 100\n"
"9.660: read: 5; total=7\n"
"10.000: read: 1; total=8\n"
"11.000: read: 1; total=9\n"
"B<^C >                 # type control-C to suspend the program\n"
msgstr ""

#.  The commented out code here is what we currently need until
#.  the required stuff is in glibc
#
#
#. /* Link with -lrt */
#. #define _GNU_SOURCE
#. #include <sys/syscall.h>
#. #include <unistd.h>
#. #include <time.h>
#. #if defined(__i386__)
#. #define __NR_timerfd_create 322
#. #define __NR_timerfd_settime 325
#. #define __NR_timerfd_gettime 326
#. #endif
#
#. static int
#. timerfd_create(int clockid, int flags)
#. {
#.     return syscall(__NR_timerfd_create, clockid, flags);
#. }
#
#. static int
#. timerfd_settime(int fd, int flags, struct itimerspec *new_value,
#.         struct itimerspec *curr_value)
#. {
#.     return syscall(__NR_timerfd_settime, fd, flags, new_value,
#.                    curr_value);
#. }
#
#. static int
#. timerfd_gettime(int fd, struct itimerspec *curr_value)
#. {
#.     return syscall(__NR_timerfd_gettime, fd, curr_value);
#. }
#
#. #define TFD_TIMER_ABSTIME (1 << 0)
#
#. ////////////////////////////////////////////////////////////
#. type: Plain text
#: build/C/man2/timerfd_create.2:447
#, no-wrap
msgid ""
"#include E<lt>sys/timerfd.hE<gt>\n"
"#include E<lt>time.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdint.hE<gt>        /* Definition of uint64_t */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:450
#, no-wrap
msgid ""
"#define handle_error(msg) \\e\n"
"        do { perror(msg); exit(EXIT_FAILURE); } while (0)\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:458
#, no-wrap
msgid ""
"static void\n"
"print_elapsed_time(void)\n"
"{\n"
"    static struct timespec start;\n"
"    struct timespec curr;\n"
"    static int first_call = 1;\n"
"    int secs, nsecs;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:464
#, no-wrap
msgid ""
"    if (first_call) {\n"
"        first_call = 0;\n"
"        if (clock_gettime(CLOCK_MONOTONIC, &start) == -1)\n"
"            handle_error(\"clock_gettime\");\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:467
#, no-wrap
msgid ""
"    if (clock_gettime(CLOCK_MONOTONIC, &curr) == -1)\n"
"        handle_error(\"clock_gettime\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:476
#, no-wrap
msgid ""
"    secs = curr.tv_sec - start.tv_sec;\n"
"    nsecs = curr.tv_nsec - start.tv_nsec;\n"
"    if (nsecs E<lt> 0) {\n"
"        secs--;\n"
"        nsecs += 1000000000;\n"
"    }\n"
"    printf(\"%d.%03d: \", secs, (nsecs + 500000) / 1000000);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:485
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct itimerspec new_value;\n"
"    int max_exp, fd;\n"
"    struct timespec now;\n"
"    uint64_t exp, tot_exp;\n"
"    ssize_t s;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:491
#, no-wrap
msgid ""
"    if ((argc != 2) && (argc != 4)) {\n"
"        fprintf(stderr, \"%s init-secs [interval-secs max-exp]\\en\",\n"
"                argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:494
#, no-wrap
msgid ""
"    if (clock_gettime(CLOCK_REALTIME, &now) == -1)\n"
"        handle_error(\"clock_gettime\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:497
#, no-wrap
msgid ""
"    /* Create a CLOCK_REALTIME absolute timer with initial\n"
"       expiration and interval as specified in command line */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:508
#, no-wrap
msgid ""
"    new_value.it_value.tv_sec = now.tv_sec + atoi(argv[1]);\n"
"    new_value.it_value.tv_nsec = now.tv_nsec;\n"
"    if (argc == 2) {\n"
"        new_value.it_interval.tv_sec = 0;\n"
"        max_exp = 1;\n"
"    } else {\n"
"        new_value.it_interval.tv_sec = atoi(argv[2]);\n"
"        max_exp = atoi(argv[3]);\n"
"    }\n"
"    new_value.it_interval.tv_nsec = 0;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:512
#, no-wrap
msgid ""
"    fd = timerfd_create(CLOCK_REALTIME, 0);\n"
"    if (fd == -1)\n"
"        handle_error(\"timerfd_create\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:515
#, no-wrap
msgid ""
"    if (timerfd_settime(fd, TFD_TIMER_ABSTIME, &new_value, NULL) == -1)\n"
"        handle_error(\"timerfd_settime\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:518
#, no-wrap
msgid ""
"    print_elapsed_time();\n"
"    printf(\"timer started\\en\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:523
#, no-wrap
msgid ""
"    for (tot_exp = 0; tot_exp E<lt> max_exp;) {\n"
"        s = read(fd, &exp, sizeof(uint64_t));\n"
"        if (s != sizeof(uint64_t))\n"
"            handle_error(\"read\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:530
#, no-wrap
msgid ""
"        tot_exp += exp;\n"
"        print_elapsed_time();\n"
"        printf(\"read: %llu; total=%llu\\en\",\n"
"                (unsigned long long) exp,\n"
"                (unsigned long long) tot_exp);\n"
"    }\n"
msgstr ""

#.  2.6.29
#. type: Plain text
#: build/C/man2/timerfd_create.2:540
msgid ""
"Currently, B<timerfd_create>()  supports fewer types of clock IDs than "
"B<timer_create>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:552
msgid ""
"B<eventfd>(2), B<poll>(2), B<read>(2), B<select>(2), B<setitimer>(2), "
"B<signalfd>(2), B<timer_create>(2), B<timer_gettime>(2), "
"B<timer_settime>(2), B<epoll>(7), B<time>(7)"
msgstr ""

#. type: TH
#: build/C/man2/tkill.2:29
#, no-wrap
msgid "TKILL"
msgstr ""

#. type: Plain text
#: build/C/man2/tkill.2:32
msgid "tkill, tgkill - send a signal to a thread"
msgstr ""

#. type: Plain text
#: build/C/man2/tkill.2:35
#, no-wrap
msgid "B<int tkill(int >I<tid>B<, int >I<sig>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/tkill.2:37
#, no-wrap
msgid "B<int tgkill(int >I<tgid>B<, int >I<tid>B<, int >I<sig>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/tkill.2:51
msgid ""
"B<tgkill>()  sends the signal I<sig> to the thread with the thread ID I<tid> "
"in the thread group I<tgid>.  (By contrast, B<kill>(2)  can only be used to "
"send a signal to a process (i.e., thread group)  as a whole, and the signal "
"will be delivered to an arbitrary thread within that process.)"
msgstr ""

#. type: Plain text
#: build/C/man2/tkill.2:59
msgid ""
"B<tkill>()  is an obsolete predecessor to B<tgkill>().  It only allows the "
"target thread ID to be specified, which may result in the wrong thread being "
"signaled if a thread terminates and its thread ID is recycled.  Avoid using "
"this system call."
msgstr ""

#. type: Plain text
#: build/C/man2/tkill.2:66
msgid "If I<tgid> is specified as -1, B<tgkill>()  is equivalent to B<tkill>()."
msgstr ""

#. type: Plain text
#: build/C/man2/tkill.2:69
msgid ""
"These are the raw system call interfaces, meant for internal thread library "
"use."
msgstr ""

#. type: Plain text
#: build/C/man2/tkill.2:77
msgid "An invalid thread ID, thread group ID, or signal was specified."
msgstr ""

#. type: Plain text
#: build/C/man2/tkill.2:82
msgid "Permission denied.  For the required permissions, see B<kill>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/tkill.2:85
msgid "No process with the specified thread ID (and thread group ID) exists."
msgstr ""

#. type: Plain text
#: build/C/man2/tkill.2:90
msgid ""
"B<tkill>()  is supported since Linux 2.4.19 / 2.5.4.  B<tgkill>()  was added "
"in Linux 2.5.75."
msgstr ""

#. type: Plain text
#: build/C/man2/tkill.2:96
msgid ""
"B<tkill>()  and B<tgkill>()  are Linux-specific and should not be used in "
"programs that are intended to be portable."
msgstr ""

#. type: Plain text
#: build/C/man2/tkill.2:102
msgid ""
"See the description of B<CLONE_THREAD> in B<clone>(2)  for an explanation of "
"thread groups."
msgstr ""

#. type: Plain text
#: build/C/man2/tkill.2:105
msgid ""
"Glibc does not provide wrappers for these system calls; call them using "
"B<syscall>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/tkill.2:110
msgid "B<clone>(2), B<gettid>(2), B<kill>(2), B<rt_sigqueueinfo>(2)"
msgstr ""

#. type: TH
#: build/C/man2/wait.2:50
#, no-wrap
msgid "WAIT"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:53
msgid "wait, waitpid, waitid - wait for process to change state"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:55
msgid "B<#include E<lt>sys/types.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:57
msgid "B<#include E<lt>sys/wait.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:59
msgid "B<pid_t wait(int *>I<status>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:61
msgid "B<pid_t waitpid(pid_t >I<pid>B<, int *>I<status>B<, int >I<options>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:64
msgid ""
"B<int waitid(idtype_t >I<idtype>B<, id_t >I<id>B<, siginfo_t *>I<infop>B<, "
"int >I<options>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:73
msgid "B<waitid>():"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:77
msgid ""
"_SVID_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 || _XOPEN_SOURCE\\ &&\\ "
"_XOPEN_SOURCE_EXTENDED"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:92
msgid ""
"All of these system calls are used to wait for state changes in a child of "
"the calling process, and obtain information about the child whose state has "
"changed.  A state change is considered to be: the child terminated; the "
"child was stopped by a signal; or the child was resumed by a signal.  In the "
"case of a terminated child, performing a wait allows the system to release "
"the resources associated with the child; if a wait is not performed, then "
"the terminated child remains in a \"zombie\" state (see NOTES below)."
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:104
msgid ""
"If a child has already changed state, then these calls return immediately.  "
"Otherwise they block until either a child changes state or a signal handler "
"interrupts the call (assuming that system calls are not automatically "
"restarted using the B<SA_RESTART> flag of B<sigaction>(2)).  In the "
"remainder of this page, a child whose state has changed and which has not "
"yet been waited upon by one of these system calls is termed I<waitable>."
msgstr ""

#. type: SS
#: build/C/man2/wait.2:104
#, no-wrap
msgid "wait() and waitpid()"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:112
msgid ""
"The B<wait>()  system call suspends execution of the calling process until "
"one of its children terminates.  The call I<wait(&status)> is equivalent to:"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:115
#, no-wrap
msgid "    waitpid(-1, &status, 0);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:129
msgid ""
"The B<waitpid>()  system call suspends execution of the calling process "
"until a child specified by I<pid> argument has changed state.  By default, "
"B<waitpid>()  waits only for terminated children, but this behavior is "
"modifiable via the I<options> argument, as described below."
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:133
msgid "The value of I<pid> can be:"
msgstr ""

#. type: IP
#: build/C/man2/wait.2:133
#, no-wrap
msgid "E<lt> -1"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:137
msgid ""
"meaning wait for any child process whose process group ID is equal to the "
"absolute value of I<pid>."
msgstr ""

#. type: IP
#: build/C/man2/wait.2:137
#, no-wrap
msgid "-1"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:139
msgid "meaning wait for any child process."
msgstr ""

#. type: IP
#: build/C/man2/wait.2:139
#, no-wrap
msgid "0"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:142
msgid ""
"meaning wait for any child process whose process group ID is equal to that "
"of the calling process."
msgstr ""

#. type: IP
#: build/C/man2/wait.2:142
#, no-wrap
msgid "E<gt> 0"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:146
msgid "meaning wait for the child whose process ID is equal to the value of I<pid>."
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:150
msgid "The value of I<options> is an OR of zero or more of the following constants:"
msgstr ""

#. type: TP
#: build/C/man2/wait.2:150 build/C/man2/wait.2:279
#, no-wrap
msgid "B<WNOHANG>"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:153
msgid "return immediately if no child has exited."
msgstr ""

#. type: TP
#: build/C/man2/wait.2:153
#, no-wrap
msgid "B<WUNTRACED>"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:162
msgid ""
"also return if a child has stopped (but not traced via B<ptrace>(2)).  "
"Status for I<traced> children which have stopped is provided even if this "
"option is not specified."
msgstr ""

#. type: TP
#: build/C/man2/wait.2:162
#, no-wrap
msgid "B<WCONTINUED> (since Linux 2.6.10)"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:166
msgid "also return if a stopped child has been resumed by delivery of B<SIGCONT>."
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:168
msgid "(For Linux-only options, see below.)"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:182
msgid ""
"If I<status> is not NULL, B<wait>()  and B<waitpid>()  store status "
"information in the I<int> to which it points.  This integer can be inspected "
"with the following macros (which take the integer itself as an argument, not "
"a pointer to it, as is done in B<wait>()  and B<waitpid>()!):"
msgstr ""

#. type: TP
#: build/C/man2/wait.2:182
#, no-wrap
msgid "B<WIFEXITED(>I<status>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:190
msgid ""
"returns true if the child terminated normally, that is, by calling "
"B<exit>(3)  or B<_exit>(2), or by returning from main()."
msgstr ""

#. type: TP
#: build/C/man2/wait.2:190
#, no-wrap
msgid "B<WEXITSTATUS(>I<status>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:203
msgid ""
"returns the exit status of the child.  This consists of the least "
"significant 8 bits of the I<status> argument that the child specified in a "
"call to B<exit>(3)  or B<_exit>(2)  or as the argument for a return "
"statement in main().  This macro should only be employed if B<WIFEXITED> "
"returned true."
msgstr ""

#. type: TP
#: build/C/man2/wait.2:203
#, no-wrap
msgid "B<WIFSIGNALED(>I<status>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:206
msgid "returns true if the child process was terminated by a signal."
msgstr ""

#. type: TP
#: build/C/man2/wait.2:206
#, no-wrap
msgid "B<WTERMSIG(>I<status>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:213
msgid ""
"returns the number of the signal that caused the child process to "
"terminate.  This macro should only be employed if B<WIFSIGNALED> returned "
"true."
msgstr ""

#. type: TP
#: build/C/man2/wait.2:213
#, no-wrap
msgid "B<WCOREDUMP(>I<status>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:222
msgid ""
"returns true if the child produced a core dump.  This macro should only be "
"employed if B<WIFSIGNALED> returned true.  This macro is not specified in "
"POSIX.1-2001 and is not available on some UNIX implementations (e.g., AIX, "
"SunOS).  Only use this enclosed in #ifdef WCOREDUMP ... #endif."
msgstr ""

#. type: TP
#: build/C/man2/wait.2:222
#, no-wrap
msgid "B<WIFSTOPPED(>I<status>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:229
msgid ""
"returns true if the child process was stopped by delivery of a signal; this "
"is only possible if the call was done using B<WUNTRACED> or when the child "
"is being traced (see B<ptrace>(2))."
msgstr ""

#. type: TP
#: build/C/man2/wait.2:229
#, no-wrap
msgid "B<WSTOPSIG(>I<status>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:235
msgid ""
"returns the number of the signal which caused the child to stop.  This macro "
"should only be employed if B<WIFSTOPPED> returned true."
msgstr ""

#. type: TP
#: build/C/man2/wait.2:235
#, no-wrap
msgid "B<WIFCONTINUED(>I<status>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:240
msgid ""
"(since Linux 2.6.10)  returns true if the child process was resumed by "
"delivery of B<SIGCONT>."
msgstr ""

#. type: SS
#: build/C/man2/wait.2:240
#, no-wrap
msgid "waitid()"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:245
msgid ""
"The B<waitid>()  system call (available since Linux 2.6.9) provides more "
"precise control over which child state changes to wait for."
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:251
msgid ""
"The I<idtype> and I<id> arguments select the child(ren) to wait for, as "
"follows:"
msgstr ""

#. type: IP
#: build/C/man2/wait.2:251
#, no-wrap
msgid "I<idtype> == B<P_PID>"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:254
msgid "Wait for the child whose process ID matches I<id>."
msgstr ""

#. type: IP
#: build/C/man2/wait.2:254
#, no-wrap
msgid "I<idtype> == B<P_PGID>"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:257
msgid "Wait for any child whose process group ID matches I<id>."
msgstr ""

#. type: IP
#: build/C/man2/wait.2:257
#, no-wrap
msgid "I<idtype> == B<P_ALL>"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:261
msgid "Wait for any child; I<id> is ignored."
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:265
msgid ""
"The child state changes to wait for are specified by ORing one or more of "
"the following flags in I<options>:"
msgstr ""

#. type: TP
#: build/C/man2/wait.2:265
#, no-wrap
msgid "B<WEXITED>"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:268
msgid "Wait for children that have terminated."
msgstr ""

#. type: TP
#: build/C/man2/wait.2:268
#, no-wrap
msgid "B<WSTOPPED>"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:271
msgid "Wait for children that have been stopped by delivery of a signal."
msgstr ""

#. type: TP
#: build/C/man2/wait.2:271
#, no-wrap
msgid "B<WCONTINUED>"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:276
msgid ""
"Wait for (previously stopped) children that have been resumed by delivery of "
"B<SIGCONT>."
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:279
msgid "The following flags may additionally be ORed in I<options>:"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:283
msgid "As for B<waitpid>()."
msgstr ""

#. type: TP
#: build/C/man2/wait.2:283
#, no-wrap
msgid "B<WNOWAIT>"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:287
msgid ""
"Leave the child in a waitable state; a later wait call can be used to again "
"retrieve the child status information."
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:294
msgid ""
"Upon successful return, B<waitid>()  fills in the following fields of the "
"I<siginfo_t> structure pointed to by I<infop>:"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:297
msgid "The process ID of the child."
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:301
msgid ""
"The real user ID of the child.  (This field is not set on most other "
"implementations.)"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:305
msgid "Always set to B<SIGCHLD>."
msgstr ""

#. type: TP
#: build/C/man2/wait.2:305
#, no-wrap
msgid "I<si_status>"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:315
msgid ""
"Either the exit status of the child, as given to B<_exit>(2)  (or "
"B<exit>(3)), or the signal that caused the child to terminate, stop, or "
"continue.  The I<si_code> field can be used to determine how to interpret "
"this field."
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:332
msgid ""
"Set to one of: B<CLD_EXITED> (child called B<_exit>(2)); B<CLD_KILLED> "
"(child killed by signal); B<CLD_DUMPED> (child killed by signal, and dumped "
"core); B<CLD_STOPPED> (child stopped by signal); B<CLD_TRAPPED> (traced "
"child has trapped); or B<CLD_CONTINUED> (child continued by B<SIGCONT>)."
msgstr ""

#.  POSIX.1-2001 leaves this possibility unspecified; most
#.  implementations (including Linux) zero out the structure
#.  in this case, but at least one implementation (AIX 5.1)
#.  does not -- MTK Nov 04
#. type: Plain text
#: build/C/man2/wait.2:354
msgid ""
"If B<WNOHANG> was specified in I<options> and there were no children in a "
"waitable state, then B<waitid>()  returns 0 immediately and the state of the "
"I<siginfo_t> structure pointed to by I<infop> is unspecified.  To "
"distinguish this case from that where a child was in a waitable state, zero "
"out the I<si_pid> field before the call and check for a nonzero value in "
"this field after the call returns."
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:358
msgid ""
"B<wait>(): on success, returns the process ID of the terminated child; on "
"error, -1 is returned."
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:367
msgid ""
"B<waitpid>(): on success, returns the process ID of the child whose state "
"has changed; if B<WNOHANG> was specified and one or more child(ren) "
"specified by I<pid> exist, but have not yet changed state, then 0 is "
"returned.  On error, -1 is returned."
msgstr ""

#.  FIXME: As reported by Vegard Nossum, if infop is NULL, then waitid()
#.  returns the PID of the child.  Either this is a bug, or it is intended
#.  behavior that needs to be documented.  See my Jan 2009 LKML mail
#.  "waitid() return value strangeness when infop is NULL".
#. type: Plain text
#: build/C/man2/wait.2:383
msgid ""
"B<waitid>(): returns 0 on success or if B<WNOHANG> was specified and no "
"child(ren) specified by I<id> has yet changed state; on error, -1 is "
"returned.  Each of these calls sets I<errno> to an appropriate value in the "
"case of an error."
msgstr ""

#. type: TP
#: build/C/man2/wait.2:384 build/C/man2/wait.2:389
#, no-wrap
msgid "B<ECHILD>"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:389
msgid ""
"(for B<wait>())  The calling process does not have any unwaited-for "
"children."
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:409
msgid ""
"(for B<waitpid>()  or B<waitid>())  The process specified by I<pid> "
"(B<waitpid>())  or I<idtype> and I<id> (B<waitid>())  does not exist or is "
"not a child of the calling process.  (This can happen for one's own child if "
"the action for B<SIGCHLD> is set to B<SIG_IGN>.  See also the I<Linux Notes> "
"section about threads.)"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:416
msgid ""
"B<WNOHANG> was not set and an unblocked signal or a B<SIGCHLD> was caught; "
"see B<signal>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:421
msgid "The I<options> argument was invalid."
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:436
msgid ""
"A child that terminates, but has not been waited for becomes a \"zombie\".  "
"The kernel maintains a minimal set of information about the zombie process "
"(PID, termination status, resource usage information)  in order to allow the "
"parent to later perform a wait to obtain information about the child.  As "
"long as a zombie is not removed from the system via a wait, it will consume "
"a slot in the kernel process table, and if this table fills, it will not be "
"possible to create further processes.  If a parent process terminates, then "
"its \"zombie\" children (if any)  are adopted by B<init>(8), which "
"automatically performs a wait to remove the zombies."
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:477
msgid ""
"POSIX.1-2001 specifies that if the disposition of B<SIGCHLD> is set to "
"B<SIG_IGN> or the B<SA_NOCLDWAIT> flag is set for B<SIGCHLD> (see "
"B<sigaction>(2)), then children that terminate do not become zombies and a "
"call to B<wait>()  or B<waitpid>()  will block until all children have "
"terminated, and then fail with I<errno> set to B<ECHILD>.  (The original "
"POSIX standard left the behavior of setting B<SIGCHLD> to B<SIG_IGN> "
"unspecified.  Note that even though the default disposition of B<SIGCHLD> is "
"\"ignore\", explicitly setting the disposition to B<SIG_IGN> results in "
"different treatment of zombie process children.)  Linux 2.6 conforms to this "
"specification.  However, Linux 2.4 (and earlier) does not: if a B<wait>()  "
"or B<waitpid>()  call is made while B<SIGCHLD> is being ignored, the call "
"behaves just as though B<SIGCHLD> were not being ignored, that is, the call "
"blocks until the next child terminates and then returns the process ID and "
"status of that child."
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:493
msgid ""
"In the Linux kernel, a kernel-scheduled thread is not a distinct construct "
"from a process.  Instead, a thread is simply a process that is created using "
"the Linux-unique B<clone>(2)  system call; other routines such as the "
"portable B<pthread_create>(3)  call are implemented using B<clone>(2).  "
"Before Linux 2.4, a thread was just a special case of a process, and as a "
"consequence one thread could not wait on the children of another thread, "
"even when the latter belongs to the same thread group.  However, POSIX "
"prescribes such functionality, and since Linux 2.4 a thread can, and by "
"default will, wait on children of other threads in the same thread group."
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:500
msgid ""
"The following Linux-specific I<options> are for use with children created "
"using B<clone>(2); they cannot be used with B<waitid>():"
msgstr ""

#. type: TP
#: build/C/man2/wait.2:500
#, no-wrap
msgid "B<__WCLONE>"
msgstr ""

#.  since 0.99pl10
#. type: Plain text
#: build/C/man2/wait.2:511
msgid ""
"Wait for \"clone\" children only.  If omitted then wait for \"non-clone\" "
"children only.  (A \"clone\" child is one which delivers no signal, or a "
"signal other than B<SIGCHLD> to its parent upon termination.)  This option "
"is ignored if B<__WALL> is also specified."
msgstr ""

#. type: TP
#: build/C/man2/wait.2:511
#, no-wrap
msgid "B<__WALL> (since Linux 2.4)"
msgstr ""

#.  since patch-2.3.48
#. type: Plain text
#: build/C/man2/wait.2:516
msgid "Wait for all children, regardless of type (\"clone\" or \"non-clone\")."
msgstr ""

#. type: TP
#: build/C/man2/wait.2:516
#, no-wrap
msgid "B<__WNOTHREAD> (since Linux 2.4)"
msgstr ""

#.  since patch-2.4.0-test8
#. type: Plain text
#: build/C/man2/wait.2:522
msgid ""
"Do not wait for children of other threads in the same thread group.  This "
"was the default before Linux 2.4."
msgstr ""

#.  fork.2 refers to this example program.
#. type: Plain text
#: build/C/man2/wait.2:539
msgid ""
"The following program demonstrates the use of B<fork>(2)  and B<waitpid>().  "
"The program creates a child process.  If no command-line argument is "
"supplied to the program, then the child suspends its execution using "
"B<pause>(2), to allow the user to send signals to the child.  Otherwise, if "
"a command-line argument is supplied, then the child exits immediately, using "
"the integer supplied on the command line as the exit status.  The parent "
"process executes a loop that monitors the child using B<waitpid>(), and uses "
"the W*() macros described above to analyze the wait status value."
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:555
#, no-wrap
msgid ""
"$B< ./a.out &>\n"
"Child PID is 32360\n"
"[1] 32359\n"
"$B< kill -STOP 32360>\n"
"stopped by signal 19\n"
"$B< kill -CONT 32360>\n"
"continued\n"
"$B< kill -TERM 32360>\n"
"killed by signal 15\n"
"[1]+  Done                    ./a.out\n"
"$\n"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:564
#, no-wrap
msgid ""
"#include E<lt>sys/wait.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:570
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    pid_t cpid, w;\n"
"    int status;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:576
#, no-wrap
msgid ""
"    cpid = fork();\n"
"    if (cpid == -1) {\n"
"        perror(\"fork\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:582
#, no-wrap
msgid ""
"    if (cpid == 0) {            /* Code executed by child */\n"
"        printf(\"Child PID is %ld\\en\", (long) getpid());\n"
"        if (argc == 1)\n"
"            pause();                    /* Wait for signals */\n"
"        _exit(atoi(argv[1]));\n"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:590
#, no-wrap
msgid ""
"    } else {                    /* Code executed by parent */\n"
"        do {\n"
"            w = waitpid(cpid, &status, WUNTRACED | WCONTINUED);\n"
"            if (w == -1) {\n"
"                perror(\"waitpid\");\n"
"                exit(EXIT_FAILURE);\n"
"            }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:604
#, no-wrap
msgid ""
"            if (WIFEXITED(status)) {\n"
"                printf(\"exited, status=%d\\en\", WEXITSTATUS(status));\n"
"            } else if (WIFSIGNALED(status)) {\n"
"                printf(\"killed by signal %d\\en\", WTERMSIG(status));\n"
"            } else if (WIFSTOPPED(status)) {\n"
"                printf(\"stopped by signal %d\\en\", WSTOPSIG(status));\n"
"            } else if (WIFCONTINUED(status)) {\n"
"                printf(\"continued\\en\");\n"
"            }\n"
"        } while (!WIFEXITED(status) && !WIFSIGNALED(status));\n"
"        exit(EXIT_SUCCESS);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:617
msgid ""
"B<_exit>(2), B<clone>(2), B<fork>(2), B<kill>(2), B<ptrace>(2), "
"B<sigaction>(2), B<signal>(2), B<wait4>(2), B<pthread_create>(3), "
"B<credentials>(7), B<signal>(7)"
msgstr ""

#. type: TH
#: build/C/man2/wait4.2:34
#, no-wrap
msgid "WAIT4"
msgstr ""

#. type: Plain text
#: build/C/man2/wait4.2:37
msgid "wait3, wait4 - wait for process to change state, BSD style"
msgstr ""

#. type: Plain text
#: build/C/man2/wait4.2:43
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/time.hE<gt>>\n"
"B<#include E<lt>sys/resource.hE<gt>>\n"
"B<#include E<lt>sys/wait.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/wait4.2:46
#, no-wrap
msgid ""
"B<pid_t wait3(int *>I<status>B<, int >I<options>B<,>\n"
"B<            struct rusage *>I<rusage>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/wait4.2:49
#, no-wrap
msgid ""
"B<pid_t wait4(pid_t >I<pid>B<, int *>I<status>B<, int >I<options>B<,>\n"
"B<            struct rusage *>I<rusage>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/wait4.2:58
msgid "B<wait3>():"
msgstr ""

#. type: Plain text
#: build/C/man2/wait4.2:64
msgid "B<wait4>():"
msgstr ""

#. type: Plain text
#: build/C/man2/wait4.2:66
msgid "_BSD_SOURCE"
msgstr ""

#. type: Plain text
#: build/C/man2/wait4.2:78
msgid ""
"The B<wait3>()  and B<wait4>()  system calls are similar to B<waitpid>(2), "
"but additionally return resource usage information about the child in the "
"structure pointed to by I<rusage>."
msgstr ""

#. type: Plain text
#: build/C/man2/wait4.2:84
msgid ""
"Other than the use of the I<rusage> argument, the following B<wait3>()  "
"call:"
msgstr ""

#. type: Plain text
#: build/C/man2/wait4.2:87
#, no-wrap
msgid "    wait3(status, options, rusage);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/wait4.2:90 build/C/man2/wait4.2:104
msgid "is equivalent to:"
msgstr ""

#. type: Plain text
#: build/C/man2/wait4.2:93
#, no-wrap
msgid "    waitpid(-1, status, options);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/wait4.2:98
msgid "Similarly, the following B<wait4>()  call:"
msgstr ""

#. type: Plain text
#: build/C/man2/wait4.2:101
#, no-wrap
msgid "    wait4(pid, status, options, rusage);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/wait4.2:107
#, no-wrap
msgid "    waitpid(pid, status, options);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/wait4.2:117
msgid ""
"In other words, B<wait3>()  waits of any child, while B<wait4>()  can be "
"used to select a specific child, or children, on which to wait.  See "
"B<wait>(2)  for further details."
msgstr ""

#. type: Plain text
#: build/C/man2/wait4.2:127
msgid ""
"If I<rusage> is not NULL, the I<struct rusage> to which it points will be "
"filled with accounting information about the child.  See B<getrusage>(2)  "
"for details."
msgstr ""

#. type: Plain text
#: build/C/man2/wait4.2:130 build/C/man2/wait4.2:133
msgid "As for B<waitpid>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/wait4.2:135
msgid "4.3BSD."
msgstr ""

#. type: Plain text
#: build/C/man2/wait4.2:147
msgid ""
"Including I<E<lt>sys/time.hE<gt>> is not required these days, but increases "
"portability.  (Indeed, I<E<lt>sys/resource.hE<gt>> defines the I<rusage> "
"structure with fields of type I<struct timeval> defined in "
"I<E<lt>sys/time.hE<gt>>.)"
msgstr ""

#. type: Plain text
#: build/C/man2/wait4.2:153
msgid ""
"On Linux, B<wait3>()  is a library function implemented on top of the "
"B<wait4>()  system call."
msgstr ""

#. type: Plain text
#: build/C/man2/wait4.2:160
msgid ""
"B<fork>(2), B<getrusage>(2), B<sigaction>(2), B<signal>(2), B<wait>(2), "
"B<signal>(7)"
msgstr ""

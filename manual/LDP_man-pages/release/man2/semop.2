.\" Copyright 1993 Giorgio Ciucci (giorgio@crcc.it)
.\"
.\" %%%LICENSE_START(VERBATIM)
.\" Permission is granted to make and distribute verbatim copies of this
.\" manual provided the copyright notice and this permission notice are
.\" preserved on all copies.
.\"
.\" Permission is granted to copy and distribute modified versions of this
.\" manual under the conditions for verbatim copying, provided that the
.\" entire resulting derived work is distributed under the terms of a
.\" permission notice identical to this one.
.\"
.\" Since the Linux kernel and libraries are constantly changing, this
.\" manual page may be incorrect or out-of-date.  The author(s) assume no
.\" responsibility for errors or omissions, or for damages resulting from
.\" the use of the information contained herein.  The author(s) may not
.\" have taken the same level of care in the production of this manual,
.\" which is licensed free of charge, as they might when working
.\" professionally.
.\"
.\" Formatted or processed versions of this manual, if unaccompanied by
.\" the source, must acknowledge the copyright and authors of this work.
.\" %%%LICENSE_END
.\"
.\" Modified 1996-10-22, Eric S. Raymond <esr@thyrsus.com>
.\" Modified 2002-01-08, Michael Kerrisk <mtk.manpages@gmail.com>
.\" Modified 2003-04-28, Ernie Petrides <petrides@redhat.com>
.\" Modified 2004-05-27, Michael Kerrisk <mtk.manpages@gmail.com>
.\" Modified, 11 Nov 2004, Michael Kerrisk <mtk.manpages@gmail.com>
.\"	Language and formatting clean-ups
.\"	Added notes on /proc files
.\" 2005-04-08, mtk, Noted kernel version numbers for semtimedop()
.\" 2007-07-09, mtk, Added an EXAMPLE code segment.
.\"
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.TH SEMOP 2 2012\-08\-27 Linux "Linux Programmer's Manual"
.SH 名前
semop, semtimedop \- セマフォの操作
.SH 書式
.nf
\fB#include <sys/types.h>\fP
\fB#include <sys/ipc.h>\fP
\fB#include <sys/sem.h>\fP
.sp
\fBint semop(int \fP\fIsemid\fP\fB, struct sembuf *\fP\fIsops\fP\fB, unsigned \fP\fInsops\fP\fB);\fP
.sp
\fBint semtimedop(int \fP\fIsemid\fP\fB, struct sembuf *\fP\fIsops\fP\fB, unsigned \fP\fInsops\fP\fB,\fP
\fB               struct timespec *\fP\fItimeout\fP\fB);\fP
.fi
.sp
.in -4n
glibc 向けの機能検査マクロの要件 (\fBfeature_test_macros\fP(7)  参照):
.in
.sp
\fBsemtimedop\fP(): _GNU_SOURCE
.SH 説明
セマフォ集合 (semaphore set) のメンバーの各セマフォは 以下の関連情報を持っている:
.sp
.in +4n
.nf
unsigned short  semval;   /* semaphore value */
unsigned short  semzcnt;  /* # waiting for zero */
unsigned short  semncnt;  /* # waiting for increase */
pid_t           sempid;   /* ID of process that did last op */
.sp
.in -4n
.fi
\fBsemop\fP()  は \fIsemid\fP で指定されたセマフォ集合の選択されたセマフォに対して操作を行う。 \fIsops\fP は \fInsops\fP
個の要素の配列を指し、配列の各要素は個々のセマフォに 対する操作を示す。その型は \fIstruct sembuf\fP で、次のメンバを持つ:
.sp
.in +4n
.nf
unsigned short sem_num;  /* セマフォ番号 */
short          sem_op;   /* セマフォ操作 */
short          sem_flg;  /* 操作フラグ */
.sp
.in -4n
.fi
\fIsem_flg\fP には \fBIPC_NOWAIT\fP と \fBSEM_UNDO\fP が設定できる。 \fBSEM_UNDO\fP
が指定された操作は、そのプロセスが終了した時に自動的に取り消される。
.PP
\fIsops\fP に含まれる操作の集合は、 \fI配列の順序\fP で、 \fIアトミックに\fP 実行される。
すなわち、全ての操作が完全に実行されるか、全く実行されないかの どちらかとなる。 全ての操作が直ちに実行できない場合のこのシステムコールの振る舞いは
個々の操作の \fIsem_flg\fP フィールドに \fBIPC_NOWAIT\fP が存在するかによって決まり、後述のようになる。

それぞれの操作はセマフォ集合の \fIsem_num\fP番目 のセマフォに対して実行される。セマフォ集合の最初のセマフォには 番号 0 が振られる。
そして操作は三種類あり、 \fIsem_op\fP の値で区別される。
.PP
If \fIsem_op\fP is a positive integer, the operation adds this value to the
semaphore value (\fIsemval\fP).  Furthermore, if \fBSEM_UNDO\fP is specified for
this operation, the system updates the undo count (\fIsemadj\fP)  for this
semaphore.  This operation can always proceed\(emit never forces a thread to
wait.  The calling process must have alter permission on the semaphore set.
.PP
If \fIsem_op\fP is zero, the process must have read permission on the semaphore
set.  This is a "wait\-for\-zero" operation: if \fIsemval\fP is zero, the
operation can immediately proceed.  Otherwise, if \fBIPC_NOWAIT\fP is specified
in \fIsem_flg\fP, \fBsemop\fP()  fails with \fIerrno\fP set to \fBEAGAIN\fP (and none of
the operations in \fIsops\fP is performed).  Otherwise \fIsemzcnt\fP (the count of
threads waiting until this semaphore's value becomes zero)  is incremented
by one and the thread sleeps until one of the following occurs:
.IP \(bu 3
\fIsemval\fP が 0 になった: このとき \fIsemzcnt\fP の値は 1 減算される。
.IP \(bu
セマフォ集合が削除された: このとき \fBsemop\fP()  は失敗し、 \fIerrno\fP に \fBEIDRM\fP が設定される。
.IP \(bu
The calling thread catches a signal: the value of \fIsemzcnt\fP is decremented
and \fBsemop\fP()  fails, with \fIerrno\fP set to \fBEINTR\fP.
.IP \(bu
\fBsemtimedop\fP()  の \fItimeout\fP で指定された制限時間が経過した: このとき \fBsemtimedop\fP()  は失敗し、
\fIerrno\fP に \fBEAGAIN\fP が設定される。
.PP
If \fIsem_op\fP is less than zero, the process must have alter permission on
the semaphore set.  If \fIsemval\fP is greater than or equal to the absolute
value of \fIsem_op\fP, the operation can proceed immediately: the absolute
value of \fIsem_op\fP is subtracted from \fIsemval\fP, and, if \fBSEM_UNDO\fP is
specified for this operation, the system updates the undo count (\fIsemadj\fP)
for this semaphore.  If the absolute value of \fIsem_op\fP is greater than
\fIsemval\fP, and \fBIPC_NOWAIT\fP is specified in \fIsem_flg\fP, \fBsemop\fP()  fails,
with \fIerrno\fP set to \fBEAGAIN\fP (and none of the operations in \fIsops\fP is
performed).  Otherwise \fIsemncnt\fP (the counter of threads waiting for this
semaphore's value to increase)  is incremented by one and the thread sleeps
until one of the following occurs:
.IP \(bu 3
\fIsemval\fP becomes greater than or equal to the absolute value of \fIsem_op\fP,
at which time the value of \fIsemncnt\fP is decremented, the absolute value of
\fIsem_op\fP is subtracted from \fIsemval\fP and, if \fBSEM_UNDO\fP is specified for
this operation, the system updates the undo count (\fIsemadj\fP)  for this
semaphore.
.IP \(bu
セマフォ集合がシステムから削除された: このとき \fBsemop\fP()  は失敗し \fIerrno\fP に \fBEIDRM\fP が設定される。
.IP \(bu
The calling thread catches a signal: the value of \fIsemncnt\fP is decremented
and \fBsemop\fP()  fails, with \fIerrno\fP set to \fBEINTR\fP.
.IP \(bu
\fBsemtimedop\fP()  の \fItimeout\fP で指定された制限時間が経過した: このとき \fBsemtimedop\fP()  は失敗し、
\fIerrno\fP に \fBEAGAIN\fP が設定される。
.PP
.\" and
.\" .I sem_ctime
On successful completion, the \fIsempid\fP value for each semaphore specified
in the array pointed to by \fIsops\fP is set to the caller's process ID.  In
addition, the \fIsem_otime\fP is set to the current time.
.PP
\fBsemtimedop\fP()  behaves identically to \fBsemop\fP()  except that in those
cases where the calling thread would sleep, the duration of that sleep is
limited by the amount of elapsed time specified by the \fItimespec\fP structure
whose address is passed in the \fItimeout\fP argument.  (This sleep interval
will be rounded up to the system clock granularity, and kernel scheduling
delays mean that the interval may overrun by a small amount.)  If the
specified time limit has been reached, \fBsemtimedop\fP()  fails with \fIerrno\fP
set to \fBEAGAIN\fP (and none of the operations in \fIsops\fP is performed).  If
the \fItimeout\fP argument is NULL, then \fBsemtimedop\fP()  behaves exactly like
\fBsemop\fP().
.SH 返り値
成功した場合、 \fBsemop\fP()  と \fBsemtimedop\fP()  は 0 を返す。そうでなければ \-1 を返し、 エラーを示す
\fIerrno\fP を設定する。
.SH エラー
失敗した場合、 \fIerrno\fP に以下のどれかが設定される:
.TP 
\fBE2BIG\fP
\fInsops\fP 引き数が \fBSEMOPM\fP より大きい。 \fBSEMOPM\fP は一回のシステムコールで許される操作の最大個数である。
.TP 
\fBEACCES\fP
呼び出し元プロセスには指定されたセマフォ操作を行うのに 必要なアクセス許可がなく、 \fBCAP_IPC_OWNER\fP ケーパビリティもない。
.TP 
\fBEAGAIN\fP
操作を直ちに処理することができず、かつ \fIsem_flg\fP に \fBIPC_NOWAIT\fP が指定されているか \fItimeout\fP
で指定された制限時間が経過した。
.TP 
\fBEFAULT\fP
引き数 \fIsops\fP か \fItimeout\fP が指しているアドレスにアクセスできない。
.TP 
\fBEFBIG\fP
ある操作で、 \fIsem_num\fP の値が 0 未満か、集合内のセマフォの数以上である。
.TP 
\fBEIDRM\fP
セマフォ集合が削除された。
.TP 
\fBEINTR\fP
While blocked in this system call, the thread caught a signal; see
\fBsignal\fP(7).
.TP 
\fBEINVAL\fP
セマフォ集合が存在しないか、 \fIsemid\fP が 0 未満であるか、 \fInsops\fP が正の数でない。
.TP 
\fBENOMEM\fP
ある操作で \fIsem_flg\fP に \fBSEM_UNDO\fP が指定されたが、システムにアンドゥ構造体に割り当てる十分なメモリがない。
.TP 
\fBERANGE\fP
ある操作で \fIsem_op+semval\fP が \fBSEMVMX\fP より大きい。 \fBSEMVMX\fP は \fIsemval\fP
の最大値で、その値は実装依存である。
.SH バージョン
\fBsemtimedop\fP()  は Linux 2.5.52 で初めて登場し、 それからカーネル 2.4.22 にも移植された。
\fBsemtimedop\fP()  の glibc でのサポートはバージョン 2.3.3 で初めて登場した。
.SH 準拠
.\" SVr4 documents additional error conditions EINVAL, EFBIG, ENOSPC.
SVr4, POSIX.1\-2001.
.SH 注意
.\" Like Linux, the FreeBSD man pages still document
.\" the inclusion of these header files.
The inclusion of \fI<sys/types.h>\fP and \fI<sys/ipc.h>\fP isn't
required on Linux or by any version of POSIX.  However, some old
implementations required the inclusion of these header files, and the SVID
also documented their inclusion.  Applications intended to be portable to
such old systems may need to include these header files.

あるプロセスの \fIsem_undo\fP 構造体は \fBfork\fP(2)  で生成された子プロセスには継承されないが、 \fBexecve\fP(2)
システムコールの場合は継承される。
.PP
\fBsemop\fP()  はシグナルハンドラによって中断された後に、 決して自動的に再開することはない。 たとえシグナルハンドラの設定時に
\fBSA_RESTART\fP フラグがセットされていても再開することはない
.PP
\fIsemadj\fP はプロセスごとの整数で、 \fBSEM_UNDO\fP フラグを設定して実行された全てのセマフォ操作の(負数の)カウンタである。
\fBsemctl\fP(2)  に \fBSETVAL\fP または \fBSETALL\fP を指定し、セマフォの値が
直接設定された場合には、全てのプロセスにおいて対応する \fIsemadj\fP の値がクリアされる。
.PP
あるセマフォの \fIsemval\fP, \fIsempid\fP, \fIsemzcnt\fP, \fIsemnct\fP の値はいずれも、適切な操作を指定して
\fBsemctl\fP(2)  を呼び出すことで取得できる。
.PP
セマフォ集合のリソースに関する制限のうち、 \fBsemop\fP()  に影響を及ぼすものを以下に挙げる:
.TP 
\fBSEMOPM\fP
.\" This /proc file is not available in Linux 2.2 and earlier -- MTK
一回の \fBsemop\fP()  で許される操作の最大数 (32)。 (Linux では、この制限値は \fI/proc/sys/kernel/sem\fP
の第3フィールドに対応し、読み出しも変更もできる)。
.TP 
\fBSEMVMX\fP
\fIsemval\fP が取り得る最大値: 実装依存 (32767)。
.PP
以下の値に関しては実装依存の制限はない。 終了時の調整 (adjust on exit) の最大値 (\fBSEMAEM\fP)、
システム全体のアンドゥ構造体の最大数 (\fBSEMMNU\fP)、 プロセスあたりのアンドゥ構造体の最大数。
.SH バグ
プロセスが終了する際、プロセスに対応する \fIsemadj\fP の集合を使って、 \fBSEM_UNDO\fP
フラグ付きで実行された全てのセマフォ操作の影響を取り消す。 これによりある問題が発生する: これらのセマフォの調整を行っていると、 中にはセマフォの値が
0 未満の値にしようとする場合が出てくる。 このような場合、どのように実装するべきか? ひとつの考えられる手法は、全てのセマフォ調整が実行されるまで
停止することである。しかし、この方法ではプロセスの終了が 長時間にわたって停止されることがあるので望ましくない。
しかもどれくらい長時間になるかは分からない。 別の選択肢として、このようなセマフォ調整を完全に無視してしまう方法がある (これはセマフォ操作として
\fBIPC_NOWAIT\fP が指定するのと少し似ている)。 Linux は第三の手法を採用している: セマフォの値を出来るだけ (つまり 0 まで)
減少させて、プロセスの終了を直ちに続行できるようにしている。

.\" The bug report:
.\" http://marc.theaimsgroup.com/?l=linux-kernel&m=110260821123863&w=2
.\" the fix:
.\" http://marc.theaimsgroup.com/?l=linux-kernel&m=110261701025794&w=2
In kernels 2.6.x, x <= 10, there is a bug that in some circumstances
prevents a thread that is waiting for a semaphore value to become zero from
being woken up when the value does actually become zero.  This bug is fixed
in kernel 2.6.11.
.SH 例
以下の部分的なコードは、 セマフォ 0 の値が 0 になるのを待ってから、 セマフォの値を 1 加算する処理を、 \fBsemop\fP()
を使ってアトミック (atomically) に行う。
.nf

    struct sembuf sops[2];
    int semid;

    /* Code to set \fIsemid\fP omitted */

    sops[0].sem_num = 0;        /* Operate on semaphore 0 */
    sops[0].sem_op = 0;         /* Wait for value to equal 0 */
    sops[0].sem_flg = 0;

    sops[1].sem_num = 0;        /* Operate on semaphore 0 */
    sops[1].sem_op = 1;         /* Increment value by one */
    sops[1].sem_flg = 0;

    if (semop(semid, sops, 2) == \-1) {
        perror("semop");
        exit(EXIT_FAILURE);
    }
.fi
.SH 関連項目
\fBclone\fP(2), \fBsemctl\fP(2), \fBsemget\fP(2), \fBsigaction\fP(2),
\fBcapabilities\fP(7), \fBsem_overview\fP(7), \fBsvipc\fP(7), \fBtime\fP(7)
.SH この文書について
この man ページは Linux \fIman\-pages\fP プロジェクトのリリース 3.50 の一部
である。プロジェクトの説明とバグ報告に関する情報は
http://www.kernel.org/doc/man\-pages/ に書かれている。

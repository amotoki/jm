.\"
.\" Japanese Version Copyright (c) 1998 Hidefumi Yab 
.\"         all rights reserved.
.\" Translated Sat Jun 12 13:47:08 JST 1999
.\"         by Hidefumi Yab (yabide@da2.so-net.ne.jp)
.\" Updated Tue Jul  8 JST 2003 by Kentaro Shirakata <argrath@ub32.org>
.\"
.TH EXPECT 1 "29 December 1994"

.\"O .SH NAME
.SH 名前
.\"O expect \- programmed dialogue with interactive programs, Version 5
expect \- 対話的なプログラムとのやりとりを自動化するプログラム, バージョン 5


.\"O .SH SYNOPSIS
.SH 書式

.B expect
[
.B \-dDinN
]
[
.B \-c
.I cmds
]
[
.BR \- [ f | b ]
]
.I cmdfile
]
[
.I args
]

.\"O .SH INTRODUCTION
.SH イントロダクション
.\"O .B Expect
.\"O is a program that "talks" to other interactive programs according to a
.\"O script.  Following the script,
.\"O .B Expect
.\"O knows what can be expected from
.\"O a program and what the correct response should be.  An interpreted
.\"O language provides branching and high-level control structures to
.\"O direct the dialogue.  In addition, the user can take control
.\"O and interact directly when desired, afterward returning control to the
.\"O script.
.B Expect
は、スクリプトの指示に従って、対話的なプログラムと"会話"するプログラムである。
以下のスクリプトに示すように、
.B Expect
には、対話プログラムからの期待されうる入力とそれに対する正しい応答を
教えておく。インタプリタは分岐処理と高度な制御構造を提供し、
対話プログラムへの指示を行なう。
さらに、必要な時にスクリプトから制御を奪って直接人間が指示を行ない、
その後、制御をスクリプトへ戻すことができる。

.PP
.\"O .B Expectk
.\"O is a mixture of
.\"O .B Expect
.\"O and
.\"O .BR Tk .
.\"O It behaves just like
.\"O .B Expect
.\"O and
.\"O .BR Tk 's
.\"O .BR wish .
.\"O .B Expect
.\"O can also be used directly in C or C++ (that is, without Tcl).
.\"O See libexpect(3).
.B Expectk
は
.B Expect
と
.BR Tk
の混合物である。
.B Expect
であり、かつ、
.BR Tk 's
.BR wish
であるかのように振舞う。
.B Expect
は、C あるいは C++ (つまり、Tcl 以外)から、直接使うこともできる。
libexpect(3)を参照。
.PP
.\"O The name "Expect" comes from the idea of
.\"O .I send/expect
.\"O sequences popularized
.\"O by uucp, kermit and other modem control programs.
.\"O However unlike uucp,
.\"O .B Expect
.\"O is generalized so that it can be run as a user-level command
.\"O with any program and task in mind.
.\"O .B Expect
.\"O can actually talk to several programs at the same time.
"Expect"という名前は、uucpで有名になった
.I send/expect
の概念に由来する。
(kermitや他のモデム制御プログラムでも、この概念は使われている)
しかし、uucp とは違って
.B Expect
は一般化されているので、想像されるどんなプログラムやタスクに対しても
マクロコマンド(user-level command)として機能できる。
.B Expect
は、同時に複数のプログラムと会話することができる。
.PP
.\"O For example, here are some things
.\"O .B Expect
.\"O can do:
.\"O .RS
.\"O .TP 4
.\"O \(bu
.\"O Cause your computer to dial you back,
.\"O so that you can login without paying for the call.
.\"O .TP
.\"O \(bu
.\"O Start a game (e.g., rogue) and if the optimal configuration doesn't appear,
.\"O restart it (again and again) until it does,
.\"O then hand over control to you.
.\"O .TP
.\"O \(bu
.\"O Run fsck, and in response to its questions, answer "yes", "no" or give control back to you,
.\"O based on predetermined criteria.
.\"O .TP
.\"O \(bu
.\"O Connect to another network or BBS (e.g., MCI Mail, CompuServe) and
.\"O automatically retrieve your mail so that it appears as if
.\"O it was originally sent to your local system.
.\"O .TP
.\"O \(bu
.\"O Carry environment variables, current directory,
.\"O or any kind of information across rlogin, telnet, tip, su, chgrp, etc.
.\"O .RE
.B Expect
にできることの例をいくつか挙げておく:
.RS
.TP 4
\(bu
電話代を払わずにログインできるようにコンピュータからあなたに電話を掛け直させる。
.TP
\(bu
ゲーム(例えば rogue)を始める時に、最適なパラメタがもらえなかった場合
最適なパラメタがもらえるまで何度でもリスタートを行ない、その後制御を人間に移す。
.TP
\(bu
fsckを走らせた時に現れる質問に、前もって決めておいた方針に従って、
"yes", "no", "手入力"を切替えて、返答する。
.TP
\(bu
他のネットワークや BBS(例えばMCI Mail, CompuServe)に接続した時に
自動的にメールの取り込み、発信を行なう。
.TP
\(bu
環境変数、カレントディレクトリ、その他の情報を、rlogin, telnet, tip, su, \
 chgrp などを行なった先へ持っていく。
.RE
.PP
.\"O There are a variety of reasons why the shell cannot perform these tasks.
.\"O (Try, you'll see.)
.\"O All are possible with
.\"O .BR Expect .
これらの処理をシェルが行なえない理由はたくさんある
(やってみればわかるだろう)。全部
.BR Expect
ならできる。
.PP
.\"O In general,
.\"O .B Expect
.\"O is useful for running any program which requires
.\"O interaction between the program and the user.
.\"O All that is necessary is that the interaction can be characterized
.\"O programmatically.
.\"O .B Expect
.\"O can also give the user back control
.\"O (without halting the program being controlled) if desired.
.\"O Similarly, the user can return control to the script at any time.
一般に
.B Expect
は、プログラムとユーザーのやりとりが必要なプログラムを走らせるときに
役に立つ。大事なことは、このやりとりがプログラムの性格を持っていると
いうことである。
.B Expect
は、必要ならユーザーに制御を返すこともできる(しかも、プログラムは
中断されない)。同様に、ユーザーは制御をいつでもスクリプトに返すことができる。

.\"O .SH USAGE
.SH 用法
.\"O .B Expect
.\"O reads
.\"O .I cmdfile
.\"O for a list of commands to execute.
.\"O .B Expect
.\"O may also be invoked implicitly on systems which support the #! notation
.\"O by marking the script executable, and making the first line in your script:
.\"O 
.\"O     #!/usr/local/bin/expect \-f
.\"O 
.\"O Of course, the path must accurately describe where
.\"O .B Expect
.\"O lives.  /usr/local/bin is just an example.
.\"O 
.\"O The
.\"O .B \-c
.\"O flag prefaces a command to be executed before any in the script.
.\"O The command should be quoted to prevent being broken up by the shell.
.\"O This option may be used multiple times.
.\"O Multiple commands may be
.\"O executed with a single
.\"O .B \-c
.\"O by separating them with semicolons.
.\"O Commands are executed in the order they appear.  
.\"O (When using Expectk, this option is specified as
.\"O .BR \-command .)
.\"O
.B Expect
は、
.I cmdfile
を読み込み、実行するコマンドのリストを得る。
.B Expect
は、#! 表記をサポートする OS で、先頭行に

    #!/usr/local/bin/expect \-f

と書いておいて実行させることもできる。
もちろん、パスは正確に
.B Expect
のある場所を指示していなければならない。
/usr/local/bin は、一例である。

.B \-c
フラグで、スクリプトを実行する前に、実行するコマンドを指示する。
コマンドはシェルに壊されないようにクオートしておくべきである。
このオプションは何回出てきても構わない。
複数コマンドを指示した場合は、セミコロンで連結されたコマンドのように
扱われる。
コマンドは現れた順に実行される。(Expectk では、
.BR \-command
と書く)
.PP
.\"O The
.\"O .B \-d
.\"O flag enables some diagnostic output, which
.\"O primarily reports internal activity of commands such as 
.\"O .B expect
.\"O and
.\"O .BR interact .
.\"O This flag has the same effect as "exp_internal 1" at the beginning of an Expect
.\"O script, plus the version of
.\"O .B Expect
.\"O is printed.
.\"O (The
.\"O .B strace
.\"O command is useful for tracing statements, and the
.\"O .B trace
.\"O command is useful for tracing variable assignments.)
.\"O (When using Expectk, this option is specified as
.\"O .BR \-diag .)
.B \-d
フラグで、デバッグ情報出力を有効にする。基本的に
内部のコマンド(例えば
.B expect
や
.BR interact )
の振舞いを報告する。
このフラグは"exp_internal 1"とスクリプトの先頭に書くのと同じことだが、
さらに
.B Expect
のバージョン番号も出力される。
(
.B strace
コマンドは、命令をトレースするのに便利である。
.B trace
コマンドは、変数値をトレースするのに便利である。)
(Expectk を使う時は、このオプションは
.BR \-diag
と書く。)
.PP
.\"O The
.\"O .B \-D
.\"O flag enables an interactive debugger.  An integer value should follow.
.\"O The debugger will take control before the next Tcl procedure
.\"O if the value is non-zero
.\"O or if a ^C is pressed (or a breakpoint is hit, or other appropriate debugger
.\"O command appears in the script).  See the README file or SEE ALSO (below)
.\"O for more information on the debugger.
.\"O (When using Expectk, this option is specified as
.\"O .BR \-Debug .)
.B \-D
フラグで対話型デバッガを有効にする。整数値が続かなければならない。
値が 0 でないか、C が押されると、次の Tcl 処理の前でデバッガに制御が移る。
ブレークポイントにかかった時や他のデバッグ命令を実行した時も、同じである。
デバッガについての情報がもっと欲しければ、 README や下記の関連項目を読むこと。
(Expectk を使っている時は、このオプションは
.BR \-Debug )
.PP
.\"O The
.\"O .B \-f
.\"O flag prefaces a file from which to read commands from.
.\"O The flag itself is optional as it is only useful when using
.\"O the #! notation (see above),
.\"O so that other arguments may be supplied on the command line.
.\"O (When using Expectk, this option is specified as
.\"O .BR \-file .)
.B \-f
フラグで、コマンドを読んでくるファイルを指示する。このフラグは
あってもなくても良いのだが、#! 表記と一緒に使うと
引数からプログラム名を除けるから、その場合意味がある。
(Expectk では
.BR \-file )
.PP
.\"O By default, the command file is read into memory and executed in its entirety.
.\"O It is occasionally desirable to read files one line at a time.  For example,
.\"O stdin is read this way.  In order to force arbitrary files to be handled this
.\"O way, use the
.\"O .B \-b
.\"O flag.
.\"O (When using Expectk, this option is specified as
.\"O .BR \-buffer .)  Note that stdio-buffering may still take place however this shouldn't cause problems when reading from a fifo or stdin.
デフォルトでは、コマンドファイルがメモリに一度に読み込まれ、そこで実行される。
一行ずつコマンドファイルを読んだ方が望ましい場合もある。例えば、
標準入力はこのように扱った方が良い。強制的にこのモードを指定するには、
.B \-b
フラグを指定する。
(Expectkでは、
.BR \-buffer )
stdio のバッファリングは依然有効であるが、FIFO または stdin から読み込む場合は
問題は起こらないはずであることに注意すること。
.PP
.\"O If the string "\-" is supplied as a filename, standard input is read instead.
.\"O (Use "./\-" to read from a file actually named "\-".)
"\-"がファイル名として渡されると、標準入力からスクリプトが読み込まれる。
(本当に"\-"と言うファイルが読みたければ、"./\-"と書くこと)
.PP
.\"O The
.\"O .B \-i
.\"O flag causes
.\"O .B Expect
.\"O to interactively prompt for commands instead of reading
.\"O them from a file.
.\"O Prompting is terminated via the
.\"O .B exit
.\"O command or upon EOF.
.\"O See
.\"O .B interpreter
.\"O (below) for more information.
.\"O .B \-i
.\"O is assumed if neither a command file nor
.\"O .B \-c
.\"O is used.
.\"O (When using Expectk, this option is specified as
.\"O .BR \-interactive .)
.B \-i
フラグを指示すると、
.B Expect
はファイルからスクリプトを読まずに対話用プロンプトを表示する。
.B exit
コマンドか、EOF を受けるとシェルを終了する。
詳細については
.B interpreter
(下記) を参照のこと。
.B \-i
を指定した場合には、
コマンドファイルも
.B \-c
も指示されなかったものとして実行される。
(Expectkでは
.BR \-interactive )
.PP
.\"O .B \-\-
.\"O may be used to delimit the end of the options.  This is useful if
.\"O you want to pass an option-like argument to your script without it being
.\"O interpreted by
.\"O .BR Expect .
.\"O This can usefully be placed in the #! line to prevent any flag-like
.\"O interpretation by Expect.  For example, the following will leave the
.\"O original arguments (including the script name) in the variable
.\"O .IR argv .
.\"O 
.\"O     #!/usr/local/bin/expect \-\-
.\"O 
.\"O Note that the usual getopt(3) and execve(2) conventions must be observed
.\"O when adding arguments to the #! line.
.B \-\-
は、オプションの終りを区切るのに用いられる(省略可能)。これは、あなたが
オプションタイプの引数を
.BR Expect
に解釈させないで、スクリプトにそのまま渡したい時に役に立つ。
#! 行にこれを置いて、Expect にオプションとして解釈させないようにするこ
とができて便利た。

例えば、以下のように書くと(スクリプト名も含めて)オリジナルの引数は、変数
.IR argv
に残される。

    #!/usr/local/bin/expect \-\-

#!行に引数を加えると、通常の getopt(3) や execve(2) ではその引数が見えてしまう
ことに注意すること。
.PP
.\"O The file $exp_library/expect.rc is sourced automatically if present, unless
.\"O the
.\"O .B \-N
.\"O flag is used.  
.\"O (When using Expectk, this option is specified as
.\"O .BR \-NORC .)
.\"O Immediately after this,
.\"O the file ~/.expect.rc is sourced automatically, unless the
.\"O .B \-n
.\"O flag is used.  If the environment variable DOTDIR is defined,
.\"O it is treated as a directory and .expect.rc is read from there.
.\"O (When using Expectk, this option is specified as
.\"O .BR \-norc .)
.\"O This sourcing occurs only after executing any
.\"O .B \-c
.\"O flags.
.B \-N
フラグを用いない限り、ファイル $exp_library/expect.rc が(あれば)自動的に
実行される。
(Expectk では、
.BR \-NORC )
.B \-n
フラグ
(Expectk では、
.BR \-norc )
を用いない限り、
続いて、ファイル ~/.expect.rc が、自動的に実行される。
環境変数 DOTDIR が定義されていれば、そこが .expect.rc のあるディレクトリ
として扱われる。

この二つのrcファイルの実行より先に
.B \-c
フラグで指示されたコマンドが実行される。
.PP
.\"O .B \-v
.\"O causes Expect to print its version number and exit.  (The corresponding flag
.\"O in Expectk, which uses long flag names, is \-version.)
.B \-v
フラグを指示すると、バージョン番号を表示して終了する。
(Expectkでは、\-version)
.PP
.\"O Optional
.\"O .I args
.\"O are constructed into a list and stored in the variable named
.\"O .IR argv .
.\"O .I argc
.\"O is initialized to the length of argv.
オプション
.I args
は、リストに変換されて、変数
.IR argv
に保存される。
.I argc
は、argv のリスト長(要素の数)に設定される。
.PP
.\"O .I argv0
.\"O is defined to be the name of the script (or binary if no script is used).
.\"O For example,
.\"O the following prints out the name of the script and the first three arguments:
.I argv0
は、スクリプト名に設定される(スクリプトを使っていなければ、
バイナリの名前になる)。
例えば、以下のスクリプトを実行すると、スクリプト名と最初の引数3つを表示する:
.nf

    send_user "$argv0 [lrange $argv 0 2]\\n"

.fi
.\"O .SH COMMANDS
.SH コマンド
.\"O .B Expect
.\"O uses
.\"O .I Tcl
.\"O (Tool Command Language).
.\"O Tcl provides control flow (e.g., if, for, break),
.\"O expression evaluation and several other features such as recursion,
.\"O procedure definition, etc.
.\"O Commands used here but not defined (e.g.,
.\"O .BR set ,
.\"O .BR if ,
.\"O .BR exec )
.\"O are Tcl commands (see tcl(3)).
.\"O .B Expect
.\"O supports additional commands, described below.
.\"O Unless otherwise specified, commands return the empty string.
.\"O
.B Expect
は、
.I Tcl
(Tool Command Language)を使用している。
Tcl は、制御フロー(例えば if, for, break)、式評価、および、
再帰やプロシジャ定義等他のいくつかの機能を提供する。
ここで使われているのに定義がないコマンド(例えば、
.BR set ,
.BR if ,
.BR exec )
は、Tcl コマンドである。(tcl(3)を参照)。
.B Expect
は、以下に記述する追加コマンドをサポートする。
記述がない場合は、そのコマンドは空文字列を返す。
.PP
.\"O Commands are listed alphabetically so that they can be quickly located.
.\"O However, new users may find it easier to start by reading the descriptions
.\"O of
.\"O .BR spawn ,
.\"O .BR send ,
.\"O .BR expect ,
.\"O and
.\"O .BR interact ,
.\"O in that order.
.\"O 
.\"O Note that the best introduction to the language (both Expect and Tcl)
.\"O is provided in the book "Exploring Expect" (see SEE ALSO below).
.\"O Examples are included in this man page but they are very limited since
.\"O this man page is meant primarily as reference material.
.\"O 
.\"O Note that in the text of this man page, "Expect" with an uppercase "E"
.\"O refers to the
.\"O .B Expect
.\"O program while "expect" with a lower-case "e" refers to the
.\"O .B expect
.\"O command within the
.\"O .B Expect
.\"O program.)
コマンドはアルファベットの列なのですぐにわかると思うが、
新しいユーザーは、
.BR spawn ,
.BR send ,
.BR expect ,
.BR interact ,
が、この順で並んでいるところを読み始めた方が理解しやすいと
気がつくかも知れない。

この言語(Expect と Tcl の両方)へのイントロダクションとしては、
"Exploring Expect"という本(関連項目を参照)がベストである。
このマニュアルページはリファレンスとして書いているので、
含まれている例は非常に限られている。注意すること。

このマニュアルページで、大文字の"E"で"Expect"とあれば、それは、
.B Expect
プログラムを指し、一方小文字の"e"で"expect"とあれば、それは、
.B Expect
プログラムに実装されている
.B expect
コマンドを指す。注意すること。
.I
.TP 6
.BI close " [-slave] [\-onexec 0|1] [\-i spawn_id]"
.\"O closes the connection to the current process.
.\"O Most interactive programs will detect EOF on their stdin and exit;
.\"O thus
.\"O .B close
.\"O usually suffices to kill the process as well.
.\"O The
.\"O .B \-i
.\"O flag declares the process to close corresponding to the named spawn_id.
.\"O 
.\"O Both
.\"O .B expect
.\"O and
.\"O .B interact
.\"O will detect when the current process exits and implicitly do a
.\"O .BR close .
.\"O But if you kill the process by, say, "exec kill $pid",
.\"O you will need to explicitly call
.\"O .BR close .
.\"O 
.\"O The
.\"O .BR \-onexec
.\"O flag determines whether the spawn id will be closed in any new spawned
.\"O processes or if the process is overlayed.  To leave a spawn id open,
.\"O use the value 0.  A non-zero integer value will force the spawn closed
.\"O (the default) in any new processes.
.\"O 
.\"O The 
.\"O .B \-slave
.\"O flag closes the slave associated with the spawn id.  (See "spawn -pty".)
.\"O When the connection is closed, the slave is automatically closed as
.\"O well if still open.
.\"O 
.\"O No matter whether the connection is closed implicitly or explicitly,
.\"O you should call
.\"O .B wait
.\"O to clear up the corresponding kernel process slot.
.\"O .B close
.\"O does not call
.\"O .B wait
.\"O since there is no guarantee that closing a process connection will cause
.\"O it to exit.
.\"O See
.\"O .B wait
.\"O below for more info.
カレントプロセスへのコネクションをクローズする。
ほとんどの対話型プログラムが標準入力の EOF を検出し exit する。
それゆえ、
.B close
はそのプロセスを kill するのにも通常充分である。
.B \-i
フラグを指示すると、続く spawn_id を持つプロセスをクローズする。

.B expect
と
.B interact
は両方とも、カレントプロセスが exit した時点を検出して、明示しなくても
.BR close
を実行する。
しかし、"exec kill $pid" などのように、あなたがプロセスを kill している
なら、明示的に
.BR close
を呼ぶ必要がある。

.BR \-onexec
フラグを指示すると、新しい spawn が起きた時またはプロセスが重ねられた時に
前の spawn を閉じるべきかどうかを指示することができる。
前の spawn id で開いたままにしておきたければ、値 0 を用いる。
0 でない整数を指示すると、新しいプロセス中では前の spawn はクローズされる
(デフォルト)。

.B \-slave
フラグを指示すると、その spawn id の抱えているスレーブの spawn もクローズする。
("spawn -pty"を参照)
コネクションがクローズされると、スレーブはオープン状態であっても
クローズされる。

コネクションのクローズが明示されていたか否かに全然関わりなく、
関係するカーネルプロセススロットをクリアしてしまいたければ、
.B wait
を呼ぶこと。
.B close
は、
.B wait
を呼ばない。プロセスへのコネクションをクローズすると、そのプロセスが
exit するという保証がないからである。
もっと知りたければ、
.B wait
の項を参照すること。
.TP
.BI debug " [[-now] 0|1]"
.\"O controls a Tcl debugger allowing you to step through statements, set
.\"O breakpoints, etc.
.\"O 
.\"O With no arguments, a 1 is returned if the debugger is not running, otherwise
.\"O a 0 is returned.
.\"O 
.\"O With a 1 argument, the debugger is started.  With a 0 argument, the
.\"O debugger is stopped.  If a 1 argument is preceded by the
.\"O .B \-now
.\"O flag, the debugger is started immediately (i.e., in the middle of the
.\"O .B debug
.\"O command itself).  Otherwise, the debugger is started with the next
.\"O Tcl statement.
.\"O 
.\"O The
.\"O .B debug
.\"O command does not change any traps.  Compare this to starting Expect with the 
.\"O .B -D
.\"O flag (see above).
.\"O 
.\"O See the README file or SEE ALSO (below)
.\"O for more information on the debugger.
は、Tcl デバッガを制御する。デバッガにより、ステップ実行、ブレークポイントの
設定などが行なえる。

引数がない場合、デバッガが走っていれば 1 を、そうでなければ 0 を返す。

引数が 1 なら、デバッガが起動される。引数が 0 なら、デバッガが停止する。
引数 1 の前に
.B \-now
フラグがあれば、デバッガは即座に起動される(つまり、
.B debug
コマンドそのものの途中で)。そうでなければ、デバッガは次の Tcl コマンドから
起動される。

.B debug
コマンドはトラップを変更しない。
.B -D
フラグをつけて起動させた場合とはそこが違う(上記参照)。

デバッガについては、README ファイルと関連項目を参照すること。
.TP
.B disconnect
.\"O disconnects a forked process from the terminal.  It continues running in the
.\"O background.  The process is given its own process group (if possible).
.\"O Standard I/O is redirected to /dev/null.
fork されたプロセスを端末から切り離す。バックグラウンドで動作は続く。
プロセスは可能であれば自分自身のプロセスグループを与える。
標準入出力は、/dev/null にリダイレクトされる。
.IP
.\"O The following fragment uses
.\"O .B disconnect
.\"O to continue running the script in the background.  
以下の断片は、
.B disconnect
を使って、バックグラウンドでスクリプトの実行を続ける。
.nf

    if {[fork]!=0} exit
    disconnect
    . . .

.fi
.\"O The following script reads a password, and then runs a program
.\"O every hour that demands a password each time it is run.  The script supplies
.\"O the password so that you only have to type it once.
.\"O (See the
.\"O .B stty
.\"O command which demonstrates how to turn off password echoing.)
以下のスクリプトは、パスワードを読んで、一時間毎にパスワードを要求する
プログラムを実行する。スクリプトはパスワードを読み込んでいるので、
タイプするのは一回だけで済む。
(パスワードのエコーを避ける方法については、
.B stty
コマンドを参照)
.nf
    send_user "password?\\ "
    expect_user -re "(.*)\\n"
    for {} 1 {} {
        if {[fork]!=0} {sleep 3600;continue}
        disconnect
        spawn priv_prog
        expect Password:
        send "$expect_out(1,string)\\r"
        . . .
        exit
    }

.fi
.\"O An advantage to using
.\"O .B disconnect
.\"O over the shell asynchronous process feature (&) is that
.\"O .B Expect
.\"O can
.\"O save the terminal parameters prior to disconnection, and then later
.\"O apply them to new ptys.  With &,
.\"O .B Expect
.\"O does not have a chance
.\"O to read the terminal's parameters since the terminal is already
.\"O disconnected by the time
.\"O .B Expect
.\"O receives control.
シェルの非同期実行(&)時に
.B disconnect
を用いる利点は、
.B Expect
が disconnect の前に端末情報を保存しておいて、後で新しい pty にそのパラメタを
適用できる点にある。
& を使っていて
.B Expect
が制御を受けとって disconnect されてしまうと、端末情報を読み込むことはできない。
.TP
.BI exit " [\-opts] [status]"
.\"O causes
.\"O .B Expect
.\"O to exit or otherwise prepare to do so.
.\"O 
.\"O The
.\"O .B \-onexit
.\"O flag causes the next argument to be used as an exit handler.
.\"O Without an argument, the current exit handler is returned.
.\"O 
.\"O The
.\"O .B \-noexit
.\"O flag causes
.\"O .B Expect
.\"O to prepare to exit but stop short of actually returning control to the
.\"O operating system.  The user-defined exit handler is run as well as Expect's
.\"O own internal handlers.
.\"O No further Expect commands should be executed.
.\"O This is useful if you are running Expect with other Tcl extensions.
.\"O The current interpreter (and main window if in the Tk environment) remain
.\"O so that other Tcl extensions can clean up.  If Expect's
.\"O .B exit
.\"O is called again (however this might occur), the handlers are not rerun.
.\"O 
.\"O Upon exiting, 
.\"O all connections to spawned processes are closed.  Closure will be detected
.\"O as an EOF by spawned processes.
.\"O .B exit
.\"O takes no other actions beyond what the normal _exit(2) procedure does.
.\"O Thus, spawned processes that do not check for EOF may continue to run.
.\"O (A variety of conditions are important to determining, for example, what
.\"O signals a spawned process will be sent, but these are system-dependent,
.\"O typically documented under exit(3).)
.\"O Spawned processes that continue to run will be inherited by init.
.\"O 
.\"O .I status
.\"O (or 0 if not specified) is returned as the exit status of
.\"O .BR Expect .
.\"O .B exit
.\"O is implicitly executed if the end of the script is reached.
.B Expect
を exit させるか、そのための準備を行なう。

.B \-onexit
フラグは、続く引数を exit ハンドラとして用いる。
引数がなければ、exit ハンドラは何もしない。

.B \-noexit
フラグを指定すると
.B Expect
は、exit の準備をして OS へ制御を返す直前に停止する。
ユーザーの定義した exit ハンドラは、Expect 自身の内部ハンドラと同じように
実行される。
それ以上 Expect のコマンドが実行されるべきではない。あなたが他の
Tcl Extension を Expect につけている場合にこの機能は意味がある。
Expect の
.B exit
がもう一度呼び出されると(こういう場合も起こり得る)、ハンドラは処理を
返さない。

exit する際に、全ての spawn されたプロセスへのコネクションはクローズされる。
クローズは EOF 検出によって行なわれる。
.B exit
は、普通の exit(2) が行なう以上のことはしない。
それで、spawn されたプロセスが EOF をチェックしない場合、そのプロセスは
走り続ける。(spawn されたプロセスへ送られたシグナルを判断するといったこと
には複数の条件が関わってくる。これらは、システム依存であり、典型的な動作は
各システムの exit(3) のドキュメントに記述されている。)

.I status
(指定がないときは、0 )は、
.BR Expect
の、終了ステータスとしてシステムに返される。
.B exit
は、スクリプトの終りに達すると、書いていなくても実行される、
.TP
\fBexp_continue\fR [-continue_timer]
.\"O The command
.\"O .B exp_continue
.\"O allows
.\"O .B expect
.\"O itself to continue
.\"O executing rather than returning as it normally would. By
.\"O default
.\"O .B exp_continue
.\"O resets the timeout timer. The
.\"O .I -continue_timer
.\"O flag prevents timer from being restarted. (See
.\"O .B expect
.\"O for more information.)
.B exp_continue
コマンドは
.B expect
自身に待っていた値が来なかった時のように、expect の実行を続ける。
デフォルトでは
.B exp_continue
は時間切れタイマーをリセットする。
.I -continue_timer
フラグはタイマーを再実行しないようにする。
(より詳細な情報は
.B expect
を参照のこと。)
.TP
.BI exp_internal " [\-f file] value"
.\"O causes further commands to send diagnostic information internal to
.\"O .B Expect
.\"O to stderr if
.\"O .I value
.\"O is non-zero.  This output is disabled if
.\"O .I value
.\"O is 0.  The diagnostic information includes every character received,
.\"O and every attempt made to match the current output against the patterns.
.I value
がゼロでなければ、以降のコマンドの診断情報を
.B Expect
内部の stderr に送るようになる。
.I value
に0を指定するとこの出力は止まる。この診断情報には、受けとった
すべての文字と、現在の出力とパターンをマッチさせる全試行が
含まれる。
.IP
.\"O If the optional
.\"O .I file
.\"O is supplied, all normal and debugging output is written to that file
.\"O (regardless of the value of
.\"O .IR value ).
.\"O Any previous diagnostic output file is closed.
.\"O 
.\"O The
.\"O .B \-info
.\"O flag causes exp_internal to return a description of the
.\"O most recent non-info arguments given.
.I file
オプションを指定すると、すべての通常および診断出力がそのファイルに
出力される。(
.IR value
の値とは無関係に)。すでにオープンされている診断出力ファイルは、
すべてクローズされる。

.B \-info
フラグは、最後に指定された info フラグでない引数の内容を返す。
.TP
.BI exp_open " [args] [\-i spawn_id]"
.\"O returns a Tcl file identifier that corresponds to the original spawn id.
.\"O The file identifier can then be used as if it were opened by Tcl's
.\"O .B open
.\"O command.  (The spawn id should no longer be used.  A
.\"O .B wait
.\"O should not be executed.
.\"O 
.\"O The
.\"O .B \-leaveopen
.\"O flag leaves the spawn id open for access through 
.\"O Expect commands.  A
.\"O .B wait
.\"O must be executed on the spawn id.
元の spawn id に結びつけられたファイル ID を返す。
そのファイル ID は、Tcl の
.B open
コマンドでオープンした時と同様に扱える。
(spawn id は、もう使われるべきでない。
.B wait
も実行すべきではない。)

.B \-leaveopen
フラグは、spawn id をオープンしたままにしておく。
.B wait
が、その spawn id に対して実行されねばならない。
.TP
.BI exp_pid " [\-i spawn_id]"
.\"O returns the process id corresponding to the currently spawned process.
.\"O If the
.\"O .B \-i
.\"O flag is used, the pid returned corresponds to that of the given spawn id.
現在の spawn されたプロセスのプロセス ID を返す。
.B \-i
フラグを指示すると、与えられた spawn id に対するプロセスの ID を返す。
.TP
.B exp_send
.\"O is an alias for
.\"O .BR send .
.BR send
のエイリアス。
.TP
.B exp_send_error
.\"O is an alias for
.\"O .BR send_error .
.BR send_error
のエイリアス。
.TP
.B exp_send_log
.\"O is an alias for
.\"O .BR send_log .
.BR send_log
のエイリアス。
.TP
.B exp_send_tty
.\"O is an alias for
.\"O .BR send_tty .
.BR send_tty
のエイリアス。
.TP
.B exp_send_user
.\"O is an alias for
.\"O .BR send_user .
.BR send_user
のエイリアス。
.TP
.BI exp_version " [[\-exit] version]"
.\"O is useful for assuring that the script is compatible with the current
.\"O version of Expect.
.\"O .IP
.\"O With no arguments, the current version of
.\"O .B Expect
.\"O is returned.  This version
.\"O may then be encoded in your script.  If you actually know that you are not
.\"O using features of recent versions, you can specify an earlier version.
は、スクリプトが現バージョンのExpectで動くことを確かめる時に役に立つ。
.IP
引数がなければ、
.B Expect
の現在のバージョンを返す。このバージョンはあなたのスクリプト内で
設定しても良い。あなたが最近のバージョンに入った機能を使わないの
であれば、もっと前のバージョンを指定することができる。
.IP
.\"O Versions consist of three numbers separated by dots.  First
.\"O is the major number.  Scripts written for versions of
.\"O .B Expect
.\"O with a
.\"O different major number will almost certainly not work.
.\"O .B exp_version 
.\"O returns an error if the major numbers do not match.
バージョンはドットで区切られた 3 つの番号である。
最初の番号は、メジャー番号である。
違うメジャー番号の
.B Expect
用に書いたスクリプトは、まず動かない。
.B exp_version 
は、メジャー番号がマッチしないとエラーを返す。
.IP
.\"O Second is the minor number.  Scripts written for a version with a
.\"O greater minor number than the current version
.\"O may depend upon some new feature and might not run.
.\"O .B exp_version
.\"O returns an error if the major numbers match, but the script minor number
.\"O is greater than that of the running
.\"O .BR Expect .
2 番めの番号はマイナー番号である。
使っている Expect よりマイナー番号がより大きい Expect 向けのスクリプトは、
新機能の使用未使用によるが、動かないかも知れない。
.B exp_version
はメジャー番号がマッチしてもマイナー番号が使っている
.BR Expect
のバージョンより大きいとエラーを返す。
.IP
.\"O Third is a number that plays no part in the version comparison.
.\"O However, it is incremented when the
.\"O .B Expect
.\"O software
.\"O distribution is changed in any way, such as by additional documentation
.\"O or optimization.  It is reset to 0 upon each new minor version.
3番めの番号は、バージョン比較には使われない。
しかし、文書の更新やプログラムの最適化が行なわれて、
.B Expect
のディストリビューションが更新されると、番号が増えていく。
新しいマイナーバージョンが設定される度に、0 にリセットされる。
.IP
.\"O With the
.\"O .B \-exit
.\"O flag,
.\"O .B Expect
.\"O prints an error and exits if the version is out of date.
.B \-exit
フラグをつけると、バージョンが合わなかった時に
.B Expect
はエラーを表示し exit する。
.TP
.BI expect " [[\-opts] pat1 body1] ... [\-opts] patn [bodyn]"
.\"O waits until one of the patterns matches the output of a spawned process,
.\"O a specified time period has passed, or an end-of-file is seen.
.\"O If the final body is empty, it may be omitted.
.\"O .IP
.\"O Patterns from the most recent
.\"O .B expect_before
.\"O command are implicitly used before any other patterns.
.\"O Patterns from the most recent
.\"O .B expect_after
.\"O command are implicitly used after any other patterns.
は、spawn されたプロセスの出力がパターンのどれかにマッチするか、
指定された時間が経過するか、enf-of-file を見つけるか、のいずれかが
成立するまでウェイトする。
最後の body が空なら、それは省略できる。
.IP
一番最後に実行された
.B expect_before
コマンドのパターンが、どのパターンより先にチェックされる。
一番最後に実行された
.B expect_after
コマンドのパターンが、どのパターンより後にチェックされる。
.IP
.\"O If the arguments to the entire
.\"O .B expect
.\"O statement require more than one line,
.\"O all the arguments may be "braced" into one so as to avoid terminating each
.\"O line with a backslash.  In this one case, the usual Tcl substitutions will
.\"O occur despite the braces.
.B expect
全体への引数が 1 行に収まらなかった場合は、
引数を"ブレース"することで、各行の終りにバックスラッシュをつけるのを
避けることができる。この場合、ブレースしたにもかかわらず通常の Tcl 展開が
発生する。
.IP
.\"O If a pattern is the keyword
.\"O .BR eof ,
.\"O the corresponding body is executed upon end-of-file.
.\"O If a pattern is the keyword
.\"O .BR timeout ,
.\"O the corresponding body is executed upon timeout.  If no timeout keyword
.\"O is used, an implicit null action is executed upon timeout.
.\"O The default timeout period is 10 seconds but may be set, for example to 30,
.\"O by the command "set timeout 30".  An infinite timeout may be designated
.\"O by the value \-1.
.\"O If a pattern is the keyword
.\"O .BR default ,
.\"O the corresponding body is executed upon either timeout or end-of-file.
もし、パターンがキーワード
.BR eof
であれば、end-of-file 発見時に処理が実行される。
もし、パターンがキーワード
.BR timeout
であれば、タイムアウトが発生した時に処理が実行される。
timeout キーワードが使われなかった場合、タイムアウト時にはなにもしない。
デフォルトタイムアウトは 10 秒である。設定することもできる。
例えば 30 秒と設定したければ、"set timeout 30"を実行すること。
タイムアウトさせないためには、値 \-1 を設定する。
もし、パターンがキーワード
.BR default
であれば、タイムアウトか end-of-file のいずれかで処理が実行される。
.IP
.\"O If a pattern matches, then the corresponding body is executed.
.\"O .B expect
.\"O returns the result of the body (or the empty string if no pattern matched).
.\"O In the event that multiple patterns match, the one appearing first is
.\"O used to select a body.
パターンにマッチすれば、処理は実行される。
.B expect
は、行なった処理(関連するブレース内の処理)の結果を返す。
(パターンにマッチしなかった時は、空文字列を返す。)
複数のパターンにマッチした場合、最初にマッチしたパターンに対応する処理が
実行される。
.IP
.\"O Each time new output arrives, it is compared to each pattern in the order
.\"O they are listed.  Thus, you may test for absence of a match by making
.\"O the last pattern something guaranteed to appear, such as a prompt.
.\"O In situations where there is no prompt, you must use
.\"O .B timeout
.\"O (just like you would if you were interacting manually).
対話型プログラムからの新しい出力が Expect に届くたびに、リストされている順に
パターンとの比較が行なわれる。それゆえ、マッチすべきものがないことを
確認するために、プロンプトのように来ることがわかっているパターンを用意する
ことができる。
プロンプトがない場合には、(あなたが手で打つ時に判断しているように)
.B timeout
を用いなければならない。
.IP
.\"O Patterns are specified in three ways.  By default, 
.\"O patterns are specified as with Tcl's
.\"O .B string match
.\"O command.  (Such patterns are also similar to C-shell regular expressions
.\"O usually referred to as "glob" patterns).  The
.\"O .B \-gl
.\"O flag may may
.\"O be used to protect patterns that might otherwise match
.\"O .B expect
.\"O flags from doing so.
.\"O Any pattern beginning with a "-" should be protected this way.  (All strings
.\"O starting with "-" are reserved for future options.)
パターンは 3 通りに書ける。デフォルトは、Tcl の
.B string match
コマンドの書式である。(このパターンはグロブで参照される C-shell の正規表現に
似ている。)
.B \-gl
フラグは、他のマッチからパターンを保護するのに使う。
"-"で始まるパターンは、この方法で保護すべきである。
("-"で始まる文字列は将来の拡張で、オプションとして使われるかも知れないから)


.IP
.\"O For example, the following fragment looks for a successful login.
.\"O (Note that
.\"O .B abort
.\"O is presumed to be a procedure defined elsewhere in the script.)
例えば、以下の断片はログインの成功を監視する。
.RB ( abort
はスクリプトのどこか他の場所で定義されていると仮定している。
注意すること。)
.nf

.ta \w'      expect 'u +\w'invalid password    'u
    expect {
        busy               {puts busy\\n ; exp_continue}
        failed             abort
        "invalid password" abort
        timeout            abort
        connected
    }

.fi
.\"O Quotes are necessary on the fourth pattern since it contains a space, which
.\"O would otherwise separate the pattern from the action.
.\"O Patterns with the same action (such as the 3rd and 4th) require listing the
.\"O actions again.  This can be avoid by using regexp-style patterns (see below).
.\"O More information on forming glob-style patterns can be found in the Tcl manual.
4番めのパターンにはスペースが含まれているのでクオートが必要である。
アクションとパターンを分離するセパレータでないことを指示する必要がある。
(3番めと4番めの)ように同じアクションを持つリクエストも並べて書く必要が
ある。これは、正規表現パターンを用いることで回避できる(下記参照)。
グロブスタイルパターンについてもっと情報が欲しければ、Tcl のマニュアルを
読むこと。
.IP
.\"O Regexp-style patterns follow the syntax defined by Tcl's
.\"O .B regexp
.\"O (short for "regular expression") command.
.\"O regexp patterns are introduced with the flag
.\"O .BR \-re .
.\"O The previous example can be rewritten using a regexp as:
正規表現パターンは、Tcl の
.B regexp
("regular expression"の短縮)コマンドで定義される文法に従う。
regexpパターンは、
.BR \-re
フラグで始める。
前の例を、regexp で書き直すと、こうなる。:
.nf

.ta \w'      expect 'u +\w'connected    'u
    expect {
        busy       {puts busy\\n ; exp_continue}
        \-re "failed|invalid password" abort
        timeout    abort
        connected
    }

.fi
.\"O Both types of patterns are "unanchored".  This means that patterns
.\"O do not have to match the entire string, but can begin and end the
.\"O match anywhere in the string (as long as everything else matches).
.\"O Use ^ to match the beginning of a string, and $ to match the end.
.\"O Note that if you do not wait for the end of a string, your responses
.\"O can easily end up in the middle of the string as they are echoed from
.\"O the spawned process.  While still producing correct results, the output
.\"O can look unnatural.  Thus, use of $ is encouraged if you can exactly
.\"O describe the characters at the end of a string.
.\"O 
.\"O Note that in many editors, the ^ and $ match the beginning and end of
.\"O lines respectively. However, because expect is not line oriented,
.\"O these characters match the beginning and end of the data (as opposed
.\"O to lines) currently in the expect matching buffer.  (Also, see the
.\"O note below on "system indigestion.")
.\"O 
.\"O The
.\"O .B \-ex
.\"O flag causes the pattern to be matched as an "exact" string.  No
.\"O interpretation of *, ^, etc is made (although the usual Tcl
.\"O conventions must still be observed).
.\"O Exact patterns are always unanchored.
どちらのパターンのタイプも、"固定されていない"。どういう意味かというと、
文字列全体にマッチする必要はなくて、文字列のどこでもマッチすれば
良いということである。^ が先頭にマッチする。 $ が末尾にマッチする。
文字列の末尾にマッチさせなければ、spawn されたプロセスからエコーされた
文字列の途中で切り上げてレスポンスを返せることに注意すること。
正しく処理が実行されていても、出力は不自然に見える可能性がある。
それで、文字列の終りの文字を正確に記述できるなら、$ を使うことを勧める。

多くのエディタでは、^ と $ は行頭、行末に正確にマッチする。
しかし、expect は行指向ではないので、(行ではなく)データの始まりと終りに
マッチする。
("EXPECTヒント"内の、バッファリングの消化不良に関する部分を参照のこと)

.B \-ex
フラグは、"正確に(exact)"指示された文字列にマッチする。
* や ^ などの解釈は行なわれない。(ただし、通常の Tcl 展開は行なわれる)。
Exact パターンは常に固定されている。


.IP
.\"O The
.\"O .B \-nocase
.\"O flag causes uppercase characters of the output to compare as if they were
.\"O lowercase characters.  The pattern is not affected.
.B \-nocase
フラグは、小文字が含まれている場合に大文字に変換してからマッチさせる。
パターンには影響しない。
.IP
.\"O While reading output,
.\"O more than 2000 bytes can force earlier bytes to be "forgotten".
.\"O This may be changed with the function
.\"O .BR match_max .
.\"O (Note that excessively large values can slow down the pattern matcher.)
.\"O If
.\"O .I patlist
.\"O is
.\"O .BR full_buffer ,
.\"O the corresponding body is executed if
.\"O .I match_max
.\"O bytes have been received and no other patterns have matched.
.\"O Whether or not the
.\"O .B full_buffer
.\"O keyword is used, the forgotten characters are written to
.\"O expect_out(buffer).
出力を読んでいて、2000 バイトを超えてしまったデータは"忘れられる"。
この動作は、
.BR match_max
関数で変更できる。
(極端に大きな値はパターンマッチの性能を低下させることに注意すること。)
.I patlist
に
.BR full_buffer
を指定すると、
.I match_max
バイト以上のデータを受けてパターンマッチしなかったときに、処理が実行される。
.B full_buffer
キーワードの有無に関わらず、忘れられたデータは
expect_out(buffer)
に保存される。

.\"O If
.\"O .I patlist
.\"O is the keyword
.\"O .BR null ,
.\"O and nulls are allowed (via the
.\"O .B remove_nulls
.\"O command), the corresponding body is executed if a single ASCII
.\"O 0 is matched.
.\"O It is not possible to
.\"O match 0 bytes via glob or regexp patterns.
.I patlist
に、キーワード
.BR null
を指定すると、ヌル文字が許可され
(
.B remove_nulls
コマンドを通して)、ヌル文字(ASCII 0)にマッチする。
glob や regexp では 0 バイトにマッチすることができない。

.\"O Upon matching a pattern (or eof or full_buffer),
.\"O any matching and previously unmatched output is saved in the variable
.\"O .IR expect_out(buffer) .
.\"O Up to 9 regexp substring matches are saved in the variables
.\"O .I expect_out(1,string)
.\"O through
.\"O .IR expect_out(9,string) .
.\"O If the
.\"O .B -indices
.\"O flag is used before a pattern,
.\"O the starting and ending indices (in a form suitable for
.\"O .BR lrange )
.\"O of the
.\"O 10 strings are stored in the variables
.\"O .I expect_out(X,start)
.\"O and
.\"O .I expect_out(X,end)
.\"O where X is a digit, corresponds to the substring position in the buffer.
.\"O 0 refers to strings which matched the entire pattern
.\"O and is generated for glob patterns as well as regexp patterns.
パターン(あるいは、eol, full_buffer)にマッチすると、マッチした部分の文字列か、
その前のマッチしなかった文字列が、変数
.IR expect_out(buffer)
に保存される。

9 個までのマッチした部分文字列は、変数
.I expect_out(1,string)
から
.IR expect_out(9,string)
に保存される。
.B -indices
フラグをパターンの前で指定すると、マッチした部分文字列の
開始位置と終了位置が(
.BR lrange
の引数として使える形で)、変数
.I expect_out(X,start)
と
.I expect_out(X,end)
に保存される。
X は数字で 0 〜 9 まで。
0 はパターン全体がマッチした部分を指示する。
.\"O For example, if a process has produced output of "abcdefgh\\n", the result of:
例えば、プロセスが"abcdefgh\\n"を出力し、以下の形:
.nf

    expect "cd"

.fi
.\"O is as if the following statements had executed:
で受けると、以下の文を実行したのと同じ結果となる。
.nf

    set expect_out(0,string) cd
    set expect_out(buffer) abcd

.fi
.\"O and "efgh\\n" is left in the output buffer.
この時、"efgh\\n"は出力バッファに残る。
.\"O If a process produced the output "abbbcabkkkka\\n", the result of:
プロセスが"abbbcabkkkka\\n"を出力し、以下の形:
.nf

    expect \-indices \-re "b(b*).*(k+)"

.fi
.\"O is as if the following statements had executed:
で受けると、以下の文を実行したのと同じ結果になる。
.nf

    set expect_out(0,start) 1
    set expect_out(0,end) 10
    set expect_out(0,string) bbbcabkkkk
    set expect_out(1,start) 2
    set expect_out(1,end) 3
    set expect_out(1,string) bb
    set expect_out(2,start) 10
    set expect_out(2,end) 10
    set expect_out(2,string) k
    set expect_out(buffer) abbbcabkkkk

.fi
.\"O and "a\\n" is left in the output buffer.  The pattern "*" (and -re ".*") will
.\"O flush the output buffer without reading any more output from the
.\"O process.
この時、"a\\n"は出力バッファに残る。
パターン"*" (と -re ".*")は、プロセスからのデータがさらに来ない限り、
出力バッファをフラッシュしない。
.IP
.\"O Normally, the matched output is discarded from Expect's internal buffers.
.\"O This may be prevented by prefixing a pattern with the
.\"O .B \-notransfer
.\"O flag.  This flag is especially useful in experimenting (and can be
.\"O abbreviated to "-not" for convenience while experimenting).
通常、マッチした出力は Expect の内部バッファから、切り捨てらる。
この動作は、
.B \-notransfer
フラグで抑止することができる。このフラグは、スクリプトを試している時に
役に立つ(そして、"-not"と略記しても良い)。

.\"O The spawn id associated with the matching output (or eof or
.\"O full_buffer) is stored in
.\"O .IR expect_out(spawn_id) .
.\"O 
.\"O The
.\"O .B \-timeout
.\"O flag causes the current expect command to use the following value
.\"O as a timeout instead of using the value of the timeout variable.
.\"O 
.\"O By default, 
.\"O patterns are matched against output from the current process, however the
.\"O .B \-i
.\"O flag declares the output from the named spawn_id list be matched against
.\"O any following patterns (up to the next
.\"O .BR \-i ).
.\"O The spawn_id list should either be a whitespace separated list of spawn_ids
.\"O or a variable referring to such a list of spawn_ids.
マッチした出力を送ってきたプロセスへの spawn id は、
.IR expect_out(spawn_id)
に保存される。

.B \-timeout
フラグは、この expect コマンドの中の timeout 時刻を timeout 変数でなく
指示された値に設定する。

デフォルトでは、パターンはカレントプロセスからの出力にマッチさせるのだが、
.B \-i
フラグを設定すると、指定された spawn_id リストに対応するプロセス群からの出力に
マッチさせることができる。(次の
.BR \-i
での指定があるまで有効である。)
spawn_id リストは、スペースで区切った spawn_id のリストか、そのような値を持つ
変数への参照でなくてはならない。

.\"O For example, the following example waits for
.\"O "connected" from the current process, or "busy", "failed" or "invalid
.\"O password" from the spawn_id named by $proc2.
例えば、以下の例はカレントプロセスからの"connected"と
$proc2 と言う名前の spawn_id からの"busy","failed","invalid password"
を待ち受ける。
.nf

    expect {
        \-i $proc2 busy {puts busy\\n ; exp_continue}
        \-re "failed|invalid password" abort
        timeout abort
        connected
    }

.fi
.\"O The value of the global variable
.\"O .I any_spawn_id
.\"O may be used to match patterns to any spawn_ids that are named
.\"O with all other
.\"O .B \-i
.\"O flags in the current
.\"O .B expect
.\"O command.
.\"O The spawn_id from a
.\"O .B \-i
.\"O flag with no associated pattern (i.e., followed immediately
.\"O by another
.\"O .BR \-i )
.\"O is made available to any other patterns
.\"O in the same
.\"O .B expect
.\"O command associated with
.\"O .I any_spawn_id.
.\"O 
.\"O The
.\"O .B \-i
.\"O flag may also name a global variable in which case the variable is read
.\"O for a list of spawn ids.  The variable is reread whenever it changes.
.\"O This provides a way of changing the I/O source while the command is in
.\"O execution.  Spawn ids provided this way are called "indirect" spawn ids.
.\"O 
.\"O Actions such as
.\"O .B break
.\"O and
.\"O .B continue
.\"O cause control structures (i.e.,
.\"O .BR for ,
.\"O .BR proc )
.\"O to behave in the usual way.
.\"O The command
.\"O .B exp_continue
.\"O allows
.\"O .B expect
.\"O itself to continue
.\"O executing rather than returning as it normally would.
大域変数
.I any_spawn_id
の値は、
今の
.B expect
コマンド内で
.B \-i
フラグを指示した spawn_id の全てにマッチさせるために使われる。
.B \-i
フラグをパターンなしで指定すると(すなわち、別の
.BR \-i
が直後に続くと)、
.I any_spawn_id
で指定された、同じ
.B expect
コマンド内の他のパターンに対して、有効になる。

.B \-i
フラグには、グローバル変数の名前を指定することもできる。その場合、
その変数は、spawn id のリストである。変数は変わるたびに読み直される。
こうすることで、コマンドが実行されている間に I/O ソースを変更すること
ができる。この方法で指定される spawn id を"間接(indirect)" spawn id
と呼ぶ。

.B break
や
.B continue
などのアクションは、制御構造(すなわち、
.BR for , proc
)内で通常通りの振舞いをする。

.B exp_continue
コマンドは、
.B expect
ループから抜けるような状況で実行を続けさせる。
.IP
.\"O This is useful for avoiding explicit loops or repeated expect statements.
.\"O The following example is part of a fragment to automate rlogin.  The
.\"O .B exp_continue
.\"O avoids having to write a second
.\"O .B expect
.\"O statement (to look for the prompt again) if the rlogin prompts for a password.
ループを書いたり、expect コマンドを繰り返すことを避ける時に便利である。
以下の例はログインを自動化するコードの断片である。
.B exp_continue
によって、(再びプロンプトを探すための)2 つめの
.B expect
コマンドを書かなくて済んでいる。
.nf

    expect {
        Password: {
            stty -echo
            send_user "password (for $user) on $host: "
            expect_user -re "(.*)\\n"
            send_user "\\n"
            send "$expect_out(1,string)\\r"
            stty echo
            exp_continue
        } incorrect {
            send_user "invalid password or account\\n"
            exit
        } timeout {
            send_user "connection to $host timed out\\n"
            exit
        } eof {
            send_user \\
                "connection to host failed: $expect_out(buffer)"
            exit
        } -re $prompt
    }

.fi
.\"O For example, the following fragment might help a user guide
.\"O an interaction that is already totally automated.  In this case, the terminal
.\"O is put into raw mode.  If the user presses "+", a variable is incremented.
.\"O If "p" is pressed, several returns are sent to the process,
.\"O perhaps to poke it in some way, and "i" lets the user interact with the
.\"O process, effectively stealing away control from the script.
.\"O In each case, the
.\"O .B exp_continue
.\"O allows the current
.\"O .B expect
.\"O to continue pattern matching after executing the
.\"O current action.
例えば、以下の断片は既に自動化されているユーザーガイドへのやりとりを
補助する。
この場合、端末は raw モードになる。
ユーザーが'+'を押すと変数がインクリメントされる。
"p"が押されると、プロセスへ復帰情報が送られる。
おそらくは同じように"i"が押されると、スクリプトから制御を奪い、
ユーザーからの制御が行なえる。
どの場合も
.B exp_continue
コマンドが、今の
.B expect
に、処理を行なわせた後再びパターンマッチさせている。
.nf

    stty raw \-echo
    expect_after {
        \-i $user_spawn_id
        "p" {send "\\r\\r\\r"; exp_continue}
        "+" {incr foo; exp_continue}
        "i" {interact; exp_continue}
        "quit" exit
    }

.fi
.IP
.\"O By default,
.\"O .B exp_continue
.\"O resets the timeout timer.  The timer is not restarted, if
.\"O .B exp_continue
.\"O is called with the 
.\"O .B \-continue_timer
.\"O flag.
デフォルトでは、
.B exp_continue
は、タイムアウトタイマーをリセットする。
タイマを再開させるには、
.B exp_continue
コマンドに
.B \-continue_timer
フラグをつける。
.TP
.BI expect_after " [expect_args]"
.\"O works identically to the
.\"O .B expect_before
.\"O except that if patterns from both
.\"O .B expect
.\"O and
.\"O .B expect_after
.\"O can match, the
.\"O .B expect
.\"O pattern is used.  See the
.\"O .B expect_before
.\"O command for more information.
は、
.B expect_before
と同様の動きをするが、
.B expect
と
.B expect_after
の両方にマッチした場合、
.B expect
のパターンが使用される点が異なる。
より詳しい情報は、
.B expect_before
コマンドの項を参照のこと。
.TP
.BI expect_background " [expect_args]"
.\"O takes the same arguments as
.\"O .BR expect ,
.\"O however it returns immediately.
.\"O Patterns are tested whenever new input arrives.
.\"O The pattern
.\"O .B timeout
.\"O and
.\"O .B default
.\"O are meaningless to
.\"O .BR expect_background
.\"O and are silently discarded.
.\"O Otherwise, the
.\"O .B expect_background
.\"O command uses
.\"O .B expect_before
.\"O and
.\"O .B expect_after
.\"O patterns just like
.\"O .B expect
.\"O does.
.\"O 
.\"O When
.\"O .B expect_background
.\"O actions are being evaluated, background processing for the same
.\"O spawn id is blocked.  Background processing is unblocked when
.\"O the action completes.  While background processing is blocked,
.\"O it is possible to do a (foreground)
.\"O .B expect
.\"O on the same spawn id.
.\"O 
.\"O It is not possible to execute an
.\"O .B expect
.\"O while an
.\"O .B expect_background
.\"O is unblocked.
.\"O .B expect_background
.\"O for a particular spawn id is deleted by
.\"O declaring a new expect_background with the same spawn id.  Declaring
.\"O .B expect_background
.\"O with no pattern removes the given spawn id
.\"O from the ability to match patterns in the background.
は、
.BR expect
と同じ引数をとるが、その場で復帰する。
パターンは新しいデータが届くたびにチェックされる。
パターン
.B timeout
と
.B default
は、
.BR expect_background
には、意味がないし、無視される。
.B expect
と同様に、
.B expect_background
コマンドは
.B expect_before
や
.B expect_after
パターンを使える。

.B expect_background
アクションが、評価される時、同じ spawn id を持つ
バックグラウンドプロセスはブロックされる。
アクションが完了すると、プロセスがアンブロックされる。
バックグラウンドプロセスがブロックされている間は、
(フォアグラウンドの)
.B expect
で、同じ spawn id に接続することができる。
逆に、
.B expect_background
がブロックされていない間は
.B expect
することができない。
特定の spawn id への
.B expect_background
は、同一 spawn id への新しい expect_background を指定すると
削除される。
パターンをつけない
.B expect_background
を指定することで、バックグラウンドでパターンマッチさせること
をやめさせられる。
.TP
.BI expect_before " [expect_args]"
.\"O takes the same arguments as
.\"O .BR expect ,
.\"O however it returns immediately.
.\"O Pattern-action pairs from the most recent
.\"O .B expect_before
.\"O with the same spawn id are implicitly added to any following
.\"O .B expect
.\"O commands.  If a pattern matches, it is treated as if it had been
.\"O specified in the
.\"O .B expect
.\"O command itself, and the associated body is executed in the context
.\"O of the
.\"O .B expect
.\"O command.
.\"O If patterns from both
.\"O .B expect_before
.\"O and
.\"O .B expect
.\"O can match, the
.\"O .B expect_before
.\"O pattern is used.
.\"O 
.\"O If no pattern is specified, the spawn id is not checked for any patterns.
.\"O 
.\"O Unless overridden by a
.\"O .B \-i
.\"O flag,
.\"O .B expect_before
.\"O patterns match against the spawn id defined at the time that the 
.\"O .B expect_before
.\"O command was executed (not when its pattern is matched).
は
.BR expect
と同じ引数をとるが、その場で復帰する。
もっとも最近、同じ spawn id に対して
.B expect_before
で使われたパターン・アクションのペアが、続く
.B expect
コマンドに対して使用される。
パターンがマッチすると、
.B expect
コマンドにマッチした時と同じように動作する。
処理は、その
.B expect
のコンテキストで行なわれる。
.B expect_before
と
.B expect
の両方のパターンにマッチした場合、
.B expect_before
のパターンが使われる。

パターンが指示されなかった場合、spawn id は
どのパターンでもチェックされない。

.B \-i
フラグをさらに指定しない限り、
.B expect_before
パターンは、
.B expect_before
が実行された時に定義されたパターンにマッチする。

.\"O The \-info flag causes
.\"O .B expect_before
.\"O to return the current specifications of what patterns it will match.
.\"O By default, it reports on the current spawn id.  An optional spawn id specification may be given for information on that spawn id.  For example
\-info フラグは
.B expect_before
から、マッチパターンの現在の状態を復帰させる。
デフォルトでは、現在の spawn id に報告する。オプションの spawn id を
指定することもできる。例えば、
.nf

    expect_before -info -i $proc

.fi
.\"O At most one spawn id specification may be given.  The flag \-indirect
.\"O suppresses direct spawn ids that come only from indirect specifications.
.\"O 
.\"O Instead of a spawn id specification, the flag "-all" will cause
.\"O "-info" to report on all spawn ids.
.\"O 
.\"O The output of the \-info flag can be reused as the argument to expect_before.
たった一つの spawn id 指定だけが許される。\-indirect フラグで、直接
spawn id を抑止し、間接的な指定から得られるidを指示する。

spawn id を指示する代わりに、"-all"フラグを使って、
全ての spawn id に "-info" の報告をさせることができる。

\-info フラグを使った時の出力結果は、expect_before への引数として
再利用できる。
.TP
.BI expect_tty " [expect_args]"
.\"O is like
.\"O .B expect
.\"O but it reads characters from /dev/tty (i.e. keystrokes from the user).
.\"O By default, reading is performed in cooked mode.
.\"O Thus, lines must end with a return in order for
.\"O .B expect
.\"O to see them.
.\"O This may be changed via
.\"O .B stty
.\"O (see the
.\"O .B stty
.\"O command below).
は、
.B expect
と似た動きをするが、文字列を /dev/tty (すなわち、ユーザーからのキー入力)
から読み込む。
デフォルトでは、cooked mode で読み込まれるので、
行はリターンで終らなければならない。そうしないと
.B expect
が読めない。この動きは、
.B stty
を使って変えられる。
(下の
.B stty
コマンドを参照)
.TP
.BI expect_user " [expect_args]"
.\"O is like
.\"O .B expect
.\"O but it reads characters from stdin (i.e. keystrokes from the user).
.\"O By default, reading is performed in cooked mode.
.\"O Thus, lines must end with a return in order for
.\"O .B expect
.\"O to see them.
.\"O This may be changed via
.\"O .B stty
.\"O (see the
.\"O .B stty
.\"O command below).
は
.B expect
と似た動きをするが、文字列を stdin(すなわち、ユーザーからのキー入力)
から読み込む。
デフォルトでは、cooked mode で読み込まれるので、
行はリターンで終らなければならない。そうしないと
.B expect
が読めない。この動きは、
.B stty
を使って変えられる。
(下の
.B stty
コマンドを参照)
.TP
.B fork
.\"O creates a new process.  The new process is an exact copy of the current
.\"O .B Expect
.\"O process.  On success,
.\"O .B fork
.\"O returns 0 to the new (child) process and returns the process ID of the child
.\"O process to the parent process.
.\"O On failure (invariably due to lack of resources, e.g., swap space, memory),
.\"O .B fork
.\"O returns \-1 to the parent process, and no child process is created.
は、新しいプロセスを作る。この新しいプロセスは、現在の
.B Expect
プロセスの正確なコピーである。
成功すると
.B fork
は 新しい(子)プロセスに 0 を返し、親プロセスに 子プロセスのプロセスIDを
返す。
失敗する(スワップ、メモリなどのリソース不足か?)と、
.B fork
は、親プロセスに \-1 を返す。新しい子プロセスは作成されない。
.\"O .IP
.\"O Forked processes exit via the
.\"O .B exit
.\"O command, just like the original process.
.\"O Forked processes are allowed to write to the log files.  If you do not
.\"O disable debugging or logging in most of the processes, the result can be
.\"O confusing.
.IP
フォークされたプロセスは、
.B exit
コマンドで ext できる。元のプロセスと同様である。
フォークされたプロセスはログファイルを作っても良い。多くのプロセスで
デバッグもログもできなければ、結果、混乱するだけである。
.\"O .IP
.\"O Some pty implementations may be confused by multiple readers and writers,
.\"O even momentarily.  Thus, it is safest to
.\"O .B fork
.\"O before spawning processes.
.IP
pty のインプリメンテーションの中には、複数の読み手と書き手が一瞬でもあれば、
混乱するものがある。それで、プロセスを spawn する前には
.B fork
しておくのが一番安全である。
.TP
.BI interact " [string1 body1] ... [stringn [bodyn]]"
.\"O gives control of the current process to the user, so that
.\"O keystrokes are sent to the current process,
.\"O and the stdout and stderr of the current process are returned.
は、現プロセスの制御をユーザーに渡す。結果、
現プロセスに送られたキーストロークと現プロセスの標準出力と標準エラー出力が
復帰する。
.IP
.\"O String-body pairs may be specified as arguments, in which case the
.\"O body is executed when the corresponding string is entered.  (By default, the
.\"O string is not sent to the current process.)   The
.\"O .B interpreter
.\"O command is assumed, if the final body is missing.
string と body の組が、引数として指示できる。(デフォルトでは、
文字列は現プロセスには送られない)
最後の body がないと、
.B interpreter
コマンドが実行される。
.IP
.\"O If the arguments to the entire
.\"O .B interact
.\"O statement require more than one line,
.\"O all the arguments may be "braced" into one so as to avoid terminating each
.\"O line with a backslash.  In this one case, the usual Tcl substitutions will
.\"O occur despite the braces.
.B interact
コマンド全体への引数が一行に収まらない場合、"brace"することで各行の終りに
バックスラッシュを入れるのを避けることができる。この場合、Tcl の展開は
ブレースしてあっても起こる。
.IP
.\"O For example, the following command runs interact with the following
.\"O string-body pairs defined:  When ^Z is pressed,
.\"O .B Expect
.\"O is suspended.
.\"O (The
.\"O .B \-reset
.\"O flag restores the terminal modes.)
.\"O When ^A is pressed, the user sees "you typed a control-A" and the
.\"O process is sent a ^A.  When $ is pressed, the user sees the date.
.\"O When ^C is pressed,
.\"O .B Expect
.\"O exits.  If "foo" is entered, the user sees "bar".
.\"O When ~~ is pressed, the
.\"O .B Expect
.\"O interpreter runs interactively.
例えば、以下のコマンドは続く string body の組と対話する。
: ^Z が押されると
.B Expect
はサスペンドする。
(
.B \-reset
フラグは、端末モードを復旧させる。)
^A が押されると、ユーザーには"you typed a control-A"が返る。
 $ が押されると、ユーザーには日付が返る。
^C が押されると、
.B Expect
は、exit する。
"foo"が入力されると、ユーザーに "bar" が返る。
~~ が押されると、
.B Expect
インタプリタは、対話モードになる。
.nf

.ta \w'    interact 'u +\w'$CTRLZ  'u +\w'{'u
    set CTRLZ \\032
    interact {
        -reset $CTRLZ {exec kill \-STOP [pid]}
        \\001   {send_user "you typed a control\-A\\n";
                send "\\001"
               }
        $      {send_user "The date is [exec date]."}
        \\003   exit
        foo    {send_user "bar"}
        ~~
    }

.fi
.IP
.\"O In string-body pairs, strings are matched in the order they are listed
.\"O as arguments.  Strings that partially match are not sent to the
.\"O current process in anticipation of the remainder coming.  If
.\"O characters are then entered such that there can no longer possibly be
.\"O a match, only the part of the string will be sent to the process that cannot
.\"O possibly begin another match.  Thus, strings that are substrings of
.\"O partial matches can match later, if the original strings that was attempting
.\"O to be match ultimately fails.
string と body の組で、string が引数として並べられた順に比較される。
部分的にマッチした文字列は、残りが到着するまで送られて来ない。
何文字かさらに打ち込まれて、マッチが可能になると、今のマッチを判断する
ためにだけ使われて他のマッチを始めることはしない。それゆえ、部分的に
マッチしている文字列のマッチが完了するのは遅れることがある。
部分的にはマッチするが最終的にはマッチしない文字列の場合などである。
.IP
.\"O By default, string matching is exact with no wild cards.  (In contrast,
.\"O the
.\"O .B expect
.\"O command uses glob-style patterns by default.)  The
.\"O .B \-ex
.\"O flag may be used to protect patterns that might otherwise match
.\"O .B interact
.\"O flags from doing so.
.\"O Any pattern beginning with a "-" should be protected this way.    (All strings
.\"O starting with "-" are reserved for future options.)
デフォルトでは、ワイルドカードを含まないマッチは、exactとなる。
(
.B expect
コマンドがデフォルトでグロブスタイルのパターンを用いるのとは対照的に。)
.B \-ex
フラグは、パターンをプロテクトするのに使える。
.B interact
フラグがそうするように。
パターンが"-"で始まる場合、この方法で保護できる。
("-"で始まる文字列は全て将来のオプションとして予約されている。)

.\"O The
.\"O .B \-re
.\"O flag forces the string to be interpreted as a regexp-style pattern.  In this
.\"O case, matching substrings are stored in the variable
.\"O .I interact_out
.\"O similarly to the way
.\"O .B expect
.\"O stores its output in the variable
.\"O .BR expect_out .
.\"O The
.\"O .B \-indices
.\"O flag is similarly supported.
.\"O 
.\"O The pattern
.\"O .B eof
.\"O introduces an action that is 
.\"O executed upon end-of-file.  A separate
.\"O .B eof
.\"O pattern may also follow the
.\"O .B \-output
.\"O flag in which case it is matched if an eof is detected while writing output.
.\"O The default
.\"O .B eof
.\"O action is "return", so that
.\"O .B interact
.\"O simply returns upon any EOF.
.\"O 
.\"O The pattern
.\"O .B timeout
.\"O introduces a timeout (in seconds) and action that is executed
.\"O after no characters have been read for a given time.
.\"O The
.\"O .B timeout
.\"O pattern applies to the most recently specified process.
.\"O There is no default timeout.
.\"O The special variable "timeout" (used by the
.\"O .B expect
.\"O command) has no affect on this timeout.
.B \-re
フラグは、正規表現スタイルのパターンとして文字列を解釈する。
この場合、マッチした部分文字列は
.I interact_out
に保存される。
.B expect
が、その出力を変数
.BR expect_out
に保存するのと似たようなものである。
.B \-indices
フラグも同じようにサポートされる。

パターン
.B eof
は、end-of-file にマッチした場合にアクションを実行する。
複数に分かれた
.B eof
パターンには
.B \-output
フラグが続いても良い。その場合、出力が書かれている間に eof が検出されると
アクションを実行する。
.B eof
のデフォルトアクションは"return"である。
それで、
.B interact
は、EOF を見つけると復帰する。

.B timeout
パターンは、(秒で表現された)タイムアウトにマッチし、アクションを実行する。
.B timeout
パターンは、最後に指示されたプロセスに適用される。タイムアウトには
デフォルトの値はない。(expect内で使われる)特殊な変数"timeout"は、
このタイムアウトと関係しない。

.\"O For example, the following statement could be used to autologout users who have
.\"O not typed anything for an hour but who still get frequent system
.\"O messages:
例えば、以下の記述は一時間以上タイプしなかったユーザーを自動的にログアウト
させる。その前にシステムから頻繁にメッセージを受けとる:
.nf

    interact -input $user_spawn_id timeout 3600 return -output \\
        $spawn_id 

.fi

.\"O If the pattern is the keyword
.\"O .BR null ,
.\"O and nulls are allowed (via the
.\"O .B remove_nulls
.\"O command), the corresponding body is executed if a single ASCII
.\"O 0 is matched.
.\"O It is not possible to
.\"O match 0 bytes via glob or regexp patterns.
.\"O 
.\"O Prefacing a pattern with the flag
.\"O .B \-iwrite
.\"O causes the variable
.\"O .I interact_out(spawn_id)
.\"O to be set to the spawn_id which matched the pattern
.\"O (or eof).
.\"O 
.\"O Actions such as
.\"O .B break
.\"O and
.\"O .B continue
.\"O cause control structures (i.e.,
.\"O .BR for ,
.\"O .BR proc )
.\"O to behave in the usual way.
.\"O However
.\"O .B return
.\"O causes interact to return to its caller, while
.\"O .B inter_return
.\"O causes
.\"O .B interact
.\"O to cause a return in its caller.  For example, if "proc foo" called
.\"O .B interact
.\"O which then executed the action
.\"O .BR inter_return ,
.\"O .B proc foo
.\"O would return.  (This means that if
.\"O .B interact
.\"O calls
.\"O .B interpreter
.\"O interactively typing
.\"O .B return
.\"O will cause the interact to continue, while
.\"O .B inter_return
.\"O will cause the interact to return to its caller.)
パターン
.BR null
と nulls は、(
.B remove_nulls
コマンドを通して)、アスキーの 0 にマッチした場合にアクションを実行する。
glob や regexp で 0 バイトにマッチさせることはできない。

このパターンの前に
.B \-iwrite
フラグをつけると、
変数
.I interact_out(spawn_id)
にパターン(あるいはeof)にマッチした spawn_id が設定される。

.B break
や
.B continue
といったアクションは、制御構造
(すなわち、
.BR for
や
.BR proc
)の中で、通常通りに動く。
しかし、
.B return
は、interact を呼出元に復帰させる。一方、
.B inter_return
は、
.B interact
をその呼びだし元内に復帰させる。例えば、"proc foo" は
.B interact
を呼ぶ。interact が、さらに、
.BR inter_return
を実行すると
.B proc foo
が復帰する。(これは、
.B interact
が、
.B interpreter
を呼んで
.B return
とタイプすると、そのinteractは継続するが、
.B inter_return
すると、その呼出元に復帰してしまうということである。)
.IP
.\"O During
.\"O .BR interact ,
.\"O raw mode is used so that all characters may be passed to the current process.
.\"O If the current process does not catch job control signals,
.\"O it will stop if sent a stop signal (by default ^Z).
.\"O To restart it, send a continue signal (such as by "kill \-CONT <pid>").
.\"O If you really want to send a SIGSTOP to such a process (by ^Z),
.\"O consider spawning csh first and then running your program.
.\"O On the other hand, if you want to send a SIGSTOP to
.\"O .B Expect
.\"O itself, first call interpreter (perhaps by using an escape character), and then press ^Z.
.BR interact
の間 raw モードが使用されるので、全ての文字が現プロセスに渡される。
現プロセスがジョブコントロールシグナルを捕まえなければ、
ストップシグナル(デフォルト^Z)で停止する。再スタートするには、
制御シグナルを送る。("kill \-CONT <pid>"とか打って)。
本当に SIGSTOP をプロセスに送りたいなら、csh を spawn してその上で
プロセスを起動すること。
そうでなくて、
.B Expect
そのものに SIGSTOP を送りたいなら、インタプリタを呼び出して
(普通はエスケープ文字)、その後 ^Z を打つこと。
.IP
.\"O String-body pairs can be used as a shorthand for avoiding having
.\"O to enter the interpreter and execute commands interactively.  The previous
.\"O terminal mode is used while the body of a string-body pair is being executed.
string bodyのペアは、インタプリタに入ってコマンドを対話的に実行するのを
避けることを簡単に書くのに使われる。
前の端末モードが、その body を実行する間使用される。
.IP
.\"O For speed, actions execute in raw mode by default.  The
.\"O .B \-reset
.\"O flag resets the terminal to the mode it had before
.\"O .B interact
.\"O was executed (invariably, cooked mode).
.\"O Note that characters entered when the mode is being switched may be lost
.\"O (an unfortunate feature of the terminal driver on some systems).
.\"O The only reason to use
.\"O .B \-reset
.\"O is if your action
.\"O depends on running in cooked mode.
実行速度を上げるには、デフォルトでアクションが raw モードで動くように
する。
.B \-reset
フラグは、端末の持っているモードをリセットする。そうしなければ、
その前に行なった
.B interact
コマンドの端末モード(cooked モードとか)が保持される。
モードが切り替わった時に、それまで打っていた文字が消えてしまうことが
あるので注意すること。(システムによっては、そういう不幸な仕様をした
端末ドライバが動いている。)
.B \-reset
を使うのは、アクションが cooked モードでしか動かない場合だけである。
.IP
.\"O The
.\"O .B \-echo
.\"O flag sends characters that match the following pattern back to the process
.\"O that generated them as each character is read.  This may be useful
.\"O when the user needs to see feedback from partially typed patterns.
.B \-echo
フラグは、一文字づつパターンにマッチする文字を返す。これは、
ユーザーが打つ文字に部分的にマッチしなければならない場合に有効である。
.IP
.\"O If a pattern is being echoed but eventually fails to match,
.\"O the characters are sent to the spawned process.  If the spawned
.\"O process then echoes them, the user will see the characters twice.
.\"O .B \-echo
.\"O is probably only appropriate in situations where the user is
.\"O unlikely to not complete the pattern.  For example, the following
.\"O excerpt is from rftp, the recursive-ftp script, where the user is
.\"O prompted to enter ~g, ~p, or ~l, to get, put, or list the current
.\"O directory recursively.  These are so far away from the normal ftp
.\"O commands, that the user is unlikely to type ~ followed by anything
.\"O else, except mistakenly, in which case, they'll probably just ignore
.\"O the result anyway.
パターンはエコーされたがマッチには失敗した場合、文字列は、spawn された
プロセスに送られる。それから、spawn されたプロセスが文字列を表示し、
ユーザーは文字列を二度見る。
.B \-echo
は、ユーザーがパターンを完成させてくれそうもない場合にだけ有効であろう。
例えば、以下は rftp(リカーシブ ftp スクリプト)からの抜粋だが、ユーザーが
~g, ~p, ~l を打つとカレントディレクトリから再帰的(リカーシブ)に get,
put, list する。通常の ftp ではこれらの操作ができない。間違って ~ を
打つか、~ の後を間違えた場合、その文字列を無視するようになっている。
.nf

    interact {
        -echo ~g {getcurdirectory 1}
        -echo ~l {getcurdirectory 0}
        -echo ~p {putcurdirectory}
    }

.fi
.\"O The
.\"O .B \-nobuffer
.\"O flag sends characters that match the following pattern on to
.\"O the output process as characters are read.
.\"O 
.\"O This is useful when you wish to let a program echo back the pattern.
.\"O For example, the following might be used to monitor where a person is
.\"O dialing (a Hayes-style modem).  Each time "atd" is seen the script
.\"O logs the rest of the line.
.\"O .nf
.\"O 
.\"O     proc lognumber {} {
.\"O         interact -nobuffer -re "(.*)\\r" return
.\"O         puts $log "[exec date]: dialed $interact_out(1,string)"
.\"O     }
.\"O 
.\"O     interact -nobuffer "atd" lognumber
.\"O 
.\"O .fi
.B \-nobuffer
フラグは、文字が読まれる度に、その文字をマッチへ送る。

このフラグは、パターンをエコーバックする時に有効である。
例えば、以下は誰かが(ヘイズモデムを)ダイアルするのを監視するのに
使われる。"atd"が見える度にスクリプトが残りのラインをログする。
.nf

    proc lognumber {} {
        interact -nobuffer -re "(.*)\\r" return
        puts $log "[exec date]: dialed $interact_out(1,string)"
    }

    interact -nobuffer "atd" lognumber

.fi
.IP
.\"O During
.\"O .BR interact ,
.\"O previous use of
.\"O .B log_user
.\"O is ignored.  In particular,
.\"O .B interact
.\"O will force its output to be logged (sent to the standard output)
.\"O since it is presumed the user doesn't wish to interact blindly.
.BR interact
の間、前に使った
.B log_user
は無視される。特に、
.B interact
は、その出力を記録される(標準出力に送られる)。
というのは、ユーザーはエコーバックのない状態でキーを打ちたくはない
だろうと考えるからである。
.IP
.\"O The
.\"O .B \-o
.\"O flag causes any following key-body pairs to be applied to the output of
.\"O the current process.
.\"O This can be useful, for example, when dealing with hosts that
.\"O send unwanted characters during a telnet session.  
.B \-o
フラグは、現プロセスの出力に key body ペアの key を結びつける。
こんな場合に便利である。例えば、telnet セッション中に望まない文字を
送ってくるホストを扱う場合である。
.IP
.\"O By default, 
.\"O .B interact
.\"O expects the user to be writing stdin and reading stdout of the
.\"O .B Expect
.\"O process
.\"O itself.
.\"O The
.\"O .B \-u
.\"O flag (for "user") makes
.\"O .B interact
.\"O look for the user as the process named by its argument
.\"O (which must be a spawned id).  
デフォルトでは、
.B interact
は、ユーザーが
.B Expect
プロセス自身の標準入力に書き込み、標準出力を見ていると思っている。
.B \-u
フラグ("user"のu)は
.B interact
に、引数で付けられた名前(spawned id である)のプロセスをユーザーとして
扱う。
.IP
.\"O This allows two unrelated processes to be joined
.\"O together without using an explicit loop.  To aid in debugging, Expect
.\"O diagnostics always go to stderr (or stdout for certain logging and
.\"O debugging information).  For the same reason, the
.\"O .B interpreter
.\"O command will read interactively from stdin.
これにより、変なループなしに2つの無関係なプロセスを結合させることが
できる。デバッグする時の助けとして、Expect は常に診断結果を stderr
へ送る。(ある種のログとデバッグ情報は stdout に送られる)。
同じ理由で、
.B interpreter
コマンドは、stdin からデータを読む。
.IP
.\"O For example, the following fragment creates a login process.
.\"O Then it dials the user (not shown), and finally connects the two together.
.\"O Of course, any process may be substituted for login.
.\"O A shell, for example, would allow the user to work without supplying an
.\"O account and password.
例えば、以下の断片はログインプロセスを作る。そして、(表示されない)
ユーザーにダイアルし、両方の接続を行なう。
もちろん、loginをどんなプロセスに変えても良い。例えば、シェルなら、ア
カウントとパスワードを与えなくてもユーザーが起動できる。
.nf

    spawn login
    set login $spawn_id
    spawn tip modem
    # dial back out to user
    # connect user to login
    interact \-u $login

.fi
.\"O To send output to multiple processes, list each spawn id list prefaced by a
.\"O .B \-output
.\"O flag.  Input for a group of output spawn ids may be determined
.\"O by a spawn id list prefaced by a
.\"O .B \-input
.\"O flag.  (Both
.\"O .B \-input
.\"O and
.\"O .B \-output
.\"O may take lists in the same form as the
.\"O .B \-i
.\"O flag in the
.\"O .B expect
.\"O command, except that any_spawn_id is not meaningful in
.\"O .BR interact .)
.\"O All following flags and
.\"O strings (or patterns) apply to this input until another -input flag appears.
.\"O If no
.\"O .B \-input
.\"O appears,
.\"O .B \-output
.\"O implies "\-input $user_spawn_id \-output".
.\"O (Similarly, with patterns that do not have
.\"O .BR \-input .)
.\"O If one
.\"O .B \-input
.\"O is specified, it overrides $user_spawn_id.  If a second
.\"O .B \-input
.\"O is specified,
.\"O it overrides $spawn_id.  Additional
.\"O .B \-input
.\"O flags may be specified.
.\"O 
.\"O The two implied input processes default to having their outputs specified as
.\"O $spawn_id and $user_spawn_id (in reverse).  
.\"O If a
.\"O .B \-input
.\"O flag appears
.\"O with no
.\"O .B \-output
.\"O flag, characters from that process are discarded.
.\"O 
.\"O The
.\"O .B \-i
.\"O flag introduces a replacement for the current spawn_id when no
.\"O other
.\"O .B \-input
.\"O or
.\"O .B \-output
.\"O flags are used.  A \-i flag implies a \-o flag.
.\"O 
複数のプロセスへの出力を行なうため、
.B \-output
フラグを前につけた各 spawn id のセットがリストされる。
出力 spawn id の組への入力は、
.B \-input
フラグによって決定される。
(
.B \-input
と
.B \-output
フラグは両方とも
.B expect
コマンドの
.B \-i
フラグと同じ書式である。(
.BR interact
内の any_spawn_id は意味がない点を除く。)
以下のフラグと文字列(あるいはパターン)は全て、別の -input フラグが現れるまで
この入力を適用する。
.B \-input
が現れなかった場合、
.B \-output
は "\-input $user_spawn_id \-output"
を行なう。
(
.BR \-input
を持たないパターンも同様である。)
.B \-input
が一つだけ指示されると、$user_spawn_id はその値で置き換わる。
二つめの
.B \-input
が指示されると、$spawn_id が置き換わる。
以降の
.B \-input
フラグも指定できる。

2つの入力プロセスはデフォルトで $spawn_id と $user_spawn_id に出力される。
もし、
.B \-input
フラグが
.B \-output
フラグなしで指定された場合、プロセスからの文字は捨てられる。

.B \-i
フラグは、現在の spawn_id を書き換える。
ただし、
.B \-input
または
.B \-output
フラグが使われていない場合である。\-i フラグは \-o フラグを含む。

.\"O It is possible to change the processes that are being interacted with
.\"O by using indirect spawn ids.  (Indirect spawn ids are described in the
.\"O section on the expect command.)  Indirect spawn ids may be specified
.\"O with the -i, -u, -input, or -output flags.
間接 spawn id を使って会話しているプロセスを切替えることが可能である。
(間接 spawn id は、expect コマンドの項で説明した)
間接 spawn id は、-i, -u, -input, -output フラグで指定できる。
.TP
.B interpreter " [args]"
.\"O causes the user to be interactively prompted for
.\"O .B Expect
.\"O and Tcl commands.
.\"O The result of each command is printed.
は、ユーザーに
.B Expect
と Tcl コマンドのためのプロンプトを表示する。
各コマンドの結果が表示される。
.IP
.\"O Actions such as
.\"O .B break
.\"O and
.\"O .B continue
.\"O cause control structures (i.e.,
.\"O .BR for ,
.\"O .BR proc )
.\"O to behave in the usual way.
.\"O However
.\"O .B return
.\"O causes interpreter to return to its caller, while
.\"O .B inter_return
.\"O causes
.\"O .B interpreter
.\"O to cause a return in its caller.  For example, if "proc foo" called
.\"O .B interpreter
.\"O which then executed the action
.\"O .BR inter_return ,
.\"O .B proc foo
.\"O would return.
.\"O Any other command causes
.\"O .B interpreter
.\"O to continue prompting for new commands.
.B break
や
.B continue
は制御構造(すなわち、
.BR for
.BR proc
)で、通常通りに動く。
しかし、
.B return
は、呼出元への復帰を行なうのに対し、
.B inter_return
は
.B interpreter
を、呼出元を復帰させる。たとえば、
"proc foo" は、
.B interpreter
を呼び、
.BR inter_return
を実行し
.B proc foo
が復帰する。
他のコマンドは
.B interpreter
に新しいコマンドのためのプロンプトを表示し続ける。
.IP
.\"O By default, the prompt contains two integers.
.\"O The first integer describes the depth of
.\"O the evaluation stack (i.e., how many times Tcl_Eval has been called).  The
.\"O second integer is the Tcl history identifier.  The prompt can be set by
.\"O defining a procedure called "prompt1" whose return value becomes the next
.\"O prompt.  If a statement has open quotes, parens, braces, or brackets, a
.\"O secondary prompt (by default "+> ") is issued upon newline.  The secondary
.\"O prompt may be set by defining a procedure called "prompt2".
デフォルトでは、プロンプトは 2 つの整数を含んでいる。
最初の数は評価スタックの深さ(つまり、何回 Tcl_Eval が呼ばれたか)
2番めの数は、Tcl ヒストリ識別番号である。プロンプトは
"prompt1"と呼ばれるプロシジャを定義することで設定できる。
このプロシジャの帰り値が次のプロンプトとなる。
記述に開きクオート、括弧、ブレース、ブラケットがあると、次の行には
第 2 プロンプトが現れる(デフォルトは "+> ")。第 2 プロンプトは
"prompt2"と呼ばれるプロシジャを定義することで設定できる。
.IP
.\"O During
.\"O .BR interpreter ,
.\"O cooked mode is used, even if the its caller was using raw mode.
.BR interpreter
の間は、呼出元が raw モードであったとしても、cooked モードが使われる。
.IP
.\"O If stdin is closed,
.\"O .B interpreter
.\"O will return unless the
.\"O .B \-eof
.\"O flag is used, in which case the subsequent argument is invoked.
stdin が閉じられると、
.B interpreter
は
.B \-eof
フラグが使われていない限り復帰する。
使われている場合は引き続く引数を実行する。
.TP
.BI log_file " [args] [[\-a] file]"
.\"O or
.\"O .B \-leaveopen
.\"O flags.  This is similar to the
.\"O .B spawn
.\"O command.  (See
.\"O .B spawn
.\"O for more info.)
.\"O 
.\"O The
.\"O .B \-a
.\"O flag forces output to be logged that was suppressed by the
.\"O .B log_user
.\"O command.
.\"O 
.\"O By default, the
.\"O .B log_file
.\"O command
.\"O .I appends
.\"O to old files rather than truncating them,
.\"O for the convenience of being able to turn logging off and on multiple
.\"O times in one session.
.\"O To truncate files, use the
.\"O .B \-noappend
.\"O flag.
.\"O 
.\"O The
.\"O .B -info
.\"O flag causes log_file to return a description of the
.\"O most recent non-info arguments given.
ファイル名が与えられると、
.B log_file
は、(現時点からの)セッションのログをそのファイルに採取する。
引数がなければ、
.B log_file
は記録をやめる。使っていたログファイルはクローズされる。

ファイル名の代わりに、Tcl ファイル識別子を指定すると、
.B \-open
や
.B \-leaveopen
フラグが使える。
.B spawn
コマンドと同様だ(より詳しくは、
.B spawn
を参照)

.B \-a
フラグは、
.B log_user
コマンドによって抑止されたログに出力を強制するものである。

デフォルトでは、
.B log_file
コマンドは古い記録を消して書き直したりせずに
.I 追記
する。
ログオフや複数のログを書く時に都合が良いように。
ファイルを消して書き直す時は
.B \-noappend
フラグを使う。

.B -info
フラグは、最後にログした内容を返す(最後が-infoフラグ付きだったら、
その前の内容)。
.TP
.BI log_user " -info|0|1"
.\"O By default, the send/expect dialogue is logged to stdout
.\"O (and a logfile if open).
.\"O The logging to stdout is disabled by the command "log_user 0"
.\"O and reenabled by "log_user 1".  Logging to the logfile is unchanged.
デフォルトでは、send/expect ダイアログは標準出力にロギングされる。
(開いていればログファイルにもロギングされる。)
"log_user 0"とすると、標準出力へのロギングが抑止される。
"log_user 1"とすると、復旧する。ログファイルへの記録については
変更はない。

.\"O The
.\"O .B -info
.\"O flag causes log_user to return a description of the
.\"O most recent non-info arguments given.
.B -info
フラグは、最後にログした内容を返す(最後が -info フラグ付きだったら、
その前の内容)。
.TP
.BI match_max " [\-d] [\-i spawn_id] [size]"
.\"O defines the size of the buffer (in bytes) used internally by
.\"O .BR expect .
.\"O With no
.\"O .I size
.\"O argument, the current size is returned.
は、バッファサイズを(バイト単位で)定義する。このバッファは、
.BR expect
の内部で使われる。
引数
.I size
がないと、現在のサイズを復帰する。
.\"O .IP
.\"O With the
.\"O .B \-d
.\"O flag, the default size is set.  (The initial default is 2000.)
.\"O With the
.\"O .B \-i
.\"O flag, the size is set for the named spawn id, otherwise it is set for
.\"O the current process.
.IP
.B \-d
フラグを指示すると、デフォルトサイズが設定される。(初期状態の
デフォルト値は 2000。)
.B \-i
フラグを指示すると、名前つき spawn id に対してサイズが設定される。
指定しなければ、カレントプロセスに対して設定される。
.TP
.BI overlay " [\-# spawn_id] [\-# spawn_id] [...] program [args]"
.\"O executes
.\"O .IR "program args"
.\"O in place of the current
.\"O .B Expect
.\"O program, which terminates.
.\"O A bare hyphen argument forces a hyphen in front of the command name as if
.\"O it was a login shell.
.\"O All spawn_ids are closed except for those named as arguments.  These
.\"O are mapped onto the named file identifiers.
は、
.IR "program args"
を現在の
.B Expect
プログラム上で実行する。現在の Expect プログラムは終了する。
ただのハイフンが引数に指定されると、コマンド名の前にハイフンをつけて
ログインシェルとして扱う。
全てのクローズ中の spawn_id は、引数に使われた文字列を待つ。
.IP
.\"O Spawn_ids are mapped to file identifiers for the new program to inherit.
.\"O For example, the following line runs chess and allows it to be
.\"O controlled by the current process \- say, a chess master.
Spawn_id は、新しいプログラムに継承させるためのファイル ID に
マップされる。例えば、以下の行はチェスを行ない、chess master
という現プロセスに制御させる。
.nf

    overlay \-0 $spawn_id \-1 $spawn_id \-2 $spawn_id chess

.fi
.\"O This is more efficient than
.\"O "interact \-u", however, it sacrifices the ability to do programmed
.\"O interaction since the
.\"O .B Expect
.\"O process is no longer in control.
.\"O .IP
.\"O Note that no controlling terminal is provided.  Thus, if you
.\"O disconnect or remap standard input, programs that do
.\"O job control (shells, login, etc) will not function properly.
これは、
"interact \-u"
とするよりも効果的である。しかし、
.B Expect
プロセスが制御していないのでプログラム能力が犠牲となる。
.IP
制御されない端末ができてしまうことに注意すること。それで、
disconnect するか標準入力をリマップするとジョブ制御プログラム
(シェル、ログインなど)が正しく機能しない。
.TP
.BI parity " [\-d] [\-i spawn_id] [value]"
.\"O defines whether parity should be retained or stripped from the output of
.\"O spawned processes.  If
.\"O .I value
.\"O is zero, parity is stripped, otherwise it is not stripped.
.\"O With no
.\"O .I value
.\"O argument, the current value is returned.
.\"O .IP
.\"O With the
.\"O .B \-d
.\"O flag, the default parity value is set.  (The initial default is 1, i.e., 
.\"O parity is not stripped.)
.\"O With the
.\"O .B \-i
.\"O flag, the parity value is set for the named spawn id, otherwise it is set for
.\"O the current process.
は、spawn idの出力からパリティを保持するか取り除くかを設定する。
.I value
が 0 であれば、パリティは取り除かれる。
それ以外の場合、取り除かれない。
.I value
が指定されない場合、現在の値が復帰する。
.IP
.B \-d
フラグは、パリティのデフォルト値を設定する。(イニシャル時のデフォルト値は
1 である。すなわち、パリティが取り除かれる。)
.B \-i
フラグを指示すると、パリティの値が引数の名前つきの spawn id に対して
設定される。引数がなければ現在のプロセスに対して設定される。
.TP
.BI remove_nulls " [\-d] [\-i spawn_id] [value]"
.\"O .I value
.\"O is 1, nulls are removed.  If
.\"O .I value
.\"O is 0, nulls are not removed.
.\"O With no
.\"O .I value
.\"O argument, the current value is returned.
.\"O .IP
.\"O With the
.\"O .B \-d
.\"O flag, the default value is set.  (The initial default is 1, i.e., 
.\"O nulls are removed.)
.\"O With the
.\"O .B \-i
.\"O flag, the value is set for the named spawn id, otherwise it is set for
.\"O the current process.
.\"O 
.\"O Whether or not nulls are removed,
.\"O .B Expect
.\"O will record null bytes to the log and stdout.
は、前にパターンマッチしたあるいは
.I expect_out 
か
.IR interact_out
に保存されている spawn されたプロセスの出力からヌルを保持するか取り除くかを
設定する。
.I value
が 1 なら、ヌルは取り除かれる。もし、
.I value
が 0 なら、ヌルは取り除かれる。
.I value
がなければ、現在の値が復帰する。
.IP
.B \-d
フラグは、デフォルト値を設定する。(イニシャルのデフォルト値は、
1 である。それゆえ、ヌルは取り除かれる。)
.B \-i
フラグは、名前つきの spawn id に対して値を設定する。なければ、
現プロセスに対して設定する。

ヌルを取り除くかどうかによらず、
.B Expect
は、ログと標準出力にはヌルが記録される。
.TP
.BI send " [\-flags] string"
.\"O Sends
.\"O .IR string
.\"O to the current process.
.IR string
を現プロセスに送る。
.\"O For example, the command
例えば、以下のコマンド:
.nf

    send "hello world\\r"

.fi
.\"O sends the characters, h e l l o <blank> w o r l d <return> to the 
.\"O current process.  
.\"O (Tcl includes a printf-like command (called
.\"O .BR format )
.\"O which can build arbitrarily complex strings.)
は、文字 h e l l o <blank> w o r l d <return>  を現在のプロセスに
送る。
(Tcl は、printf に似たコマンド (
.BR format
と呼ばれる )を持っていて、複雑な文字列を組み立てることができる。)
.IP
.\"O Characters are sent immediately although programs with line-buffered input
.\"O will not read the characters until a return character is sent.  A return
.\"O character is denoted "\\r".
.\"O 
.\"O The
.\"O .B \-\-
.\"O flag forces the next argument to be interpreted as a string rather than a flag.
.\"O Any string can be preceded by "\-\-" whether or not it actually looks
.\"O like a flag.  This provides a reliable mechanism to specify variable strings
.\"O without being tripped up by those that accidentally look like flags.
.\"O (All strings starting with "-" are reserved for future options.)
.\"O 
.\"O The
.\"O .B \-i
.\"O flag declares that the string be sent to the named spawn_id.
.\"O If the spawn_id is
.\"O .IR user_spawn_id ,
.\"O and the terminal is in raw mode, newlines in the string are translated
.\"O to return-newline
.\"O sequences so that they appear as if the terminal was in cooked mode.
.\"O The
.\"O .B \-raw
.\"O flag disables this translation.
.\"O 
.\"O The
.\"O .BR \-null
.\"O flag sends null characters (0 bytes).  By default, one null is sent.
.\"O An integer may follow the
.\"O .BR \-null
.\"O to indicate how many nulls to send.
.\"O 
.\"O The
.\"O .B \-break
.\"O flag generates a break condition.  This only makes sense if the spawn
.\"O id refers to a tty device opened via "spawn -open".  If you have
.\"O spawned a process such as tip, you should use tip's convention for
.\"O generating a break.
.\"O 
.\"O The
.\"O .B \-s
.\"O flag forces output to be sent "slowly", thus avoid the common situation
.\"O where a computer outtypes an input buffer that was designed for a
.\"O human who would never outtype the same buffer.  This output is
.\"O controlled by the value of the variable "send_slow" which takes a two
.\"O element list.  The first element is an integer that describes the
.\"O number of bytes to send atomically.  The second element is a real
.\"O number that describes the number of seconds by which the atomic sends
.\"O must be separated.  For example, "set send_slow {10 .001}" would force
.\"O "send \-s" to send strings with 1 millisecond in between each 10
.\"O characters sent.
.\"O 
.\"O The
.\"O .B \-h
.\"O flag forces output to be sent (somewhat) like a human actually typing.
.\"O Human-like delays appear between the characters.  (The algorithm is
.\"O based upon a Weibull distribution, with modifications to suit this
.\"O particular application.)  This output is controlled by the value of
.\"O the variable "send_human" which takes a five element list.  The first
.\"O two elements are average interarrival time of characters in seconds.
.\"O The first is used by default.  The second is used at word endings, to
.\"O simulate the subtle pauses that occasionally occur at such
.\"O transitions.  The third parameter is a measure of variability where .1
.\"O is quite variable, 1 is reasonably variable, and 10 is quite
.\"O invariable.  The extremes are 0 to infinity.  The last two parameters
.\"O are, respectively, a minimum and maximum interarrival time.
.\"O The minimum and maximum are used last and "clip" the final time.
.\"O The ultimate average can be quite different from the given average
.\"O if the minimum and maximum clip enough values.
文字は直ちに送られる。ただし、入力にラインバッファのあるプログラムでは、
リターンコードが送られるまで文字が読まれない。リターンコードは、
"\\r"と表記する。

.B \-\-
フラグは、続く引数をフラグと解釈せず文字列として解釈される。
全体としてフラグに見えなくても"\-\-"が前についた文字列はフラグとして
扱われてしまう。このフラグは処理されていない文字列がフラグとして
扱われるのを防ぐ。
("-"で始まる文字は全て将来のオプションとして予約されている。)

.B \-i
フラグは、名前つきの spawn_id に文字列を送ることを宣言する。
その spawn_id が
.IR user_spawn_id
であれば、端末はraw モードに入り、文字列中の改行が復帰改行シーケンスに
変換される。それで、外からは 端末が cooked モードとなっているように
見える。
.B \-raw
フラグは、この変換を抑止する。

.BR \-null
フラグは、ヌル文字を送る(0 バイト)。デフォルトでは、ヌル文字を
1つ送る。
.BR \-null
に続く整数はヌル文字をいくつ送るかを指示する。

.B \-break
フラグは、ブレーク状態を作る。spawn id が"spawn -open"で指示した
tty デバイスを参照する場合のみ意味がある。tip などのプロセスを
spawn する場合、tip の都合で ブレーク状態を作るべきである。

.B \-s
フラグは、出力を強制的に"遅く"する。結果、コンピュータが打ち込んでいる
バッファに人間が打ち込んでしまう状況を避けることができる。この出力は
変数"send_slow"の値で制御される。この変数は二つの要素を持つリストである。
最初の要素は、アトミックに送るバイト数である。2 番めの要素はアトミックに送る
間隔(秒)である。例えば、 "set send_slow {10 .001}" は "send \-s" に 
10 文字送る毎に1ミリ秒待つように指示する。

.B \-h
フラグは、人間の実際の入力に似せて send を行なう。(アルゴリズムは、
Weibull distribution に基づいていて、この特定のアプリケーション Expect? に
合わせるための修正が行なわれている。)
この出力は変数"send_human"の値で制御されていて、この変数は 5 つの要素から
なるリストで最初の 2 つの要素は文字間の平均インターバル時間(秒)である。
1 つめがデフォルト値で、2 つめが(通常発生する微妙な待ち時間を表現する)
単語の終りの値である。3 つめの要素は変動率である。
.1 はよく変動する。 1 は妥当な変動率である。 10 だと全然変化しない。
可能な値は 0 から 無限大である。最後の 2 つのパラメタは、それぞれ、
インターバル時間の最小値と最大値である。この 2 つの値は最後に使われて、
最終時刻をクリップする。この 2 値が違うと究極の平均は与えられた平均とは、
全く違ったものになる。

.\"O As an
.\"O example, the following command emulates a fast and
.\"O consistent typist:
例として、続くコマンドが一定の速度で速く打つタイピストを
エミュレートする:
.nf

    set send_human {.1 .3 1 .05 2}
    send \-h "I'm hungry.  Let's do lunch."

.fi
.\"O while the following might be more suitable after a hangover:
ハングさせてしまった後は、以下のようにした方が良いだろう。:
.nf

    set send_human {.4 .4 .2 .5 100}
    send \-h "Goodd party lash night!"

.fi
.\"O Note that errors are not simulated, although you can set up error
.\"O correction situations yourself by embedding mistakes and corrections
.\"O in a send argument.
.\"O 
.\"O The flags for sending null characters, for sending breaks, for forcing slow
.\"O output and for human-style output are mutually exclusive. Only the one
.\"O specified last will be used. Furthermore, no
.\"O .I string
.\"O argument can be specified with the flags for sending null characters or breaks.
.\"O 
.\"O It is a good idea to precede the first
.\"O .B send
.\"O to a process by an
.\"O .BR expect .
.\"O .B expect
.\"O will wait for the process to start, while
.\"O .B send
.\"O cannot.
.\"O In particular, if the first
.\"O .B send
.\"O completes before the process starts running,
.\"O you run the risk of having your data ignored.
.\"O In situations where interactive programs offer no initial prompt,
.\"O you can precede
.\"O .B send
.\"O by a delay as in:
send にエラーや修正を埋め込んであっても、
エラーはシミュレートされない点に注意すること。

ブレークを送るためや、ゆっくりした出力を行なったり、人間が出力したように
見せかけるためにヌル文字を送るフラグは相互排他される。
最後に指定されたものだけが使われる。それ以上は、
.I string
の引数が、ヌル文字あるいはブレークを送るフラグとして指定できる。

最初の
.B send
より前に
.B expect
を置いた方が良い。
.B expect
は、プロセスが始まるのを待てるが、
.B send
は待てない。
特に、最初の
.B send
は、プロセスが走り始める前に完了する。あなたのデータが無視される
危険がある。
最初にプロンプトを表示しないような対話的なプログラムでは、
次のように
.B send
の前にディレイをつけることができる:
.nf

.\"O     # To avoid giving hackers hints on how to break in,
.\"O     # this system does not prompt for an external password.
.\"O     # Wait for 5 seconds for exec to complete
    # どのように破るかのヒントをハッカーに与えてしまわないように、
    # このシステムでは外部のパスワードに対するプロンプトを提供しない。
    # exec が完了するのを 5 秒待て。
    spawn telnet very.secure.gov
    sleep 5
    send password\\r

.fi
.\"O .B exp_send
.\"O is an alias for
.\"O .BI send .
.\"O If you are using Expectk or some other variant of Expect in the Tk environment,
.\"O .B send
.\"O is defined by Tk for an entirely different purpose.
.\"O .B exp_send
.\"O is provided for compatibility between environments.
.\"O Similar aliases are provided for other Expect's other send commands.
.B exp_send
は
.B send
のエイリアスである。あなたが Expectk か、Tk 環境で動く Expect の他の変種を
使っている場合、
.B send
は、全く異なった目的のために使われている。
.B exp_send
が、両環境の間での互換性のために提供されている。
似たようなエイリアスが他の Expect の他の send コマンドのために提供されている。
.TP
.BI send_error " [\-flags] string"
.\"O is like
.\"O .BR send ,
.\"O except that the output is sent to stderr rather than the current
.\"O process.
.BR send
と似たようなもので、現プロセスでなく stderr に出力される。
.TP
.BI send_log " [\--] string"
.\"O is like
.\"O .BR send ,
.\"O except that the string is only sent to the log file (see
.\"O .BR log_file .)
.\"O The arguments are ignored if no log file is open.
.BR send
と似たようなもので、ログファイルだけに string を送る。(
.BR log_file
を参照。) 引数はログファイルが open されていなければ無視される。
.TP
.BI send_tty " [\-flags] string"
.\"O is like
.\"O .BR send ,
.\"O except that the output is sent to /dev/tty rather than the current
.\"O process.
.BR send
と似たようなもので、現プロセスでなく /dev/tty へ出力を送る。
.TP
.BI send_user " [\-flags] string"
.\"O except that the output is sent to stdout rather than the current
.\"O process.
.BR send
と似たようなもので、現プロセスでなく標準出力へ出力を送る。
.TP
.BI sleep " seconds"
.\"O causes the script to sleep for the given number of seconds.
.\"O Seconds may be a decimal number.  Interrupts (and Tk events if you
.\"O are using Expectk) are processed while Expect sleeps.
は、与えられた数字の秒数だけスクリプトがスリープする。
seconds は、10進数だけが許される。
(Expectk を使っている場合、Tkのイベントと)割り込みは、Expectが
スリープしている間も処理される。
.TP
.BI spawn " [args] program [args]"
.\"O The process described by
.\"O .I spawn_id
.\"O is considered the
.\"O .IR "current process" .
.\"O .I spawn_id
.\"O may be read or written, in effect providing job control.
.IR "program args"
を走らせる新しいプロセスを生成する。その標準入力と標準出力は
Expect に結びつけられる。それで、他の
.B Expect
コマンドで読んだり書いたりできる。
接続は
.B close
によって、あるいは、プロセスそのものがファイル ID の
いずれかをクローズした場合、破壊される。
.IP
プロセスは
.BR spawn
によって始められる。変数
.I spawn_id
には、そのプロセスへの参照を行なう識別子が設定される。
.I spawn_id
によって記述されるプロセスは
.IR "current process"
が考慮される。
.I spawn_id
は、読んでも書いても良く、効果的なジョブ制御を提供する。
.\"O .IP
.\"O .I user_spawn_id
.\"O is a global variable containing a descriptor which refers to the user.
.\"O For example, when
.\"O .I spawn_id
.\"O is set to this value,
.\"O .B expect
.\"O behaves like
.\"O .BR expect_user .
.\"O 
.\"O .I
.\"O .I error_spawn_id
.\"O is a global variable containing a descriptor which refers to the standard
.\"O error.
.\"O For example, when
.\"O .I spawn_id
.\"O is set to this value,
.\"O .B send
.\"O behaves like
.\"O .BR send_error .
.IP
.I user_spawn_id
はユーザーを参照する識別子の入ったグローバル変数である。
例えば、
.I spawn_id
が、この値に設定された場合、
.B expect
は、
.BR expect_user
のような動きをする。

.I
.I error_spawn_id
は、標準エラー出力を参照する識別子の入ったグローバル変数である。
例えば、
.I spawn_id
が、この値に設定された場合、
.B send
は、
.BR send_error
のような動きをする。
.IP
.\"O .I tty_spawn_id
.\"O is a global variable containing a descriptor which refers to /dev/tty.
.\"O If /dev/tty does not exist (such as in a cron, at, or batch script), then
.\"O .I tty_spawn_id
.\"O is not defined.  This may be tested as:
.I tty_spawn_id
は、/dev/tty を参照する識別子の入ったグローバル変数である。
/dev/tty が存在しない(cron, at, バッチスクリプトの中)場合、
.I tty_spawn_id
は定義されない。以下のように確認することができる。:
.nf

    if {[info vars tty_spawn_id]} {
        # /dev/tty exists
    } else {
        # /dev/tty doesn't exist
        # probably in cron, batch, or at script
    }

.fi
.IP
.\"O .B spawn
.\"O returns the UNIX process id.  If no process is spawned, 0 is returned.
.\"O The variable
.\"O .I spawn_out(slave,name)
.\"O is set to the name of the pty slave device.
.B spawn
UNIX プロセス ID を復帰する。spawn されたプロセスがない場合、0 が
復帰する。変数
.I spawn_out(slave,name)
は pty スレーブデバイスの名前に設定される。
.IP
.\"O By default,
.\"O .B spawn
.\"O echoes the command name and arguments.  The
.\"O .B \-noecho
.\"O flag stops
.\"O .B spawn
.\"O from doing this.
デフォルトでは、
.B spawn
はコマンド名と引数をエコーする。
.B \-noecho
フラグで
.B spawn
がこうするのを止められる。
.IP
.\"O The
.\"O .B \-console
.\"O flag causes console output to be redirected to the spawned process.
.\"O This is not supported on all systems.
.\"O 
.\"O Internally,
.\"O .B spawn
.\"O uses a pty, initialized the same way as the user's tty.  This is further
.\"O initialized so that all settings are "sane" (according to stty(1)).
.\"O If the variable
.\"O .I stty_init
.\"O is defined, it is interpreted in the style of stty arguments
.\"O as further configuration.
.\"O For example, "set stty_init raw" will cause further spawned processes's
.\"O terminals to start in raw mode.
.\"O .B \-nottycopy
.\"O skips the initialization based on the user's tty.
.\"O .B \-nottyinit
.\"O skips the "sane" initialization.
.B \-console
フラグは、コンソールへの出力を起こし、spawn されたプロセスへの
リダイレクトされる。この機能は未サポートのシステムがある。

内部的に、
.B spawn
は pty を使い、ユーザーの tty と同じように初期化される。これは、かなり
初期化してしまうので全ての設定が (stty(1)によると) "正常(sane)" になる。
変数
.I stty_init
が定義されていると、stty の引数の形式を解釈できるので、より詳細な設定を
行なえる。例えば、
"set stty_init raw"
は、以降 spawn されたプロセスの端末を raw モードで開始する。
.B \-nottycopy
は、ユーザーの tty に基づいた初期化を飛ばす。
.B \-nottyinit
は、"正常な"初期化を飛ばす。
.IP
.\"O Normally,
.\"O .B spawn
.\"O takes little time to execute.  If you notice spawn taking a
.\"O significant amount of time, it is probably encountering ptys that are
.\"O wedged.  A number of tests are run on ptys to avoid entanglements with
.\"O errant processes.  (These take 10 seconds per wedged pty.)  Running
.\"O Expect with the
.\"O .B \-d
.\"O option will show if
.\"O .B Expect
.\"O is encountering many ptys in odd states.  If you cannot kill
.\"O the processes to which these ptys are attached, your only recourse may
.\"O be to reboot.
普通、
.B spawn
は、実行するのにわずかの時間しかかからない。spawn に時間をかけたいので
あれば、おそらく割り込まれた pty に遭遇するだろう。たくさんのテストが
間違ったプロセスに掛かり合うことを避けることができる。
(割り込まれた pty につき、10 秒かかる。)
.B \-d
オプションをつけて Expect を走らせると、
.B Expect
がおかしな状態のたくさんの pty に遭遇しているかどうかが表示される。
これらの pty がつながっているためにプロセスを殺せない場合、リブートするしか
頼れる復旧手段はない。

.\"O If
.\"O .I program
.\"O cannot be spawned successfully because exec(2) fails (e.g. when
.\"O .I program
.\"O doesn't exist), an error message will be returned by the next
.\"O .B interact
.\"O or
.\"O .B expect
.\"O command as if
.\"O .I program
.\"O had run and produced the error message as output.
.\"O This behavior is a natural consequence of the implementation of
.\"O .BR spawn .
.\"O Internally, spawn forks, after which the spawned process has no
.\"O way to communicate with the original
.\"O .B Expect
.\"O process except by communication
.\"O via the spawn_id.
exec(2)が失敗して
.I program
が spawn に成功しなかった場合
(例えば、
.I program
がなかった場合など)、エラーメッセージが次の
.B interact
か
.B expect
コマンドで復帰する。つまり。
.I program
が、出力としてエラーメッセージを出しているように見せる。
この動作は、
.BR spawn
の実装の自然な帰結である。内部で、spawn がフォークされ、その後、
spawn されたプロセスがオリジナルの
.B Expect
プロセスとその spawn_id で会話を行なう。

.\"O The
.\"O .B \-open
.\"O flag causes the next argument to be interpreted as a Tcl file identifier
.\"O (i.e., returned by
.\"O .BR open .)
.\"O The spawn id can then be used as if it were a spawned process.  (The file
.\"O identifier should no longer be used.)
.\"O This lets you treat raw devices, files, and
.\"O pipelines as spawned processes without using a pty.  0 is returned to
.\"O indicate there is no associated process.  When the connection to
.\"O the spawned process is closed, so is the Tcl file identifier.
.\"O The
.\"O .B \-leaveopen
.\"O flag is similar to
.\"O .B \-open
.\"O except that
.\"O .B \-leaveopen
.\"O causes the file identifier to be left open even after the spawn id is closed.
.\"O 
.\"O The
.\"O .B \-pty
.\"O flag causes a pty to be opened but no process spawned.  0 is returned
.\"O to indicate there is no associated process.  Spawn_id is set as usual.
.\"O 
.\"O The variable
.\"O .I spawn_out(slave,fd)
.\"O is set to a file identifier corresponding to the pty slave.
.\"O It can be closed using "close -slave".
.\"O 
.\"O The
.\"O .B \-ignore
.\"O flag names a signal to be ignored in the spawned process.
.\"O Otherwise, signals get the default behavior.
.\"O Signals are named as in the
.\"O .B trap
.\"O command, except that each signal requires a separate flag.
.B \-open
フラグは、次の引数を Tcl ファイル識別子として解釈する(つまり、
.BR open
を行なって復帰する。
)
spawn id は、spawn された id として使われる。(ファイル識別子は、
もう使うべきではない。) これにより、
pty を除く、raw デバイス、ファイル、パイプラインを使うことができる。
0 が返ってくるのは、関連するプロセスがなかった時である。
spawn されたプロセスへの接続がクローズされると、Tcl ファイル識別子も
クローズされる。
.B \-leaveopen
フラグは、
.B \-open
と似た動きをするが、
spawn id をクローズした後もファイル識別子を開いたままにする点が違う。

.B \-pty
フラグは、
pty をオープンするがプロセスをspawnしない。0 が復帰するのは、
関連するプロセスがない場合である。spawn_id は、通常通り設定される。

変数
.I spawn_out(slave,fd)
には、pty スレーブとつながっているファイル識別子が設定される。
"close -slave" で close できる。

.B \-ignore
フラグは、spawn されたプロセス中で無視されるシグナルの名前を指示する。
なければ、シグナルはデフォルトの振舞いをする。シグナルの名前は
.B trap
コマンドで使う名前と同じである。各シグナルを分離するのにフラグが
必要な点を除いては。
.TP
.BI strace " level"
は、以降の命令を実行する前に表示を行なう。
(Tcl の trace は、変数のトレースを行なう。)
.I level
は、トレースへの呼び出しスタックの深さを示す。
.\"O the following command runs
.\"O .B Expect
.\"O while tracing the first 4 levels of calls,
.\"O but none below that.
例えば、
以下のコマンドは
.B Expect
最初の 4 レベルの呼び出しをトレースする。
それ以上の深さはトレースしない。
.nf

    expect \-c "strace 4" script.exp

.fi
.\"O The
.\"O .B -info
.\"O flag causes strace to return a description of the
.\"O most recent non-info arguments given.

.B -info
フラグを指定すると、strace は最後の info でない指定の内容を復帰する。
.TP
.BI stty " args"
.\"O is requested and the controlling terminal is accessed, the previous
.\"O status of the raw and echo attributes are returned in a form which can
.\"O later be used by the command.
.\"O 
.\"O For example, the arguments
.\"O .B raw
.\"O or
.\"O .B \-cooked
.\"O put the terminal into raw mode.
.\"O The arguments
.\"O .B \-raw
.\"O or
.\"O .B cooked
.\"O put the terminal into cooked mode.
.\"O The arguments
.\"O .B echo
.\"O and
.\"O .B \-echo
.\"O put the terminal into echo and noecho mode respectively.
は端末モードを変更する。外部の stty コマンドと似たようなものである。

デフォルトでは、制御している端末がアクセスされる。他の端末は、
"< /dev/tty..." を追加することでアクセスできる。(引数を一つの引数に
まとめるべきではない。)

ステータス要求はコマンドの結果としてステータスを復帰する。
ステータスが要求されずに制御している端末にアクセスする場合、直前の raw と
echo の状態を返す。

例えば、引数
.B raw
か
.B \-cooked
は、端末を raw モードに設定する。
引数
.B \-raw
か
.B cooked
は、端末を cooked モードに設定する。
引数
.B echo
か
.B \-echo
は、端末をそれぞれ echo あるいは noecho モードに設定する。
.IP
.\"O The following example illustrates how to temporarily disable echoing.
.\"O This could be used in otherwise-automatic
.\"O scripts to avoid embedding passwords in them.
.\"O (See more discussion on this under EXPECT HINTS below.)
以下の例は、一時的なエコー禁止をどうやっておこなうかを示す。
これは、他の自動スクリプトで、その中にパスワードが埋め込まれるのを
防ぐことに使われる。(もっと議論したければ、下の EXPECT ヒントに
ある。)
.nf

    stty \-echo
    send_user "Password: "
    expect_user -re "(.*)\\n"
    set password $expect_out(1,string)
    stty echo

.fi
.TP
.BI system " args"
.\"O gives
.\"O .I args
.\"O to sh(1) as input,
.\"O just as if it had been typed as a command from a terminal.
.\"O .B Expect
.\"O waits until the shell terminates.
.\"O The return status from sh is handled the same way that
.\"O .B exec
.\"O handles its return status.
は、
.I args
を、sh(1)に入力する。端末からコマンドを叩くのとちょうど同じである。
.B Expect
は、シェルが終るのを待つ。sh からの復帰値は、
.B exec
がその復帰値を扱うのと同じに扱われる。
.\"O .IP
.\"O In contrast to
.\"O .B exec
.\"O which redirects stdin and stdout to the script,
.\"O .B system
.\"O performs no redirection
.\"O (other than that indicated by the string itself).
.\"O Thus, it is possible to use programs which must talk directly to /dev/tty.
.\"O For the same reason, the results of
.\"O .B system
.\"O are not recorded in the log.
.IP
.B exec
が、スクリプトに標準入出力をリダイレクトするのと対照的に、
対照的に
.B system
は、リダイレクションを行なわない。(他に文字列そのものでリダイレクトを
指示しない限り。) それで、/dev/tty と直接話さなければならないプログラムを
使うことができる。同じ理由で、
.B system
の結果は、ログに記録されない。
.TP
.BI timestamp " [args]"
.\"O returns a timestamp.
.\"O With no arguments, the number of
.\"O seconds since the epoch is returned.
は、タイムスタンプを復帰する。
引数がない場合、復帰するまでの秒数が返る。

.\"O The
.\"O .B \-format
.\"O flag introduces a string which is returned but with 
.\"O substitutions made according to the
.\"O POSIX rules for strftime.  For example %a is replaced by an abbreviated
.\"O weekday name (i.e., Sat).  Others are:
.\"O .nf
.\"O     %a      abbreviated weekday name
.\"O     %A      full weekday name
.\"O     %b      abbreviated month name
.\"O     %B      full month name
.\"O     %c      date-time as in: Wed Oct  6 11:45:56 1993
.\"O     %d      day of the month (01-31)
.\"O     %H      hour (00-23)
.\"O     %I      hour (01-12)
.\"O     %j      day (001-366)
.\"O     %m      month (01-12)
.\"O     %M      minute (00-59)
.\"O     %p      am or pm
.\"O     %S      second (00-61)
.\"O     %u      day (1-7, Monday is first day of week)
.\"O     %U      week (00-53, first Sunday is first day of week one)
.\"O     %V      week (01-53, ISO 8601 style)
.\"O     %w      day (0-6)
.\"O     %W      week (00-53, first Monday is first day of week one)
.\"O     %x      date-time as in: Wed Oct  6 1993
.\"O     %X      time as in: 23:59:59
.\"O     %y      year (00-99)
.\"O     %Y      year as in: 1993
.\"O     %Z      timezone (or nothing if not determinable)
.\"O     %%      a bare percent sign
.\"O 
.\"O .fi
.\"O Other % specifications are undefined.  Other characters will be passed
.\"O through untouched.  Only the C locale is supported.
.\"O 
.\"O The
.\"O .B \-seconds
.\"O flag introduces a number of seconds since the epoch to be used as a source
.\"O from which to format.  Otherwise, the current time is used.
.\"O 
.\"O The
.\"O .B \-gmt
.\"O flag forces timestamp output to use the GMT timezone.  With no flag,
.\"O the local timezone is used.
.B \-format
フラグは、文字列が続くが、その文字列に
POSIX の strftime のルールに従って置換がかかる。
例えば、 %a は曜日(すなわち、Sat)とか。他は以下の通りである。:
.nf
    %a      略記された曜日の名前
    %A      略されない曜日の名前
    %b      略記された月の名前
    %B      略されない月の名前
    %c      次の形式で書かれた時刻: Wed Oct  6 11:45:56 1993
    %d      日 (01-31)
    %H      時 (00-23)
    %I      時 (01-12)
    %j      日 (001-366)
    %m      月 (01-12)
    %M      分 (00-59)
    %p      am または pm
    %S      秒 (00-61)
    %u      日 (1-7, 月曜日が週の最初の日)
    %U      週 (00-53, 最初の日曜日が第1週の最初の日)
    %V      週 (01-53, ISO 8601 スタイル)
    %w      日 (0-6)
    %W      週 (00-53, 最初の月曜日が第1週の最初の日)
    %x      date-time as in: Wed Oct  6 1993
    %X      time as in: 23:59:59
    %y      year (00-99)
    %Y      year as in: 1993
    %Z      timezone (or nothing if not determinable)
    %%      a bare percent sign

.fi
この他の % 指定は定義されていない。他の文字は変更されない。
C ロカールだけがサポートされる。

.B \-seconds
フラグは、
タイムスタンプを秒で表す。

.B \-gmt
GMT タイムゾーンで出力する。デフォルトはローカルタイムゾーンである。
.TP
.BI trap " [[command] signals]"
.\"O causes the given 
.\"O .I command
.\"O to be executed upon future receipt of any of the given signals.
.\"O The command is executed in the global scope.
.\"O If
.\"O .I command
.\"O is absent, the signal action is returned.
.\"O If
.\"O .I command 
.\"O is the string SIG_IGN, the signals are ignored.
.\"O If
.\"O .I command
.\"O is the string SIG_DFL, the signals are result to the system default.
.\"O .I signals
.\"O is either a single signal or a list of signals.  Signals may be specified
.\"O numerically or symbolically as per signal(3).  The "SIG" prefix may be omitted.
.\"O 
.\"O With no arguments (or the argument \-number),
.\"O .B trap
.\"O returns the signal number of the trap command currently being executed.
.\"O 
.\"O The
.\"O .B \-code
.\"O flag uses the return code of the command in place of whatever code Tcl
.\"O was about to return when the command originally started running.
.\"O 
.\"O The
.\"O .B \-interp
.\"O flag causes the command to be evaluated using the interpreter
.\"O active at the time the command started running
.\"O rather than when the trap was declared.
.\"O 
.\"O The
.\"O .B \-name
.\"O flag causes the
.\"O .B trap
.\"O command to return the signal name of the trap command currently being executed.
.\"O 
.\"O The
.\"O .B \-max
.\"O flag causes the
.\"O .B trap
.\"O command to return the largest signal number that can be set.
.\"O 
.\"O For example, the command "trap {send_user "Ouch!"} SIGINT" will print "Ouch!"
.\"O each time the user presses ^C.
.\"O 
.\"O By default, SIGINT (which can usually be generated by pressing ^C) and 
.\"O SIGTERM cause Expect to exit.  This is due to the following trap, created
.\"O by default when Expect starts.
.\"O .nf
.\"O 
.\"O     trap exit {SIGINT SIGTERM}
.\"O 
.\"O .fi
.\"O If you use the -D flag to start the debugger, SIGINT is redefined
.\"O to start the interactive debugger.  This is due to the following trap:
.\"O .nf
.\"O 
.\"O     trap {exp_debug 1} SIGINT
.\"O 
.\"O .fi
.\"O The debugger trap can be changed by setting the environment variable
.\"O EXPECT_DEBUG_INIT to a new trap command.  
.\"O 
.\"O You can, of course, override both of these just by adding trap
.\"O commands to your script.  In particular, if you have your own "trap
.\"O exit SIGINT", this will override the debugger trap.  This is useful
.\"O if you want to prevent users from getting to the debugger at all.
.\"O 
.\"O If you want to define your own trap on SIGINT but still trap to the
.\"O debugger when it is running, use:
.\"O .nf
.\"O 
.\"O     if ![exp_debug] {trap mystuff SIGINT}
.\"O 
.\"O .fi
.\"O Alternatively, you can trap to the debugger using some other signal.
.\"O 
.\"O .B trap
.\"O will not let you override the action for SIGALRM as this is used internally
.\"O to
.\"O .BR Expect .
.\"O The disconnect command sets SIGALRM to SIG_IGN (ignore).  You can reenable
.\"O this as long as you disable it during subsequent spawn commands.
.\"O 
.\"O See signal(3) for more info.
を実行すると、以降指定された signal を受けとると指定された
.I command
を実行する。
このコマンドは、グローバルスコープで実行される。
もし、
.I command
が指定されなければ、シグナルアクションが復帰する。
.I command
が、文字列 SIG_IGN であれば、シグナルが無視される。
.I command
が、文字列 SIG_DFL であれば、シグナルはデフォルトの動きをする。
.I signals
は、シグナルが１つでも複数のシグナルのリストでも良い。シグナルは、
数字とsignal(3)に記述されている文字列のどちらで指定しても良い。
プレフィクスの"SIG"は、省略しても良い。

引数がなければ(または、引数 \-number であれば)、
.B trap
は、trapコマンドで横取りされているシグナル番号を復帰する。

.B \-code
フラグはコマンドコードを返す。Tcl がコマンドを動かし始めた時に
帰そうとしたコードである。

.B \-interp
フラグは、trap が宣言された時でなくコマンドが開始された時にインタプリタに
コマンドを評価させる。

.B \-name
フラグは、
.B trap
コマンドに trap のかかっているシグナル名を帰す。

.B \-max
フラグは、
.B trap
コマンドに設定できる最も大きなシグナル番号を帰す。

例えば、"trap {send_user "Ouch!"} SIGINT" は、
ユーザーが ^C を押す度に "Ouch!" を表示する。

デフォルトでは、SIGINT(通常 ^C を押すと発生する)や
SIGTERM は、Expect を exit させてしまう。これは、Expect が起動時に
実行する以下の trap によって起こっている。
.nf

    trap exit {SIGINT SIGTERM}

.fi
-Dフラグを使ってデバッガを起動するなら、SIGINT が再定義されてから対話型
デバッガが起動される。これは以下の trap によって起こる。
.nf

    trap {exp_debug 1} SIGINT

.fi
デバッガのトラップは、環境変数 EXPECT_DEBUG_INIT を設定して、新しく
trap を起動することで変更できる。

もちろん、スクリプトにtrapコマンドを足すだけで例のトラップは両方とも
上書きできる。特に、自作の "trap exit SIGINT" があるなら、これは
デバッガのトラップを上書きしてしまう。ユーザーにデバッガを全く
触らせないようにするのに、便利である。

SIGINT のトラップを独自に定義したいけれど、デバッガにも同時に割り込んで
もらいたいのであれば、こう書く。:
.nf

    if ![exp_debug] {trap mystuff SIGINT}

.fi
代わりに、別のシグナルを使ってデバッガに割り込みをかけることができる。

.B trap
は、SIGALRM のアクションを上書きしない。
.BR Expect
が内部で使用しない。
disconnect コマンドは、SIGALRMを SIG_IGN (ignore)に設定する。
後から発行される spawn コマンドを実行している間、SIGALRM は
ディスエーブル中であれば再度イネーブルにできる。

もっと情報が欲しい場合、signal(3) を参照すること。
.TP
.BI wait " [args]"
.\"O delays until a spawned process (or
.\"O the current process if none is named) terminates.
は、spawn されたプロセス(あるいは、名前つきのプロセスがなければ現在のプロセス)
が終了するのを待つ。
.IP
.\"O .B wait
.\"O normally returns a list of four integers.
.\"O The first integer is the pid of the process that was waited upon.
.\"O The second integer is the corresponding spawn id.
.\"O The third integer is -1 if an operating system error occurred, or 0 otherwise.
.\"O If the third integer was 0, the fourth integer is the status returned by
.\"O the spawned process.  If the third integer was -1, the fourth integer is
.\"O the value of errno set by the operating system.  The global variable
.\"O errorCode is also set.
.B wait
は、通常 4 つの整数のリストを帰す。
最初の整数は、終了を待ち構えているプロセスの pid である。
2 つめの整数は、関連する spawn id である。
3 つめの整数は、オペレーティングシステムエラーがあれば -1、
そうでなければ、0 である。
3 つめの整数が 0 であれば、4 つめの整数はspawnされたプロセスからのリターン
コードである。3 つめの整数が -1 であれば、4 つめの整数はオペレーティングシステム
によって設定された errno の値である。グローバル変数 errorCode も設定される。

.\"O Additional elements may appear at the end of the return value from
.\"O .BR wait .
.\"O An optional fifth element identifies a class of information.
.\"O Currently, the only possible value for this element is CHILDKILLED in
.\"O which case the next two values are the C-style signal name and a short
.\"O textual description.
追加の要素が
.BR wait
の復帰値に加わっても構わない。オプションの5つめの要素は、情報クラスの
識別子である。今のところ、この要素の唯一可能な値は CHILDKILLED で、
その場合、次の二つの値が C スタイルのシグナル名と短い文書による記述である。
.IP
.\"O The
.\"O .B \-i
.\"O flag declares the process to wait corresponding to the named spawn_id
.\"O (NOT the process id).
.\"O Inside a SIGCHLD handler,
.\"O it is possible to wait for any spawned process by using the spawn id -1.
.\"O 
.\"O The
.\"O .B \-nowait
.\"O flag causes the wait to return immediately with the indication of a
.\"O successful wait.  When the process exits (later), it will automatically
.\"O disappear without the need for an explicit wait.
.B \-i
フラグによって、wait を行なう名前付き spawn_id(プロセス ID ではなく)を
指定する。SIGCHLD ハンドラの内部では、spawn ID -1 を指定することで、
spawn されたプロセスのいずれかを wait できる。

.B \-nowait
フラグを指定すると、wait が成功の復帰値で即時復帰する。
(あとで)そのプロセスが exit すると、自動的に後始末が行なわれ、明示的に
wait する必要がない。

.\"O The
.\"O .B wait
.\"O command may also be used wait for a forked process using the arguments
.\"O "-i -1".  Unlike its use with spawned processes, this command can be
.\"O executed at any time.  There is no control over which process is
.\"O reaped.  However, the return value can be checked for the process id.
.B wait
コマンドは、引数に "-i -1" を指定することによって、
fork したプロセスを待つためにも使われる。
spawn したプロセスに用いられる場合と異なり、
このコマンドはいつでも実行できる。
どのプロセスを待つかを制御することは出来ないが、
返り値はプロセス ID としてチェックできる。

.\"O .SH LIBRARIES
.SH ライブラリ
.\"O Expect automatically knows about two built-in libraries for Expect scripts.
.\"O These are defined by the directories named in the variables
.\"O exp_library and exp_exec_library.  Both are meant to contain utility
.\"O files that can be used by other scripts.
.\"O 
.\"O exp_library contains architecture-independent files.  exp_exec_library
.\"O contains architecture-dependent files.  Depending on your system, both
.\"O directories may be totally empty.  The existence of the file
.\"O $exp_exec_library/cat-buffers describes whether your /bin/cat buffers
.\"O by default.
.\"O
Expect は、スクリプトのための二つのビルトインライブラリを自動的に理解する。
それらは変数 exp_library と変数 exp_exec_library に設定されたディレクトリ名と
して定義される。これらのディレクトリには、他のスクリプトによって使える
ユーティリティファイルが入っている。

exp_library には、アーキテクチャに依存しないファイルが格納される。
exp_exec_library には、アーキテクチャに依存するファイルが格納される。
あなたのシステムによっては、両方のディレクトリが空という場合もあり得る。
ファイル $exp_exec_library/cat-buffers の存在は、あなたのシステムの
/bin/cat がデフォルトでバッファリングされているかどうかに左右される。

.\"O .SH PRETTY-PRINTING
.SH 整形印刷
.\"O A vgrind definition is available for pretty-printing
.\"O .B Expect
.\"O scripts.
.\"O Assuming the vgrind definition supplied with the
.\"O .B Expect
.\"O distribution is
.\"O correctly installed, you can use it as:
.\"O .nf
.\"O 
.\"O     vgrind \-lexpect file
.\"O 
.\"O .fi
.\"O
.B Expect
スクリプトをきれいに印刷するための vgrind の定義がある。
.B Expect
ディストリビューションと一緒に配布されている vgrind 定義が正しく
インストールされていると仮定して、こうすれば使える。
.nf

    vgrind \-lexpect file

.fi

.\"O .SH EXAMPLES
.SH 例
.\"O It many not be apparent how to put everything together that the man page
.\"O describes.  I encourage you to read and try out the examples in
.\"O the example directory of the
.\"O .B Expect
.\"O distribution.
.\"O Some of them are real programs.  Others are simply illustrative
.\"O of certain techniques, and of course, a couple are just quick hacks.
.\"O The INSTALL file has a quick overview of these programs.
マニュアルページによる記述では、あらゆるものをどう組み合わせるのかと
いうことが明白ではない。私としては、
.B Expect
ディストリビューションの
example ディレクトリにある例を読んで試してみて欲しいと思う。
いくつかは本物のプログラムである。それ以外は特定のテクニックの単純な解説、
あと、もちろん、単なるクイックハックが少しある。
INSTALL ファイルにはこれらのプログラムの簡単な梗概が書かれている。
.PP
.\"O The
.\"O .B Expect
.\"O papers (see SEE ALSO) are also useful.  While some papers
.\"O use syntax corresponding to earlier versions of Expect, the accompanying
.\"O rationales are still valid and go into a lot more detail than this
.\"O man page.
.B Expect
の論文も役に立つ(関連項目参照)。いくつかは、初期バージョンの Expect の
文法を使っているが、それとともにある根本的な考えは、なお有効であり、
このマニュアルページより詳細に書かれている。

.\"O .SH CAVEATS
.SH 警告
.\"O Extensions may collide with Expect's command names.  For example, 
.\"O .B send
.\"O is defined by Tk for an entirely different purpose.
.\"O For this reason, most of the
.\"O .B Expect
.\"O commands are also available as "exp_XXXX".
.\"O Commands and variables beginning with "exp", "inter", "spawn",
.\"O and "timeout" do not have aliases.
.\"O Use the extended command names if you need this compatibility between environments.
.\"O 
.\"O .B Expect
.\"O takes a rather liberal view of scoping.
.\"O In particular, variables read by commands specific to the
.\"O .B Expect
.\"O program will be sought first from the local scope, and if not found, in the
.\"O global scope.  For example, this
.\"O obviates the need to place "global timeout" in every
.\"O procedure you write that uses
.\"O .BR expect .
.\"O On the other hand, variables written are always in the local scope (unless
.\"O a "global" command has been issued).  The most common problem this causes
.\"O is when spawn is executed in a procedure.  Outside the procedure, 
.\"O .I spawn_id
.\"O no longer exists, so the spawned process is no longer accessible
.\"O simply because of scoping.  Add a "global spawn_id" to such a procedure.
.\"O 
.\"O If you cannot enable the multispawning capability
.\"O (i.e., your system supports neither select (BSD *.*), poll (SVR>2),
.\"O nor something equivalent),
.\"O .B Expect
.\"O will only be able to control a single process at a time.
.\"O In this case, do not attempt to set
.\"O .IR spawn_id ,
.\"O nor should you execute processes via exec while a spawned process
.\"O is running.  Furthermore, you will not be able to
.\"O .B expect
.\"O from multiple processes (including the user as one) at the same time.
.\"O 
.\"O Terminal parameters can have a big effect on scripts.  For example, if
.\"O a script is written to look for echoing, it will misbehave if echoing
.\"O is turned off.  For this reason, Expect forces sane terminal
.\"O parameters by default.  Unfortunately, this can make things unpleasant
.\"O for other programs.  As an example, the emacs shell wants to change
.\"O the "usual" mappings: newlines get mapped to newlines instead of
.\"O carriage-return newlines, and echoing is disabled.  This allows one to
.\"O use emacs to edit the input line.  Unfortunately, Expect cannot
.\"O possibly guess this.
.\"O 
.\"O You can request that Expect not override its default setting of
.\"O terminal parameters, but you must then be very careful when writing
.\"O scripts for such environments.  In the case of emacs, avoid depending
.\"O upon things like echoing and end-of-line mappings.
.\"O 
拡張は Expect のコマンド名と衝突するかもしれない。例えば、
.B send
は、Tk では全く別の目的で定義されている。
そういう理由で、ほとんどの
.B Expect
コマンドは、"exp_XXXX" という 別の記法(エイリアス)もサポートする。
"exp", "inter", "spawn", "timeout" で始まるコマンドと変数は、
エイリアスを持たない。
この環境間の互換性が必要であれば、拡張されたコマンド名を用いること。

.B Expect
は、かなり自由なスコープを持っている。特に、
.B Expect
プログラムで指定したコマンドにより読み込ませる変数は、そのローカルスコープ
内でまず探索され、見つからなければ、グローバルスコープで探索される。
例えば、こうすることで
.BR expect
を使う全てのプロシジャに "global timeout" を書く必要が
なくなる。
逆に、プロシジャ内に書かれた変数は全てローカルスコープ内に設定される。
("global"コマンドを指定しない限りは)。この動作が引き起こすもっとも共通した
問題は、spawn がプロシジャ内で実行された時である。プロシジャの外では、
.I spawn_id
はスコープのため、もはや存在しないので spawn されたプロセスは単純には
アクセス不能となる。そのようなプロセスには、"global spawn_id"を
付け加えねばならない。

multi-spawn 機能が使えない(つまり、あなたのシステムが
select (BSD *.*), poll (SVR>2),または、それと等価なもの のいずれも
サポートしていない)場合、
.B Expect
は、同時に 1 プロセスしか制御できない。
この場合、
.IR spawn_id
を無理に設定したり、spawn されたプロセスが走っている間に exec を使って
プロセスを実行したりしてはならない。さらに、複数のプロセス(片方が
ユーザーでも)から同時に
.B expect
することもできない。

端末制御パラメタは、スクリプトに大きな影響を与える。例えば、
スクリプトがエコーを探すように書かれていれば、エコーをオフにすると
動作がおかしくなる。この理由で、Expect はデフォルトで 正気の
端末パラメタを設定する。不幸なことに、この設定が他のプログラムではまずい
場合がある。例えば、emacs シェルは"通常の"マッピングを変更しようとする。
: newlinesは、carriage-return newlines に変換されず newlines にマップされる。
そして、エコーは行なわれない。こうマップされることで、emacs は入力行を
編集できる。残念ながら、Expect はこのマッピングを検出できない。

Expect が端末パラメタのデフォルト設定を上書きしないように指定することが
できるが、そういった環境で動かすスクリプトを書くときは細心の注意が
必要である。emacs の場合、エコーや改行コードのマッピングを回避しなければ
ならない。

.\"O The commands that accepted arguments braced into a single list (the
.\"O .B expect
.\"O variants and
.\"O .BR interact )
.\"O use a heuristic to decide if the list is actually one argument or
.\"O many.  The heuristic can fail only in the case when the list actually
.\"O does represent a single argument which has multiple embedded \\n's
.\"O with non-whitespace characters between them.  This seems sufficiently
.\"O improbable, however the argument "\-nobrace" can be used to force a
.\"O single argument to be handled as a single argument.  This could
.\"O conceivably be used with machine-generated Expect code.  Similarly,
.\"O -brace forces a single argument to be handle as multiple patterns/actions.
(
.B expect
とその変種、および、
.BR interact
といった)1 つのリストにブレースされた引数を受けとるコマンドは、
リストが引数をどれだけ持っているのかを判断するのに、発見的手法を用いる。
その発見的手法はが失敗する唯一の場合は、引数の一つに複数の\\nが埋め込まれ、
その間にホワイトスペースがない場合である。これは十分検出不能な状態だが、
引数"\-nobrace" で、強制的に一つの引数として扱うことができる。
自動的に生成された Expect コード中で使われるかもしれない。
同様に、-brace は複数のパターン/アクションをひとつの引数として扱うことを
強制する。

.\"O .SH BUGS
.SH バグ
.\"O It was really tempting to name the program "sex" (for either "Smart EXec"
.\"O or "Send-EXpect"), but good sense (or perhaps just Puritanism) prevailed.
プログラムに "sex" ("Smart EXec" か "Send-EXpect" の略) という名前を
つけるのは実に魅力的だったのだが、センスの良い方(あるいは、
単にピューリタニズム)が優先された。

.\"O On some systems, when a shell is spawned, it complains about not being
.\"O able to access the tty but runs anyway.  This means your system has a
.\"O mechanism for gaining the controlling tty that
.\"O .B Expect
.\"O doesn't know about.  Please find out what it is, and send this information
.\"O back to me.
シェルが spawn されるとttyにアクセスできないと文句をいって、しかし、動作はする
というシステムがある。これは、このシステムがtty制御を得るための機構を
持っているが
.B Expect
はそれを知らないという意味である。どういう仕組みか調べて、その情報を私に
知らせてほしい。

.\"O Ultrix 4.1 (at least the latest versions around here) considers
.\"O timeouts of above 1000000 to be equivalent to 0.
.\"O 
.\"O Digital UNIX 4.0A (and probably other versions) refuses to allocate
.\"O ptys if you define a SIGCHLD handler.  See grantpt page for more info.
.\"O 
.\"O IRIX 6.0 does not handle pty permissions correctly so that if Expect
.\"O attempts to allocate a pty previously used by someone else, it fails.
.\"O Upgrade to IRIX 6.1.
Ultrix 4.1 (少なくとも最新バージョンのあたり) では、
1000000 を超えるタイムアウトを 0 とみなしてしまう。

Digital UNIX 4.0A (おそらく他のバージョンも)は SIGCHLD ハンドラを
定義すると、pty の割り付けを拒否する。詳細は grantpt ページを参照のこと。

IRIX 6.0 は、pty へのアクセス制御を正確に扱えない。それで、
Expect は、pty がアロケートできない場合は、他の人が前に使った pty の
アロケートを試みる。
IRIX 6.1 にアップグレードすること。

.\"O Telnet (verified only under SunOS 4.1.2) hangs if TERM is not set.
.\"O This is a problem under cron, at and in cgi scripts, which do not
.\"O define TERM.  Thus, you must set it explicitly - to what type is
.\"O usually irrelevant.  It just has to be set to something!  The
.\"O following probably suffices for most cases.
telnet (SunOS 4.1.2 でのみ確認)は、TERM が設定されてないと
ハングする。この問題は cron や at や CGI スクリプトで使う時に問題だ
(設定しないので)。それで、
明示的に指定しなくてはならない - 本当のタイプは通常関係ない。
何かに設定してないと駄目なのだ! 以下の記述はおそらくほとんどの場合を
満足させるだろう。
.nf

    set env(TERM) vt100

.fi

.\"O Tip (verified only under BSDI BSD/OS 3.1 i386) hangs if SHELL and HOME
.\"O are not set.  This is a problem under cron, at and in cgi scripts,
.\"O which do not define these environment variables.  Thus, you must set
.\"O them explicitly - to what type is usually irrelevant.  It just has to
.\"O be set to something!  The following probably suffices for most cases.
tipt (BSDI BSD/OS 3.1 i386 でのみ確認)は、SHELL と HOME が設定されてないと
ハングする。この問題は cron や at や CGI スクリプトで使う時に問題だ
(設定しないので)。それで、
明示的に指定しなくてはならない - 本当のタイプは通常関係ない。
何かに設定してないと駄目なのだ! 以下の記述はおそらくほとんどの場合を
満足させるだろう。
.nf

    set env(SHELL) /bin/sh
    set env(HOME) /usr/local/bin

.fi


.\"O Some implementations of ptys are designed so that the kernel throws
.\"O away any unread output after 10 to 15 seconds (actual number is
.\"O implementation-dependent) after the process has closed the file
.\"O descriptor.  Thus
.\"O .B Expect
.\"O programs such as
.\"O .nf
.\"O 
.\"O     spawn date
.\"O     sleep 20
.\"O     expect
.\"O 
.\"O .fi
.\"O will fail.  To avoid this, invoke non-interactive programs with
.\"O .B exec
.\"O rather than
.\"O .BR spawn .
.\"O While such situations are conceivable, in practice I have never
.\"O encountered a situation in which the final output of a truly
.\"O interactive program would be lost due to this behavior.
.\"O 
.\"O On the other hand, Cray UNICOS ptys throw away any unread output
.\"O immediately after the process has closed the file descriptor.  I have
.\"O reported this to Cray and they are working on a fix.
.\"O 
.\"O Sometimes a delay is required between a prompt and a response, such as
.\"O when a tty interface is changing UART settings or matching baud rates
.\"O by looking for start/stop bits.  Usually, all this is require is to
.\"O sleep for a second or two.  A more robust technique is to retry until
.\"O the hardware is ready to receive input.  The following example uses
.\"O both strategies:
.\"O .nf
.\"O 
.\"O     send "speed 9600\\r";
.\"O     sleep 1
.\"O     expect {
.\"O         timeout {send "\\r"; exp_continue}
.\"O         $prompt
.\"O     }
.\"O 
.\"O .fi
.\"O
pty のインプリメントの中には、プロセスがファイル記述子をクローズした後、
読んでない出力を 10 から 15 秒後(この値はインプリメントに依存)に投げてくる
ものがある。それゆえ、
.nf

    spawn date
    sleep 20
    expect

.fi
のような
.B Expect
プログラムは失敗する。失敗しないように非対話的なプログラムでは
.BR spawn
せずに
.B exec
すること。こういう状況は考えられるが、実際には私はまだその状態に
陥ったことがない。つまり、この原因で対話プログラムの最後の出力を
取りこぼすという状態になったことがない。

一方、Cray UNICOS の pty は読み込んでいない出力をファイルディスクリプタを
プロセスが閉じるとすぐに投げてくる。私は Cray にこの動きについて報告し、
回避するための修正を行なった。

プロンプトと応答の間にディレイが必要な場合がある。tty インターフェースが
UART の設定を変えたり、スタート/ストップビットを探してボーレートを合わせて
いる時などである。通常、ここで必要とされているものは 1 秒か 2 秒の待ち合わせである。
もっとしっかりしたやり方はハードウェアが入力を受ける準備ができるまで繰り返す
ことである。以下の例は、両方の戦略を採用している。:
.nf

    send "speed 9600\\r";
    sleep 1
    expect {
        timeout {send "\\r"; exp_continue}
        $prompt
    }

.fi

.\"O trap \-code will not work with any command that sits in Tcl's event
.\"O loop, such as sleep.  The problem is that in the event loop, Tcl
.\"O discards the return codes from async event handlers.  A workaround is
.\"O to set a flag in the trap code.  Then check the flag immediately after
.\"O the command (i.e., sleep).
\-code をトラップするのは Tcl のイベントループに依存しているコマンド
(sleep など)では動かない。
問題は、イベントループの中では Tcl は非同期イベントハンドラからの
返り値を捨てているからである。
回避方法としては、トラップコードでフラグをセットし、
コマンド(sleep など)の直後でフラグをチェックすることである。

.\"O .SH EXPECT HINTS
.SH EXPECT ヒント
.\"O There are a couple of things about
.\"O .B Expect
.\"O that may be non-intuitive.
.\"O This section attempts to address some of these things with a couple of
.\"O suggestions.
.\"O 
.\"O A common expect problem is how to recognize shell prompts.  Since
.\"O these are customized differently by differently people and different
.\"O shells, portably automating rlogin can be difficult without knowing
.\"O the prompt.  A reasonable convention is to have users store a regular
.\"O expression describing their prompt (in particular, the end of it) in
.\"O the environment variable EXPECT_PROMPT.  Code like the following
.\"O can be used.  If EXPECT_PROMPT doesn't exist, the code still has a good chance of functioning correctly.
.\"O .nf
.\"O 
.\"O     set prompt "(%|#|\\\\$) $"          ;# default prompt
.\"O     catch {set prompt $env(EXPECT_PROMPT)}
.\"O 
.\"O     expect -re $prompt
.\"O 
.\"O .fi
.\"O I encourage you to write
.\"O .B expect
.\"O patterns that include the end of whatever
.\"O you expect to see.  This avoids the possibility of answering a question
.\"O before seeing the entire thing.  In addition, while you may well be
.\"O able to answer questions before seeing them entirely, if you answer
.\"O early,  your answer may appear echoed back in the middle of the question.
.\"O In other words, the resulting dialogue will be correct but look scrambled.
.\"O 
.\"O Most prompts include a space character at the end.
.\"O For example, the prompt from ftp is 'f', 't', 'p', '>' and <blank>.
.\"O To match this prompt, you must account for each of these characters.
.\"O It is a common mistake not to include the blank.
.\"O Put the blank in explicitly.
.\"O 
.\"O If you use a pattern of the form X*, the * will match all the output
.\"O received from the end of X to the last thing received.
.\"O This sounds intuitive but can be somewhat confusing because the phrase
.\"O "last thing received" can vary depending upon the speed of the computer
.\"O and the processing of I/O both by the kernel and the device driver.
.\"O
.B Expect
について、直観的でない点が少しある。
このセクションではそういったことの指摘とそれに対する示唆を試みる。

共通の expect の問題は、シェルプロンプトを認識する方法である。
その設定も、それを扱う人も、使うシェルもまちまちなので、実際に出てくる
プロンプトを知らずに、汎用的に rlogin を自動化することは困難である。
妥当な線は、ユーザーにプロンプトにマッチする正規表現(特にプロンプトの
終りの部分)を環境変数 EXPECT_PROMPT に保存させることである。
以下のようなコードでできる。
EXPECT_PROMPT がなくても、コードは正しく動く可能性がある。
.nf

    set prompt "(%|#|\\\\$) $"          ;# default prompt
    catch {set prompt $env(EXPECT_PROMPT)}

    expect -re $prompt

.fi
私としては、見えると思っているものの終りの部分を含んだ
.B expect
パターンを書くように勧める。そうすれば、全体を見る前に応答を返してしまう
ことを避けることができる。さらに、全体が見える前に答えることもできるが
その文字は質問に混ざって echo される。言い替えれば、会話は正常だが見た目は
混ざって見える。

ほとんどのプロンプトの終りの文字はスペースである。例えば、
ftpからのプロンプトは、'f', 't', 'p', '>' そして <blank> である。
このプロンプトにマッチさせるには、この文字の一つ一つにマッチしなければ
ならない。blank を含めないのは、よくある誤りである。明示的に blank を
入れるように。

X* の形のパターンを使うのであれば、* はXから最後に受けとる何かまでの
全てにマッチする。これは一見直観的だが、"最後に受けとる何か"が
コンピュータの速度とカーネルとデバイスドライバによるI/O処理によって
変わってしまうので混乱するだろう。
.PP
.\"O In particular, humans tend to see program output arriving in huge chunks
.\"O (atomically) when in reality most programs produce output one
.\"O line at a time.  Assuming this is the case, the * in the pattern of the
.\"O previous paragraph may only match the end of the current line even though
.\"O there seems to be more, because at the time of the match that was all
.\"O the output that had been received.
特に、人間はプログラムの出力が巨大なひとまとまりとしてやってくると思いがち
だが、実際には、ほとんどのプログラムは一行を一度に送る。
こう仮定すると、直前の段落のパターンにあった * は、行の終りにしか
マッチしないかも知れない。たとえ、もっと入力があると思われる場合でも
出力を全て受けとった時点でしかマッチを行なわないのである。
.PP
.\"O .B expect
.\"O has no way of knowing that further output is coming unless your
.\"O pattern specifically accounts for it.
.B expect
は、指定したパターンが教えてくれない限り、出力がさらにやってくるのか
どうかわからない。
.PP
.\"O Even depending on line-oriented buffering is unwise.  Not only do programs
.\"O rarely make promises about the type of buffering they do, but system
.\"O indigestion can break output lines up so that lines break at seemingly
.\"O random places.  Thus, if you can express the last few characters
.\"O of a prompt when writing patterns, it is wise to do so.
.\"O 
.\"O If you are waiting for a pattern in the last output of a program
.\"O and the program emits something else instead, you will not be able to
.\"O detect that with the
.\"O .B timeout
.\"O keyword.  The reason is that
.\"O .B expect
.\"O will not timeout \- instead it will get an
.\"O .B eof
.\"O indication.
.\"O Use that instead.  Even better, use both.  That way if that line
.\"O is ever moved around, you won't have to edit the line itself.
.\"O 
.\"O Newlines are usually converted to carriage return, linefeed sequences
.\"O when output by the terminal driver.  Thus, if you want a pattern that
.\"O explicitly matches the two lines, from, say, printf("foo\\nbar"),
.\"O you should use the pattern "foo\\r\\nbar".
行指向のバッファリングを行なっている場合ですら、賢いやり方とはいえない。
プログラムはバッファリングのタイプをめったに保証しないだけでなく、その際に
消化不良を起こして出力行を中断し、行末をバッファ中のランダムな位置に
置いてしまう。
それで、パターンを書く時には、プロンプトの最後の何文字かを入れておいた方が
賢いやり方といえるのである。

プログラムの最後の出力にあるパターンを待ち、実際には何がしか他のものが
発行されている場合には
.B timeout
キーワードで判定することができない。理由は、
.B expect
が、タイムアウトしない \- そのかわりに
.B eof
を見つけられる \-
からである。
代わりになるものを使うこと。もっと良いのは、両方使うことだろう。
行が回り込んだ場合でも、行そのものを編集するべきではない。

tty ドライバによって出力される時に
newline は、普通 carriage return, linefeed の組に変換される。
それで、2 ラインにマッチするには、例えば、printf("foo\\nbar") に
マッチさせるには、"foo\\r\\nbar" というパターンを使うことになる。
.PP
.\"O A similar translation occurs when reading from the user, via
.\"O .BR expect_user .
.\"O In this case, when you press return, it will be
.\"O translated to a newline.  If
.\"O .B Expect
.\"O then passes that to a program
.\"O which sets its terminal to raw mode (like telnet), there is going to
.\"O be a problem, as the program expects a true return.  (Some programs
.\"O are actually forgiving in that they will automatically translate
.\"O newlines to returns, but most don't.)  Unfortunately, there is no way to find
.\"O out that a program put its terminal into raw mode.
似たような変換は、ユーザーから
.BR expect_user
を通して入力を読み込む時にも起こる。この場合、ユーザーがリターンを
押すと、それは newline に変換される。その後、
.B Expect
が端末モードを raw モード(telnet のような)を設定すると、問題が発生する
可能性がある。プログラムが本当のリターンを待ってしまうからである。(プログラムの
中には、newline をリターンに変えても大丈夫なものもあるが、ほとんどはだめである。)
残念ながら、プログラムが端末を raw モードにすることを検出する方法がない。
.PP
.\"O Rather than manually replacing newlines with returns, the solution is to
.\"O use the command "stty raw", which will stop the translation.
.\"O Note, however, that this means that you will no longer get the cooked
.\"O line-editing features.
手で newline をリターンに変えるのではなく、"stty raw"を使うのが解決策である。
stty raw は、変換を停止する。しかし、こうすると cooked モードの行編集機能が
使えなくなるということに注意すること。
.PP
.\"O .B interact
.\"O implicitly sets your terminal to raw mode so this problem will not arise then.
.\"O 
.\"O It is often useful to store passwords (or other private information)
.\"O in
.\"O .B Expect
.\"O scripts.  This is not recommended since anything that is
.\"O stored on a computer is susceptible to being accessed by anyone.
.\"O Thus, interactively prompting for passwords from a script is a smarter
.\"O idea than embedding them literally.  Nonetheless, sometimes such embedding
.\"O is the only possibility.
.B interact
は、端末を raw モードに設定するので、この問題は発生しない。

.B Expect
スクリプトの中でパスワード(や他の機密情報)を保存すると便利なことは
よくある。だれかのアクセスを受けるとその影響を受けてしまうコンピュータで
そういうことをするのは勧められない。それで、パスワードのプロンプトを
スクリプトから出すのが、文字通りパスワードを埋め込むよりは、良い考えと
いえる。とはいうものの、そういった埋め込みをするしかない場合もある。
.PP
.\"O Unfortunately, the UNIX file system has no direct way of creating
.\"O scripts which are executable but unreadable.  Systems which support
.\"O setgid shell scripts may indirectly simulate this as follows:
不幸なことに、UNIX のファイルシステムは「実行可能で読めない」スクリプトを
作る直接の方法がない。setgid シェルスクリプトをサポートしたシステムでは、
次のようにすることで間接的にシミュレートできる。
.PP
.\"O Create the
.\"O .B Expect
.\"O script (that contains the secret data) as usual.
.\"O Make its permissions be 750 (\-rwxr\-x\-\-\-) and owned by a trusted group
,
.\"O i.e., a group which is allowed to read it.  If necessary, create a new
.\"O group for this purpose.  Next, create a /bin/sh script with
.\"O permissions 2751 (\-rwxr\-s\-\-x) owned by the same group as before.
.B Expect
スクリプト(機密情報の入った)を普通に作る。
そのパーミッションを 750 (\-rwxr\-x\-\-\-) に設定し、trusted group 
つまり、読んでも良いグループ の所有とする。必要なら、この目的のための
新しいグループをつくること。次に、/bin/sh スクリプトを パーミッション
 2751 (\-rwxr\-s\-\-x) で、同じグループの所有で作成する。
.PP
.\"O The result is a script which may be executed (and read) by anyone.
.\"O When invoked, it runs the
.\"O .B Expect
.\"O script.
こうすると、シェルスクリプトはだれからも実行でき(かつ、読め)る。
実行すると、それは
.B Expect
スクリプトを実行する。

.\"O .SH SEE ALSO
.SH 関連項目

.BR Tcl (3),
.BR libexpect (3)
.br
.I
"Exploring Expect: A Tcl-Based Toolkit for Automating Interactive Programs"
\fRby Don Libes, pp. 602, ISBN 1-56592-090-2, O'Reilly and Associates, 1995.
.br
.I
"expect: Curing Those Uncontrollable Fits of Interactivity" \fRby Don Libes,
Proceedings of the Summer 1990 USENIX Conference,
Anaheim, California, June 11-15, 1990.
.br
.I
"Using
.B expect
to Automate System Administration Tasks" \fRby Don Libes,
Proceedings of the 1990 USENIX Large Installation Systems Administration
Conference, Colorado Springs, Colorado, October 17-19, 1990.
.br
.I
"Tcl: An Embeddable Command Language" \fRby John Ousterhout,
Proceedings of the Winter 1990 USENIX Conference,
Washington, D.C., January 22-26, 1990.
.br
.I
"expect: Scripts for Controlling Interactive Programs" \fRby Don Libes,
Computing Systems, Vol. 4, No. 2, University of California Press Journals,
November 1991.
.br
.I
"Regression Testing and Conformance Testing Interactive Programs", \fRby Don
Libes, Proceedings of the Summer 1992 USENIX Conference, pp. 135-144,
San Antonio, TX, June 12-15, 1992.
.br
.I
"Kibitz \- Connecting Multiple Interactive Programs Together", \fRby Don Libes,
Software \- Practice & Experience, John Wiley & Sons, West Sussex, England,
Vol. 23, No. 5, May, 1993.
.br
.I
"A Debugger for Tcl Applications", \fRby Don Libes,
Proceedings of the 1993 Tcl/Tk Workshop, Berkeley, CA, June 10-11, 1993.

.\"O .SH AUTHOR
.SH 著者

Don Libes, National Institute of Standards and Technology

.\"O .SH ACKNOWLEDGMENTS
.SH 謝辞
.\"O Thanks to John Ousterhout for Tcl, and Scott Paisley for inspiration.
.\"O Thanks to Rob Savoye for Expect's autoconfiguration code.
Tclを生み出した John Ousterhout と、インスピレーションを与えてくれた
Scott Paisley に感謝する。
Expect のオートコンフィギュレーションコードについて、 Rob Savoye に感謝する。

.PP
.\"O The HISTORY file documents much of the evolution of
.\"O .BR expect .
.\"O It makes interesting reading and might give you further insight to this
.\"O software.  Thanks to the people mentioned in it who sent me bug fixes
.\"O and gave other assistance.
HISTORY ファイルに
.B expect
の進化の大部分が記述されている。このファイルは面白く読めて、かつ、
あなたのこのソフトウェアへの洞察をより深くするだろう。このファイルに
書かれている、私にバグフィックスを送ってくれた人たちや、他の援助を
してくれた人たちに感謝する。
.PP
.\"O Design and implementation of
.\"O .B Expect
.\"O was paid for in part by the U.S. government and is therefore in the public
.\"O domain.
.\"O However the author and NIST would like credit
.\"O if this program and documentation or portions of them are used.
.B Expect
の設計と実装は、部分的にアメリカ政府からその対価をもらっているので、
パブリックドメインである。しかし、このプログラムとドキュメントあるいは
その一部が使われたなら、著者と NIST への謝辞を述べてもらいたい。
